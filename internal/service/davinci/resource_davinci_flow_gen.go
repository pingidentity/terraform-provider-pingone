// Copyright Â© 2025 Ping Identity Corporation
// Code generated by ping-terraform-plugin-framework-generator

//go:build beta

package davinci

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/int32validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int32default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/pingidentity/pingone-go-client/pingone"
	pingonetypes "github.com/pingidentity/pingone-go-client/types"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework"
	internalstringvalidator "github.com/pingidentity/terraform-provider-pingone/internal/framework/stringvalidator"
	"github.com/pingidentity/terraform-provider-pingone/internal/verify"
)

var (
	_ resource.Resource                = &davinciFlowResource{}
	_ resource.ResourceWithConfigure   = &davinciFlowResource{}
	_ resource.ResourceWithImportState = &davinciFlowResource{}
)

func NewDavinciFlowResource() resource.Resource {
	return &davinciFlowResource{}
}

type davinciFlowResource serviceClientType

func (r *davinciFlowResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_davinci_flow"
}

func (r *davinciFlowResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	resourceConfig, ok := req.ProviderData.(framework.ResourceType)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected the provider client, got: %T. Please report this issue to the provider maintainers.", req.ProviderData),
		)

		return
	}

	r.Client = resourceConfig.Client
	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialised",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.",
		)
		return
	}
}

type davinciFlowResourceModel struct {
	Color            types.String  `tfsdk:"color"`
	Connectors       types.Set     `tfsdk:"connectors"`
	CurrentVersion   types.Float32 `tfsdk:"current_version"`
	Description      types.String  `tfsdk:"description"`
	Enabled          types.Bool    `tfsdk:"enabled"`
	EnvironmentId    types.String  `tfsdk:"environment_id"`
	GraphData        types.Object  `tfsdk:"graph_data"`
	Id               types.String  `tfsdk:"id"`
	InputSchema      types.List    `tfsdk:"input_schema"`
	Name             types.String  `tfsdk:"name"`
	OutputSchema     types.Object  `tfsdk:"output_schema"`
	PublishedVersion types.Float32 `tfsdk:"published_version"`
	Settings         types.Object  `tfsdk:"settings"`
	Trigger          types.Object  `tfsdk:"trigger"`
}

func (r *davinciFlowResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	graphDataElementsEdgesDataAttrTypes := map[string]attr.Type{
		"id":     types.StringType,
		"source": types.StringType,
		"target": types.StringType,
	}
	graphDataElementsEdgesPositionAttrTypes := map[string]attr.Type{
		"x": types.NumberType,
		"y": types.NumberType,
	}
	graphDataElementsEdgesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsEdgesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsEdgesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsEdgesElementType := types.ObjectType{AttrTypes: graphDataElementsEdgesAttrTypes}
	settingsJsLinksAttrTypes := map[string]attr.Type{
		"crossorigin":    types.StringType,
		"defer":          types.BoolType,
		"integrity":      types.StringType,
		"label":          types.StringType,
		"referrerpolicy": types.StringType,
		"type":           types.StringType,
		"value":          types.StringType,
	}
	settingsJsLinksElementType := types.ObjectType{AttrTypes: settingsJsLinksAttrTypes}
	settingsAttrTypes := map[string]attr.Type{
		"csp":                                types.StringType,
		"css":                                types.StringType,
		"css_links":                          types.SetType{ElemType: types.StringType},
		"custom_error_screen_brand_logo_url": types.StringType,
		"custom_error_show_footer":           types.BoolType,
		"custom_favicon_link":                types.StringType,
		"custom_logo_urlselection":           types.Int32Type,
		"custom_title":                       types.StringType,
		"default_error_screen_brand_logo":    types.BoolType,
		"flow_http_timeout_in_seconds":       types.Int32Type,
		"flow_timeout_in_seconds":            types.Int32Type,
		"intermediate_loading_screen_css":    types.StringType,
		"intermediate_loading_screen_html":   types.StringType,
		"js_custom_flow_player":              types.StringType,
		"js_links":                           types.SetType{ElemType: settingsJsLinksElementType},
		"log_level":                          types.Int32Type,
		"require_authentication_to_initiate": types.BoolType,
		"scrub_sensitive_info":               types.BoolType,
		"sensitive_info_fields":              types.SetType{ElemType: types.StringType},
		"use_csp":                            types.BoolType,
		"use_custom_css":                     types.BoolType,
		"use_custom_flow_player":             types.BoolType,
		"use_custom_script":                  types.BoolType,
		"use_intermediate_loading_screen":    types.BoolType,
		"validate_on_save":                   types.BoolType,
	}
	resp.Schema = schema.Schema{
		Description: "Resource to create and manage a davinci flow.",
		Attributes: map[string]schema.Attribute{
			"color": schema.StringAttribute{
				Optional: true,
			},
			"connectors": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Computed: true,
			},
			"current_version": schema.Float32Attribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1024),
					stringvalidator.LengthAtLeast(1),
				},
			},
			"enabled": schema.BoolAttribute{
				Computed: true,
			},
			"environment_id": schema.StringAttribute{
				Required:    true,
				Description: "The ID of the environment to create and manage the flow in. Must be a valid PingOne resource ID. This field is immutable and will trigger a replace plan if changed.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"), "Must be a valid UUID"),
				},
			},
			"graph_data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"box_selection_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"data": schema.StringAttribute{
						CustomType: jsontypes.NormalizedType{},
						Optional:   true,
					},
					"elements": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"edges": schema.MapNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"classes": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Default:  stringdefault.StaticString(""),
										},
										"data": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"source": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"target": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
											},
											Required: true,
										},
										"grabbable": schema.BoolAttribute{
											Optional: true,
										},
										"group": schema.StringAttribute{
											Optional: true,
										},
										"locked": schema.BoolAttribute{
											Optional: true,
										},
										"pannable": schema.BoolAttribute{
											Optional: true,
										},
										"position": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"x": schema.NumberAttribute{
													Required: true,
												},
												"y": schema.NumberAttribute{
													Required: true,
												},
											},
											Optional: true,
										},
										"removed": schema.BoolAttribute{
											Optional: true,
										},
										"selectable": schema.BoolAttribute{
											Optional: true,
										},
										"selected": schema.BoolAttribute{
											Optional: true,
										},
									},
								},
								Optional: true,
								Computed: true,
								Default:  mapdefault.StaticValue(types.MapValueMust(graphDataElementsEdgesElementType, nil)),
							},
							"nodes": schema.MapNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"classes": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Default:  stringdefault.StaticString(""),
										},
										"data": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"capability_name": schema.StringAttribute{
													Optional: true,
												},
												"connection_id": schema.StringAttribute{
													Optional: true,
													Computed: true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"connector_id": schema.StringAttribute{
													Optional: true,
												},
												"id": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"id_unique": schema.StringAttribute{
													Optional: true,
													Computed: true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"label": schema.StringAttribute{
													Optional: true,
												},
												"name": schema.StringAttribute{
													Optional: true,
													Computed: true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"node_type": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"properties": schema.StringAttribute{
													CustomType: jsontypes.NormalizedType{},
													Optional:   true,
													Sensitive:  true,
												},
												"status": schema.StringAttribute{
													Optional: true,
												},
												"type": schema.StringAttribute{
													Optional: true,
												},
											},
											Required: true,
										},
										"grabbable": schema.BoolAttribute{
											Optional: true,
										},
										"group": schema.StringAttribute{
											Optional: true,
										},
										"locked": schema.BoolAttribute{
											Optional: true,
										},
										"pannable": schema.BoolAttribute{
											Optional: true,
										},
										"position": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"x": schema.NumberAttribute{
													Required: true,
												},
												"y": schema.NumberAttribute{
													Required: true,
												},
											},
											Optional: true,
										},
										"removed": schema.BoolAttribute{
											Optional: true,
										},
										"selectable": schema.BoolAttribute{
											Optional: true,
										},
										"selected": schema.BoolAttribute{
											Optional: true,
										},
									},
								},
								Optional: true,
							},
						},
						Optional: true,
					},
					"max_zoom": schema.NumberAttribute{
						Optional: true,
					},
					"min_zoom": schema.NumberAttribute{
						Optional: true,
					},
					"pan": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"x": schema.NumberAttribute{
								Required: true,
							},
							"y": schema.NumberAttribute{
								Required: true,
							},
						},
						Optional: true,
					},
					"panning_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"renderer": schema.StringAttribute{
						CustomType: jsontypes.NormalizedType{},
						Optional:   true,
					},
					"user_panning_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"user_zooming_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"zoom": schema.Int32Attribute{
						Optional: true,
					},
					"zooming_enabled": schema.BoolAttribute{
						Optional: true,
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: "The ID of this resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"input_schema": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"is_expanded": schema.BoolAttribute{
							Optional: true,
							Computed: true,
						},
						"preferred_control_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Options are \"button\", \"colorPicker\", \"contentEditableTextArea\", \"cssArea\", \"dropDown\", \"dropDownMultiSelect\", \"dropDownMultiSelect2\", \"dropDownWithCreate\", \"functionArgumentList\", \"keyValueList\", \"label\", \"radioSelect\", \"textArea\", \"textField\", \"textFieldArrayView\", \"toggleSwitch\".",
							MarkdownDescription: "Options are `button`, `colorPicker`, `contentEditableTextArea`, `cssArea`, `dropDown`, `dropDownMultiSelect`, `dropDownMultiSelect2`, `dropDownWithCreate`, `functionArgumentList`, `keyValueList`, `label`, `radioSelect`, `textArea`, `textField`, `textFieldArrayView`, `toggleSwitch`.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"button",
									"colorPicker",
									"contentEditableTextArea",
									"cssArea",
									"dropDown",
									"dropDownMultiSelect",
									"dropDownMultiSelect2",
									"dropDownWithCreate",
									"functionArgumentList",
									"keyValueList",
									"label",
									"radioSelect",
									"textArea",
									"textField",
									"textFieldArrayView",
									"toggleSwitch",
								),
							},
						},
						"preferred_data_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Options are \"array\", \"boolean\", \"number\", \"object\", \"string\".",
							MarkdownDescription: "Options are `array`, `boolean`, `number`, `object`, `string`.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"array",
									"boolean",
									"number",
									"object",
									"string",
								),
								stringvalidator.LengthAtLeast(1),
								// This attribute is required by the API, but can't be marked as such or it will cause unnecessary plans
								// See https://github.com/hashicorp/terraform-plugin-framework/issues/898
								internalstringvalidator.NotNull(),
							},
						},
						"property_name": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.LengthAtLeast(1),
								// This attribute is required by the API, but can't be marked as such or it will cause unnecessary plans
								// See https://github.com/hashicorp/terraform-plugin-framework/issues/898
								internalstringvalidator.NotNull(),
							},
						},
						"required": schema.BoolAttribute{
							Optional: true,
							Computed: true,
						},
					},
				},
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 256),
				},
			},
			"output_schema": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"output": schema.SingleNestedAttribute{
						Required: true,
						Attributes: map[string]schema.Attribute{
							"type": schema.StringAttribute{
								Required: true,
							},
							"properties": schema.StringAttribute{
								CustomType: jsontypes.NormalizedType{},
								Optional:   true,
							},
							"additional_properties": schema.BoolAttribute{
								Optional: true,
							},
						},
					},
				},
				Optional: true,
			},
			"published_version": schema.Float32Attribute{
				Computed: true,
			},
			"settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"csp": schema.StringAttribute{
						Optional: true,
					},
					"css": schema.StringAttribute{
						Optional: true,
					},
					"css_links": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"custom_error_screen_brand_logo_url": schema.StringAttribute{
						Optional: true,
					},
					"custom_error_show_footer": schema.BoolAttribute{
						Optional: true,
					},
					"custom_favicon_link": schema.StringAttribute{
						Optional: true,
					},
					"custom_logo_urlselection": schema.Int32Attribute{
						Optional: true,
					},
					"custom_title": schema.StringAttribute{
						Optional: true,
					},
					"default_error_screen_brand_logo": schema.BoolAttribute{
						Optional: true,
					},
					"flow_http_timeout_in_seconds": schema.Int32Attribute{
						Optional: true,
					},
					"flow_timeout_in_seconds": schema.Int32Attribute{
						Optional: true,
					},
					"intermediate_loading_screen_css": schema.StringAttribute{
						Optional: true,
					},
					"intermediate_loading_screen_html": schema.StringAttribute{
						Optional: true,
					},
					"js_custom_flow_player": schema.StringAttribute{
						Optional: true,
					},
					"js_links": schema.SetNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"crossorigin": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"defer": schema.BoolAttribute{
									Required: true,
								},
								"integrity": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"label": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"referrerpolicy": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"type": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"value": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
							},
						},
						Optional: true,
					},
					"log_level": schema.Int32Attribute{
						Optional: true,
						Computed: true,
						Default:  int32default.StaticInt32(4),
						Validators: []validator.Int32{
							int32validator.Between(1, 4),
						},
					},
					"require_authentication_to_initiate": schema.BoolAttribute{
						Optional: true,
					},
					"scrub_sensitive_info": schema.BoolAttribute{
						Optional: true,
					},
					"sensitive_info_fields": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"use_csp": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_css": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_flow_player": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_script": schema.BoolAttribute{
						Optional: true,
					},
					"use_intermediate_loading_screen": schema.BoolAttribute{
						Optional: true,
					},
					"validate_on_save": schema.BoolAttribute{
						Optional: true,
					},
				},
				Optional: true,
				Computed: true,
				Default: objectdefault.StaticValue(types.ObjectValueMust(settingsAttrTypes, map[string]attr.Value{
					"csp":                                types.StringNull(),
					"css":                                types.StringNull(),
					"css_links":                          types.SetNull(types.StringType),
					"custom_error_screen_brand_logo_url": types.StringNull(),
					"custom_error_show_footer":           types.BoolNull(),
					"custom_favicon_link":                types.StringNull(),
					"custom_logo_urlselection":           types.Int32Null(),
					"custom_title":                       types.StringNull(),
					"default_error_screen_brand_logo":    types.BoolNull(),
					"flow_http_timeout_in_seconds":       types.Int32Null(),
					"flow_timeout_in_seconds":            types.Int32Null(),
					"intermediate_loading_screen_css":    types.StringNull(),
					"intermediate_loading_screen_html":   types.StringNull(),
					"js_custom_flow_player":              types.StringNull(),
					"js_links":                           types.SetNull(settingsJsLinksElementType),
					"log_level":                          types.Int32Value(4),
					"require_authentication_to_initiate": types.BoolNull(),
					"scrub_sensitive_info":               types.BoolNull(),
					"sensitive_info_fields":              types.SetNull(types.StringType),
					"use_csp":                            types.BoolNull(),
					"use_custom_css":                     types.BoolNull(),
					"use_custom_flow_player":             types.BoolNull(),
					"use_custom_script":                  types.BoolNull(),
					"use_intermediate_loading_screen":    types.BoolNull(),
					"validate_on_save":                   types.BoolNull(),
				})),
			},
			"trigger": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"configuration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"mfa": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Required: true,
									},
									"time": schema.Float32Attribute{
										Required: true,
									},
									"time_format": schema.StringAttribute{
										Required: true,
										Validators: []validator.String{
											stringvalidator.LengthBetween(0, 50),
										},
									},
								},
								Required: true,
							},
							"pwd": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Required: true,
									},
									"time": schema.Float32Attribute{
										Required: true,
									},
									"time_format": schema.StringAttribute{
										Required: true,
										Validators: []validator.String{
											stringvalidator.LengthBetween(0, 50),
										},
									},
								},
								Required: true,
							},
						},
						Optional: true,
					},
					"type": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AUTHENTICATION",
								"SCHEDULE",
							),
							stringvalidator.LengthAtLeast(1),
						},
					},
				},
				Optional: true,
			},
		},
	}
}

func (model *davinciFlowResourceModel) buildClientStructPost() (*pingone.DaVinciFlowCreateRequest, diag.Diagnostics) {
	result := &pingone.DaVinciFlowCreateRequest{}
	var respDiags diag.Diagnostics
	// color
	if !model.Color.IsNull() && !model.Color.IsUnknown() {
		result.Color = model.Color.ValueStringPointer()
	}
	// description
	if !model.Description.IsNull() && !model.Description.IsUnknown() {
		result.Description = model.Description.ValueStringPointer()
	}
	// graph_data
	if !model.GraphData.IsNull() && !model.GraphData.IsUnknown() {
		graphDataValue := &pingone.DaVinciFlowGraphDataRequest{}
		graphDataAttrs := model.GraphData.Attributes()
		graphDataValue.BoxSelectionEnabled = graphDataAttrs["box_selection_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["data"].IsNull() && !graphDataAttrs["data"].IsUnknown() {
			var unmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["data"].(jsontypes.Normalized).ValueString()), &unmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for data could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Data = unmarshaled
		}
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsValue := &pingone.DaVinciFlowGraphDataRequestElements{}
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			if !graphDataElementsAttrs["edges"].IsNull() && !graphDataElementsAttrs["edges"].IsUnknown() {
				graphDataElementsValue.Edges = []pingone.DaVinciFlowGraphDataRequestElementsEdge{}
				for _, edgesElement := range graphDataElementsAttrs["edges"].(types.Map).Elements() {
					edgesValue := pingone.DaVinciFlowGraphDataRequestElementsEdge{}
					edgesAttrs := edgesElement.(types.Object).Attributes()
					edgesValue.Classes = edgesAttrs["classes"].(types.String).ValueStringPointer()
					edgesDataValue := pingone.DaVinciFlowGraphDataRequestElementsEdgeData{}
					edgesDataAttrs := edgesAttrs["data"].(types.Object).Attributes()
					edgesDataValue.Id = edgesDataAttrs["id"].(types.String).ValueString()
					edgesDataValue.Source = edgesDataAttrs["source"].(types.String).ValueString()
					edgesDataValue.Target = edgesDataAttrs["target"].(types.String).ValueString()
					edgesValue.Data = edgesDataValue
					edgesValue.Grabbable = edgesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					edgesValue.Group = edgesAttrs["group"].(types.String).ValueStringPointer()
					edgesValue.Locked = edgesAttrs["locked"].(types.Bool).ValueBoolPointer()
					edgesValue.Pannable = edgesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !edgesAttrs["position"].IsNull() && !edgesAttrs["position"].IsUnknown() {
						edgesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsEdgePosition{}
						edgesPositionAttrs := edgesAttrs["position"].(types.Object).Attributes()
						if !edgesPositionAttrs["x"].IsNull() && !edgesPositionAttrs["x"].IsUnknown() {
							edgesPositionValue.X = pingonetypes.BigFloatUnquoted{
								Float: edgesPositionAttrs["x"].(types.Number).ValueBigFloat(),
							}
						}
						if !edgesPositionAttrs["y"].IsNull() && !edgesPositionAttrs["y"].IsUnknown() {
							edgesPositionValue.Y = pingonetypes.BigFloatUnquoted{
								Float: edgesPositionAttrs["y"].(types.Number).ValueBigFloat(),
							}
						}
						edgesValue.Position = edgesPositionValue
					}
					edgesValue.Removed = edgesAttrs["removed"].(types.Bool).ValueBoolPointer()
					edgesValue.Selectable = edgesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					edgesValue.Selected = edgesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Edges = append(graphDataElementsValue.Edges, edgesValue)
				}
			}
			if !graphDataElementsAttrs["nodes"].IsNull() && !graphDataElementsAttrs["nodes"].IsUnknown() {
				graphDataElementsValue.Nodes = []pingone.DaVinciFlowGraphDataRequestElementsNode{}
				for _, nodesElement := range graphDataElementsAttrs["nodes"].(types.Map).Elements() {
					nodesValue := pingone.DaVinciFlowGraphDataRequestElementsNode{}
					nodesAttrs := nodesElement.(types.Object).Attributes()
					nodesValue.Classes = nodesAttrs["classes"].(types.String).ValueStringPointer()
					nodesDataValue := pingone.DaVinciFlowGraphDataRequestElementsNodeData{}
					nodesDataAttrs := nodesAttrs["data"].(types.Object).Attributes()
					nodesDataValue.CapabilityName = nodesDataAttrs["capability_name"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectionId = nodesDataAttrs["connection_id"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectorId = nodesDataAttrs["connector_id"].(types.String).ValueStringPointer()
					nodesDataValue.Id = nodesDataAttrs["id"].(types.String).ValueString()
					nodesDataValue.IdUnique = nodesDataAttrs["id_unique"].(types.String).ValueStringPointer()
					nodesDataValue.Label = nodesDataAttrs["label"].(types.String).ValueStringPointer()
					nodesDataValue.Name = nodesDataAttrs["name"].(types.String).ValueStringPointer()
					nodesDataValue.NodeType = nodesDataAttrs["node_type"].(types.String).ValueString()
					if !nodesDataAttrs["properties"].IsNull() && !nodesDataAttrs["properties"].IsUnknown() {
						var unmarshaled map[string]interface{}
						err := json.Unmarshal([]byte(nodesDataAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
						if err != nil {
							respDiags.AddError(
								"Error Parsing JSON val",
								fmt.Sprintf("The value provided for properties could not be parsed as json: %s", err.Error()),
							)
						}
						nodesDataValue.Properties = unmarshaled
					}
					nodesDataValue.Status = nodesDataAttrs["status"].(types.String).ValueStringPointer()
					nodesDataValue.Type = nodesDataAttrs["type"].(types.String).ValueStringPointer()
					nodesValue.Data = nodesDataValue
					nodesValue.Grabbable = nodesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					nodesValue.Group = nodesAttrs["group"].(types.String).ValueStringPointer()
					nodesValue.Locked = nodesAttrs["locked"].(types.Bool).ValueBoolPointer()
					nodesValue.Pannable = nodesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !nodesAttrs["position"].IsNull() && !nodesAttrs["position"].IsUnknown() {
						nodesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsNodePosition{}
						nodesPositionAttrs := nodesAttrs["position"].(types.Object).Attributes()
						if !nodesPositionAttrs["x"].IsNull() && !nodesPositionAttrs["x"].IsUnknown() {
							nodesPositionValue.X = pingonetypes.BigFloatUnquoted{
								Float: nodesPositionAttrs["x"].(types.Number).ValueBigFloat(),
							}
						}
						if !nodesPositionAttrs["y"].IsNull() && !nodesPositionAttrs["y"].IsUnknown() {
							nodesPositionValue.Y = pingonetypes.BigFloatUnquoted{
								Float: nodesPositionAttrs["y"].(types.Number).ValueBigFloat(),
							}
						}
						nodesValue.Position = nodesPositionValue
					}
					nodesValue.Removed = nodesAttrs["removed"].(types.Bool).ValueBoolPointer()
					nodesValue.Selectable = nodesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					nodesValue.Selected = nodesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Nodes = append(graphDataElementsValue.Nodes, nodesValue)
				}
			}
			graphDataValue.Elements = graphDataElementsValue
		}
		if !graphDataAttrs["max_zoom"].IsNull() && !graphDataAttrs["max_zoom"].IsUnknown() {
			graphDataValue.MaxZoom = &pingonetypes.BigFloatUnquoted{
				Float: graphDataAttrs["max_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["min_zoom"].IsNull() && !graphDataAttrs["min_zoom"].IsUnknown() {
			graphDataValue.MinZoom = &pingonetypes.BigFloatUnquoted{
				Float: graphDataAttrs["min_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["pan"].IsNull() && !graphDataAttrs["pan"].IsUnknown() {
			graphDataPanValue := &pingone.DaVinciFlowGraphDataRequestPan{}
			graphDataPanAttrs := graphDataAttrs["pan"].(types.Object).Attributes()
			if !graphDataPanAttrs["x"].IsNull() && !graphDataPanAttrs["x"].IsUnknown() {
				graphDataPanValue.X = pingonetypes.BigFloatUnquoted{
					Float: graphDataPanAttrs["x"].(types.Number).ValueBigFloat(),
				}
			}
			if !graphDataPanAttrs["y"].IsNull() && !graphDataPanAttrs["y"].IsUnknown() {
				graphDataPanValue.Y = pingonetypes.BigFloatUnquoted{
					Float: graphDataPanAttrs["y"].(types.Number).ValueBigFloat(),
				}
			}
			graphDataValue.Pan = graphDataPanValue
		}
		graphDataValue.PanningEnabled = graphDataAttrs["panning_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["renderer"].IsNull() && !graphDataAttrs["renderer"].IsUnknown() {
			var newUnmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["renderer"].(jsontypes.Normalized).ValueString()), &newUnmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for renderer could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Renderer = newUnmarshaled
		}
		graphDataValue.UserPanningEnabled = graphDataAttrs["user_panning_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.UserZoomingEnabled = graphDataAttrs["user_zooming_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.Zoom = graphDataAttrs["zoom"].(types.Int32).ValueInt32Pointer()
		graphDataValue.ZoomingEnabled = graphDataAttrs["zooming_enabled"].(types.Bool).ValueBoolPointer()
		result.GraphData = graphDataValue
	}

	// input_schema
	if !model.InputSchema.IsNull() && !model.InputSchema.IsUnknown() {
		result.InputSchema = []pingone.DaVinciFlowInputSchemaRequestItem{}
		for _, inputSchemaElement := range model.InputSchema.Elements() {
			inputSchemaValue := pingone.DaVinciFlowInputSchemaRequestItem{}
			inputSchemaAttrs := inputSchemaElement.(types.Object).Attributes()
			inputSchemaValue.Description = inputSchemaAttrs["description"].(types.String).ValueStringPointer()
			inputSchemaValue.IsExpanded = inputSchemaAttrs["is_expanded"].(types.Bool).ValueBoolPointer()
			if !inputSchemaAttrs["preferred_control_type"].IsNull() && !inputSchemaAttrs["preferred_control_type"].IsUnknown() {
				inputSchemaPreferredControlTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredControlTypeFromValue(inputSchemaAttrs["preferred_control_type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("preferred_control_type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for preferred_control_type is not valid: %s", err.Error()),
					)
				} else {
					inputSchemaValue.PreferredControlType = inputSchemaPreferredControlTypeValue
				}
			}
			inputSchemaPreferredDataTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredDataTypeFromValue(inputSchemaAttrs["preferred_data_type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("preferred_data_type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for preferred_data_type is not valid: %s", err.Error()),
				)
			} else {
				inputSchemaValue.PreferredDataType = *inputSchemaPreferredDataTypeValue
			}
			inputSchemaValue.PropertyName = inputSchemaAttrs["property_name"].(types.String).ValueString()
			inputSchemaValue.Required = inputSchemaAttrs["required"].(types.Bool).ValueBoolPointer()
			result.InputSchema = append(result.InputSchema, inputSchemaValue)
		}
	}

	// name
	result.Name = model.Name.ValueString()
	// output_schema
	if !model.OutputSchema.IsNull() && !model.OutputSchema.IsUnknown() {
		outputSchemaValue := &pingone.DaVinciFlowOutputSchemaRequest{}
		outputSchemaAttrs := model.OutputSchema.Attributes()
		if !outputSchemaAttrs["output"].IsNull() && !outputSchemaAttrs["output"].IsUnknown() {
			outputSchemaOutputValue := pingone.DaVinciFlowOutputSchemaRequestOutput{}
			outputSchemaOutputAttrs := outputSchemaAttrs["output"].(types.Object).Attributes()
			outputSchemaOutputValue.AdditionalPropertiesField = outputSchemaOutputAttrs["additional_properties"].(types.Bool).ValueBoolPointer()
			if !outputSchemaOutputAttrs["properties"].IsNull() && !outputSchemaOutputAttrs["properties"].IsUnknown() {
				var unmarshaled map[string]interface{}
				err := json.Unmarshal([]byte(outputSchemaOutputAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
				if err != nil {
					respDiags.AddError(
						"Error Parsing JSON val",
						fmt.Sprintf("The value provided for output.output_schema.properties could not be parsed as json: %s", err.Error()),
					)
				}
				outputSchemaOutputValue.Properties = unmarshaled
			}
			outputSchemaOutputTypeValue, err := pingone.NewDaVinciFlowOutputSchemaRequestOutputTypeFromValue(outputSchemaOutputAttrs["type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("output_schema.output.type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for output_schema.output.type is not valid: %s", err.Error()),
				)
			} else {
				outputSchemaOutputValue.Type = *outputSchemaOutputTypeValue
			}
			outputSchemaValue.Output = outputSchemaOutputValue
		}
		result.OutputSchema = outputSchemaValue
	}

	// settings
	if !model.Settings.IsNull() && !model.Settings.IsUnknown() {
		settingsValue := &pingone.DaVinciFlowSettingsRequest{}
		settingsAttrs := model.Settings.Attributes()
		settingsValue.Csp = settingsAttrs["csp"].(types.String).ValueStringPointer()
		settingsValue.Css = settingsAttrs["css"].(types.String).ValueStringPointer()
		if !settingsAttrs["css_links"].IsNull() && !settingsAttrs["css_links"].IsUnknown() {
			settingsValue.CssLinks = []string{}
			for _, cssLinksElement := range settingsAttrs["css_links"].(types.Set).Elements() {
				settingsValue.CssLinks = append(settingsValue.CssLinks, cssLinksElement.(types.String).ValueString())
			}
		}
		settingsValue.CustomErrorScreenBrandLogoUrl = settingsAttrs["custom_error_screen_brand_logo_url"].(types.String).ValueStringPointer()
		if !settingsAttrs["custom_error_show_footer"].IsNull() && !settingsAttrs["custom_error_show_footer"].IsUnknown() {
			settingsValue.CustomErrorShowFooter = &pingone.DaVinciFlowSettingsRequestCustomErrorShowFooter{
				Bool: settingsAttrs["custom_error_show_footer"].(types.Bool).ValueBoolPointer(),
			}
		}
		settingsValue.CustomFaviconLink = settingsAttrs["custom_favicon_link"].(types.String).ValueStringPointer()
		settingsValue.CustomLogoURLSelection = settingsAttrs["custom_logo_urlselection"].(types.Int32).ValueInt32Pointer()
		settingsValue.CustomTitle = settingsAttrs["custom_title"].(types.String).ValueStringPointer()
		if !settingsAttrs["default_error_screen_brand_logo"].IsNull() && !settingsAttrs["default_error_screen_brand_logo"].IsUnknown() {
			settingsValue.DefaultErrorScreenBrandLogo = &pingone.DaVinciFlowSettingsRequestDefaultErrorScreenBrandLogo{
				Bool: settingsAttrs["default_error_screen_brand_logo"].(types.Bool).ValueBoolPointer(),
			}
		}
		settingsValue.FlowHttpTimeoutInSeconds = settingsAttrs["flow_http_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.FlowTimeoutInSeconds = settingsAttrs["flow_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		if !settingsAttrs["intermediate_loading_screen_css"].IsNull() && !settingsAttrs["intermediate_loading_screen_css"].IsUnknown() {
			settingsIntermediateLoadingScreenCSSValue := &pingone.DaVinciFlowSettingsRequestIntermediateLoadingScreenCSS{}
			settingsIntermediateLoadingScreenCSSValue.String = settingsAttrs["intermediate_loading_screen_css"].(types.String).ValueStringPointer()
			settingsValue.IntermediateLoadingScreenCSS = settingsIntermediateLoadingScreenCSSValue
		}
		if !settingsAttrs["intermediate_loading_screen_html"].IsNull() && !settingsAttrs["intermediate_loading_screen_html"].IsUnknown() {
			settingsIntermediateLoadingScreenHTMLValue := &pingone.DaVinciFlowSettingsRequestIntermediateLoadingScreenHTML{}
			settingsIntermediateLoadingScreenHTMLValue.String = settingsAttrs["intermediate_loading_screen_html"].(types.String).ValueStringPointer()
			settingsValue.IntermediateLoadingScreenHTML = settingsIntermediateLoadingScreenHTMLValue
		}
		settingsValue.JsCustomFlowPlayer = settingsAttrs["js_custom_flow_player"].(types.String).ValueStringPointer()
		if !settingsAttrs["js_links"].IsNull() && !settingsAttrs["js_links"].IsUnknown() {
			settingsValue.JsLinks = []pingone.DaVinciFlowSettingsRequestJsLink{}
			for _, jsLinksElement := range settingsAttrs["js_links"].(types.Set).Elements() {
				jsLinksValue := pingone.DaVinciFlowSettingsRequestJsLink{}
				jsLinksAttrs := jsLinksElement.(types.Object).Attributes()
				jsLinksValue.Crossorigin = jsLinksAttrs["crossorigin"].(types.String).ValueString()
				if !jsLinksAttrs["defer"].IsNull() && !jsLinksAttrs["defer"].IsUnknown() {
					jsLinksValue.Defer = pingone.DaVinciFlowSettingsRequestJsLinkDefer{
						Bool: jsLinksAttrs["defer"].(types.Bool).ValueBoolPointer(),
					}
				}
				jsLinksValue.Integrity = jsLinksAttrs["integrity"].(types.String).ValueString()
				jsLinksValue.Label = jsLinksAttrs["label"].(types.String).ValueString()
				jsLinksValue.Referrerpolicy = jsLinksAttrs["referrerpolicy"].(types.String).ValueString()
				jsLinksValue.Type = jsLinksAttrs["type"].(types.String).ValueString()
				jsLinksValue.Value = jsLinksAttrs["value"].(types.String).ValueString()
				settingsValue.JsLinks = append(settingsValue.JsLinks, jsLinksValue)
			}
		}
		settingsValue.LogLevel = settingsAttrs["log_level"].(types.Int32).ValueInt32Pointer()
		if !settingsAttrs["require_authentication_to_initiate"].IsNull() && !settingsAttrs["require_authentication_to_initiate"].IsUnknown() {
			settingsValue.RequireAuthenticationToInitiate = &pingone.DaVinciFlowSettingsRequestRequireAuthenticationToInitiate{
				Bool: settingsAttrs["require_authentication_to_initiate"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["scrub_sensitive_info"].IsNull() && !settingsAttrs["scrub_sensitive_info"].IsUnknown() {
			settingsValue.ScrubSensitiveInfo = &pingone.DaVinciFlowSettingsRequestScrubSensitiveInfo{
				Bool: settingsAttrs["scrub_sensitive_info"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["sensitive_info_fields"].IsNull() && !settingsAttrs["sensitive_info_fields"].IsUnknown() {
			settingsValue.SensitiveInfoFields = []string{}
			for _, sensitiveInfoFieldsElement := range settingsAttrs["sensitive_info_fields"].(types.Set).Elements() {
				settingsValue.SensitiveInfoFields = append(settingsValue.SensitiveInfoFields, sensitiveInfoFieldsElement.(types.String).ValueString())
			}
		}
		if !settingsAttrs["use_csp"].IsNull() && !settingsAttrs["use_csp"].IsUnknown() {
			settingsValue.UseCSP = &pingone.DaVinciFlowSettingsRequestUseCSP{
				Bool: settingsAttrs["use_csp"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_css"].IsNull() && !settingsAttrs["use_custom_css"].IsUnknown() {
			settingsValue.UseCustomCSS = &pingone.DaVinciFlowSettingsRequestUseCustomCSS{
				Bool: settingsAttrs["use_custom_css"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_flow_player"].IsNull() && !settingsAttrs["use_custom_flow_player"].IsUnknown() {
			settingsValue.UseCustomFlowPlayer = &pingone.DaVinciFlowSettingsRequestUseCustomFlowPlayer{
				Bool: settingsAttrs["use_custom_flow_player"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_script"].IsNull() && !settingsAttrs["use_custom_script"].IsUnknown() {
			settingsValue.UseCustomScript = &pingone.DaVinciFlowSettingsRequestUseCustomScript{
				Bool: settingsAttrs["use_custom_script"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_intermediate_loading_screen"].IsNull() && !settingsAttrs["use_intermediate_loading_screen"].IsUnknown() {
			settingsValue.UseIntermediateLoadingScreen = &pingone.DaVinciFlowSettingsRequestUseIntermediateLoadingScreen{
				Bool: settingsAttrs["use_intermediate_loading_screen"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["validate_on_save"].IsNull() && !settingsAttrs["validate_on_save"].IsUnknown() {
			settingsValue.ValidateOnSave = &pingone.DaVinciFlowSettingsRequestValidateOnSave{
				Bool: settingsAttrs["validate_on_save"].(types.Bool).ValueBoolPointer(),
			}
		}
		result.Settings = settingsValue
	}

	// trigger
	if !model.Trigger.IsNull() && !model.Trigger.IsUnknown() {
		triggerValue := &pingone.DaVinciFlowTriggerRequest{}
		triggerAttrs := model.Trigger.Attributes()
		if !triggerAttrs["configuration"].IsNull() && !triggerAttrs["configuration"].IsUnknown() {
			triggerConfigurationValue := &pingone.DaVinciFlowTriggerRequestConfiguration{}
			triggerConfigurationAttrs := triggerAttrs["configuration"].(types.Object).Attributes()
			if !triggerConfigurationAttrs["mfa"].IsNull() && !triggerConfigurationAttrs["mfa"].IsUnknown() {
				triggerConfigurationMfaValue := pingone.DaVinciFlowTriggerRequestConfigurationMFA{}
				triggerConfigurationMfaAttrs := triggerConfigurationAttrs["mfa"].(types.Object).Attributes()
				triggerConfigurationMfaValue.Enabled = triggerConfigurationMfaAttrs["enabled"].(types.Bool).ValueBool()
				triggerConfigurationMfaValue.Time = triggerConfigurationMfaAttrs["time"].(types.Float32).ValueFloat32()
				triggerConfigurationMfaValue.TimeFormat = triggerConfigurationMfaAttrs["time_format"].(types.String).ValueString()
				triggerConfigurationValue.Mfa = triggerConfigurationMfaValue
			}
			if !triggerConfigurationAttrs["pwd"].IsNull() && !triggerConfigurationAttrs["pwd"].IsUnknown() {
				triggerConfigurationPwdValue := pingone.DaVinciFlowTriggerRequestConfigurationPassword{}
				triggerConfigurationPwdAttrs := triggerConfigurationAttrs["pwd"].(types.Object).Attributes()
				triggerConfigurationPwdValue.Enabled = triggerConfigurationPwdAttrs["enabled"].(types.Bool).ValueBool()
				triggerConfigurationPwdValue.Time = triggerConfigurationPwdAttrs["time"].(types.Float32).ValueFloat32()
				triggerConfigurationPwdValue.TimeFormat = triggerConfigurationPwdAttrs["time_format"].(types.String).ValueString()
				triggerConfigurationValue.Pwd = triggerConfigurationPwdValue
			}
			triggerValue.Configuration = triggerConfigurationValue
		}
		triggerTypeValue, err := pingone.NewDaVinciFlowTriggerRequestTypeFromValue(triggerAttrs["type"].(types.String).ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			triggerValue.Type = *triggerTypeValue
		}
		result.Trigger = triggerValue
	}

	return result, respDiags
}

func (model *davinciFlowResourceModel) buildClientStructPut() (*pingone.DaVinciFlowReplaceRequest, diag.Diagnostics) {
	result := &pingone.DaVinciFlowReplaceRequest{}
	var respDiags diag.Diagnostics
	// color
	if !model.Color.IsNull() && !model.Color.IsUnknown() {
		result.Color = model.Color.ValueStringPointer()
	}
	// description
	if !model.Description.IsNull() && !model.Description.IsUnknown() {
		result.Description = model.Description.ValueStringPointer()
	}
	// graph_data
	if !model.GraphData.IsNull() && !model.GraphData.IsUnknown() {
		graphDataValue := &pingone.DaVinciFlowGraphDataRequest{}
		graphDataAttrs := model.GraphData.Attributes()
		graphDataValue.BoxSelectionEnabled = graphDataAttrs["box_selection_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["data"].IsNull() && !graphDataAttrs["data"].IsUnknown() {
			var unmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["data"].(jsontypes.Normalized).ValueString()), &unmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for data could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Data = unmarshaled
		}
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsValue := &pingone.DaVinciFlowGraphDataRequestElements{}
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			if !graphDataElementsAttrs["edges"].IsNull() && !graphDataElementsAttrs["edges"].IsUnknown() {
				graphDataElementsValue.Edges = []pingone.DaVinciFlowGraphDataRequestElementsEdge{}
				for _, edgesElement := range graphDataElementsAttrs["edges"].(types.Map).Elements() {
					edgesValue := pingone.DaVinciFlowGraphDataRequestElementsEdge{}
					edgesAttrs := edgesElement.(types.Object).Attributes()
					edgesValue.Classes = edgesAttrs["classes"].(types.String).ValueStringPointer()
					edgesDataValue := pingone.DaVinciFlowGraphDataRequestElementsEdgeData{}
					edgesDataAttrs := edgesAttrs["data"].(types.Object).Attributes()
					edgesDataValue.Id = edgesDataAttrs["id"].(types.String).ValueString()
					edgesDataValue.Source = edgesDataAttrs["source"].(types.String).ValueString()
					edgesDataValue.Target = edgesDataAttrs["target"].(types.String).ValueString()
					edgesValue.Data = edgesDataValue
					edgesValue.Grabbable = edgesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					edgesValue.Group = edgesAttrs["group"].(types.String).ValueStringPointer()
					edgesValue.Locked = edgesAttrs["locked"].(types.Bool).ValueBoolPointer()
					edgesValue.Pannable = edgesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !edgesAttrs["position"].IsNull() && !edgesAttrs["position"].IsUnknown() {
						edgesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsEdgePosition{}
						edgesPositionAttrs := edgesAttrs["position"].(types.Object).Attributes()
						if !edgesPositionAttrs["x"].IsNull() && !edgesPositionAttrs["x"].IsUnknown() {
							edgesPositionValue.X = pingonetypes.BigFloatUnquoted{
								Float: edgesPositionAttrs["x"].(types.Number).ValueBigFloat(),
							}
						}
						if !edgesPositionAttrs["y"].IsNull() && !edgesPositionAttrs["y"].IsUnknown() {
							edgesPositionValue.Y = pingonetypes.BigFloatUnquoted{
								Float: edgesPositionAttrs["y"].(types.Number).ValueBigFloat(),
							}
						}
						edgesValue.Position = edgesPositionValue
					}
					edgesValue.Removed = edgesAttrs["removed"].(types.Bool).ValueBoolPointer()
					edgesValue.Selectable = edgesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					edgesValue.Selected = edgesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Edges = append(graphDataElementsValue.Edges, edgesValue)
				}
			}
			if !graphDataElementsAttrs["nodes"].IsNull() && !graphDataElementsAttrs["nodes"].IsUnknown() {
				graphDataElementsValue.Nodes = []pingone.DaVinciFlowGraphDataRequestElementsNode{}
				for _, nodesElement := range graphDataElementsAttrs["nodes"].(types.Map).Elements() {
					nodesValue := pingone.DaVinciFlowGraphDataRequestElementsNode{}
					nodesAttrs := nodesElement.(types.Object).Attributes()
					nodesValue.Classes = nodesAttrs["classes"].(types.String).ValueStringPointer()
					nodesDataValue := pingone.DaVinciFlowGraphDataRequestElementsNodeData{}
					nodesDataAttrs := nodesAttrs["data"].(types.Object).Attributes()
					nodesDataValue.CapabilityName = nodesDataAttrs["capability_name"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectionId = nodesDataAttrs["connection_id"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectorId = nodesDataAttrs["connector_id"].(types.String).ValueStringPointer()
					nodesDataValue.Id = nodesDataAttrs["id"].(types.String).ValueString()
					nodesDataValue.IdUnique = nodesDataAttrs["id_unique"].(types.String).ValueStringPointer()
					nodesDataValue.Label = nodesDataAttrs["label"].(types.String).ValueStringPointer()
					nodesDataValue.Name = nodesDataAttrs["name"].(types.String).ValueStringPointer()
					nodesDataValue.NodeType = nodesDataAttrs["node_type"].(types.String).ValueString()
					if !nodesDataAttrs["properties"].IsNull() && !nodesDataAttrs["properties"].IsUnknown() {
						var unmarshaled map[string]interface{}
						err := json.Unmarshal([]byte(nodesDataAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
						if err != nil {
							respDiags.AddError(
								"Error Parsing JSON val",
								fmt.Sprintf("The value provided for properties could not be parsed as json: %s", err.Error()),
							)
						}
						nodesDataValue.Properties = unmarshaled
					}
					nodesDataValue.Status = nodesDataAttrs["status"].(types.String).ValueStringPointer()
					nodesDataValue.Type = nodesDataAttrs["type"].(types.String).ValueStringPointer()
					nodesValue.Data = nodesDataValue
					nodesValue.Grabbable = nodesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					nodesValue.Group = nodesAttrs["group"].(types.String).ValueStringPointer()
					nodesValue.Locked = nodesAttrs["locked"].(types.Bool).ValueBoolPointer()
					nodesValue.Pannable = nodesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !nodesAttrs["position"].IsNull() && !nodesAttrs["position"].IsUnknown() {
						nodesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsNodePosition{}
						nodesPositionAttrs := nodesAttrs["position"].(types.Object).Attributes()
						if !nodesPositionAttrs["x"].IsNull() && !nodesPositionAttrs["x"].IsUnknown() {
							nodesPositionValue.X = pingonetypes.BigFloatUnquoted{
								Float: nodesPositionAttrs["x"].(types.Number).ValueBigFloat(),
							}
						}
						if !nodesPositionAttrs["y"].IsNull() && !nodesPositionAttrs["y"].IsUnknown() {
							nodesPositionValue.Y = pingonetypes.BigFloatUnquoted{
								Float: nodesPositionAttrs["y"].(types.Number).ValueBigFloat(),
							}
						}
						nodesValue.Position = nodesPositionValue
					}
					nodesValue.Removed = nodesAttrs["removed"].(types.Bool).ValueBoolPointer()
					nodesValue.Selectable = nodesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					nodesValue.Selected = nodesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Nodes = append(graphDataElementsValue.Nodes, nodesValue)
				}
			}
			graphDataValue.Elements = graphDataElementsValue
		}
		if !graphDataAttrs["max_zoom"].IsNull() && !graphDataAttrs["max_zoom"].IsUnknown() {
			graphDataValue.MaxZoom = &pingonetypes.BigFloatUnquoted{
				Float: graphDataAttrs["max_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["min_zoom"].IsNull() && !graphDataAttrs["min_zoom"].IsUnknown() {
			graphDataValue.MinZoom = &pingonetypes.BigFloatUnquoted{
				Float: graphDataAttrs["min_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["pan"].IsNull() && !graphDataAttrs["pan"].IsUnknown() {
			graphDataPanValue := &pingone.DaVinciFlowGraphDataRequestPan{}
			graphDataPanAttrs := graphDataAttrs["pan"].(types.Object).Attributes()
			if !graphDataPanAttrs["x"].IsNull() && !graphDataPanAttrs["x"].IsUnknown() {
				graphDataPanValue.X = pingonetypes.BigFloatUnquoted{
					Float: graphDataPanAttrs["x"].(types.Number).ValueBigFloat(),
				}
			}
			if !graphDataPanAttrs["y"].IsNull() && !graphDataPanAttrs["y"].IsUnknown() {
				graphDataPanValue.Y = pingonetypes.BigFloatUnquoted{
					Float: graphDataPanAttrs["y"].(types.Number).ValueBigFloat(),
				}
			}
			graphDataValue.Pan = graphDataPanValue
		}
		graphDataValue.PanningEnabled = graphDataAttrs["panning_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["renderer"].IsNull() && !graphDataAttrs["renderer"].IsUnknown() {
			var newUnmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["renderer"].(jsontypes.Normalized).ValueString()), &newUnmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for renderer could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Renderer = newUnmarshaled
		}
		graphDataValue.UserPanningEnabled = graphDataAttrs["user_panning_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.UserZoomingEnabled = graphDataAttrs["user_zooming_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.Zoom = graphDataAttrs["zoom"].(types.Int32).ValueInt32Pointer()
		graphDataValue.ZoomingEnabled = graphDataAttrs["zooming_enabled"].(types.Bool).ValueBoolPointer()
		result.GraphData = graphDataValue
	}

	// input_schema
	if !model.InputSchema.IsNull() && !model.InputSchema.IsUnknown() {
		result.InputSchema = []pingone.DaVinciFlowInputSchemaRequestItem{}
		for _, inputSchemaElement := range model.InputSchema.Elements() {
			inputSchemaValue := pingone.DaVinciFlowInputSchemaRequestItem{}
			inputSchemaAttrs := inputSchemaElement.(types.Object).Attributes()
			inputSchemaValue.Description = inputSchemaAttrs["description"].(types.String).ValueStringPointer()
			inputSchemaValue.IsExpanded = inputSchemaAttrs["is_expanded"].(types.Bool).ValueBoolPointer()
			if !inputSchemaAttrs["preferred_control_type"].IsNull() && !inputSchemaAttrs["preferred_control_type"].IsUnknown() {
				inputSchemaPreferredControlTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredControlTypeFromValue(inputSchemaAttrs["preferred_control_type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("preferred_control_type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for preferred_control_type is not valid: %s", err.Error()),
					)
				} else {
					inputSchemaValue.PreferredControlType = inputSchemaPreferredControlTypeValue
				}
			}
			inputSchemaPreferredDataTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredDataTypeFromValue(inputSchemaAttrs["preferred_data_type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("preferred_data_type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for preferred_data_type is not valid: %s", err.Error()),
				)
			} else {
				inputSchemaValue.PreferredDataType = *inputSchemaPreferredDataTypeValue
			}
			inputSchemaValue.PropertyName = inputSchemaAttrs["property_name"].(types.String).ValueString()
			inputSchemaValue.Required = inputSchemaAttrs["required"].(types.Bool).ValueBoolPointer()
			result.InputSchema = append(result.InputSchema, inputSchemaValue)
		}
	}

	// name
	result.Name = model.Name.ValueString()
	// output_schema
	if !model.OutputSchema.IsNull() && !model.OutputSchema.IsUnknown() {
		outputSchemaValue := &pingone.DaVinciFlowOutputSchemaRequest{}
		outputSchemaAttrs := model.OutputSchema.Attributes()
		if !outputSchemaAttrs["output"].IsNull() && !outputSchemaAttrs["output"].IsUnknown() {
			outputSchemaOutputValue := pingone.DaVinciFlowOutputSchemaRequestOutput{}
			outputSchemaOutputAttrs := outputSchemaAttrs["output"].(types.Object).Attributes()
			outputSchemaOutputValue.AdditionalPropertiesField = outputSchemaOutputAttrs["additional_properties"].(types.Bool).ValueBoolPointer()
			if !outputSchemaOutputAttrs["properties"].IsNull() && !outputSchemaOutputAttrs["properties"].IsUnknown() {
				var unmarshaled map[string]interface{}
				err := json.Unmarshal([]byte(outputSchemaOutputAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
				if err != nil {
					respDiags.AddError(
						"Error Parsing JSON val",
						fmt.Sprintf("The value provided for output.output_schema.properties could not be parsed as json: %s", err.Error()),
					)
				}
				outputSchemaOutputValue.Properties = unmarshaled
			}
			outputSchemaOutputTypeValue, err := pingone.NewDaVinciFlowOutputSchemaRequestOutputTypeFromValue(outputSchemaOutputAttrs["type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("output_schema.output.type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for output_schema.output.type is not valid: %s", err.Error()),
				)
			} else {
				outputSchemaOutputValue.Type = *outputSchemaOutputTypeValue
			}
			outputSchemaValue.Output = outputSchemaOutputValue
		}
		result.OutputSchema = outputSchemaValue
	}

	// settings
	if !model.Settings.IsNull() && !model.Settings.IsUnknown() {
		settingsValue := &pingone.DaVinciFlowSettingsRequest{}
		settingsAttrs := model.Settings.Attributes()
		settingsValue.Csp = settingsAttrs["csp"].(types.String).ValueStringPointer()
		settingsValue.Css = settingsAttrs["css"].(types.String).ValueStringPointer()
		if !settingsAttrs["css_links"].IsNull() && !settingsAttrs["css_links"].IsUnknown() {
			settingsValue.CssLinks = []string{}
			for _, cssLinksElement := range settingsAttrs["css_links"].(types.Set).Elements() {
				settingsValue.CssLinks = append(settingsValue.CssLinks, cssLinksElement.(types.String).ValueString())
			}
		}
		settingsValue.CustomErrorScreenBrandLogoUrl = settingsAttrs["custom_error_screen_brand_logo_url"].(types.String).ValueStringPointer()
		if !settingsAttrs["custom_error_show_footer"].IsNull() && !settingsAttrs["custom_error_show_footer"].IsUnknown() {
			settingsValue.CustomErrorShowFooter = &pingone.DaVinciFlowSettingsRequestCustomErrorShowFooter{
				Bool: settingsAttrs["custom_error_show_footer"].(types.Bool).ValueBoolPointer(),
			}
		}
		settingsValue.CustomFaviconLink = settingsAttrs["custom_favicon_link"].(types.String).ValueStringPointer()
		settingsValue.CustomLogoURLSelection = settingsAttrs["custom_logo_urlselection"].(types.Int32).ValueInt32Pointer()
		settingsValue.CustomTitle = settingsAttrs["custom_title"].(types.String).ValueStringPointer()
		if !settingsAttrs["default_error_screen_brand_logo"].IsNull() && !settingsAttrs["default_error_screen_brand_logo"].IsUnknown() {
			settingsValue.DefaultErrorScreenBrandLogo = &pingone.DaVinciFlowSettingsRequestDefaultErrorScreenBrandLogo{
				Bool: settingsAttrs["default_error_screen_brand_logo"].(types.Bool).ValueBoolPointer(),
			}
		}
		settingsValue.FlowHttpTimeoutInSeconds = settingsAttrs["flow_http_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.FlowTimeoutInSeconds = settingsAttrs["flow_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		if !settingsAttrs["intermediate_loading_screen_css"].IsNull() && !settingsAttrs["intermediate_loading_screen_css"].IsUnknown() {
			settingsIntermediateLoadingScreenCSSValue := &pingone.DaVinciFlowSettingsRequestIntermediateLoadingScreenCSS{}
			settingsIntermediateLoadingScreenCSSValue.String = settingsAttrs["intermediate_loading_screen_css"].(types.String).ValueStringPointer()
			settingsValue.IntermediateLoadingScreenCSS = settingsIntermediateLoadingScreenCSSValue
		}
		if !settingsAttrs["intermediate_loading_screen_html"].IsNull() && !settingsAttrs["intermediate_loading_screen_html"].IsUnknown() {
			settingsIntermediateLoadingScreenHTMLValue := &pingone.DaVinciFlowSettingsRequestIntermediateLoadingScreenHTML{}
			settingsIntermediateLoadingScreenHTMLValue.String = settingsAttrs["intermediate_loading_screen_html"].(types.String).ValueStringPointer()
			settingsValue.IntermediateLoadingScreenHTML = settingsIntermediateLoadingScreenHTMLValue
		}
		settingsValue.JsCustomFlowPlayer = settingsAttrs["js_custom_flow_player"].(types.String).ValueStringPointer()
		if !settingsAttrs["js_links"].IsNull() && !settingsAttrs["js_links"].IsUnknown() {
			settingsValue.JsLinks = []pingone.DaVinciFlowSettingsRequestJsLink{}
			for _, jsLinksElement := range settingsAttrs["js_links"].(types.Set).Elements() {
				jsLinksValue := pingone.DaVinciFlowSettingsRequestJsLink{}
				jsLinksAttrs := jsLinksElement.(types.Object).Attributes()
				jsLinksValue.Crossorigin = jsLinksAttrs["crossorigin"].(types.String).ValueString()
				if !jsLinksAttrs["defer"].IsNull() && !jsLinksAttrs["defer"].IsUnknown() {
					jsLinksValue.Defer = pingone.DaVinciFlowSettingsRequestJsLinkDefer{
						Bool: jsLinksAttrs["defer"].(types.Bool).ValueBoolPointer(),
					}
				}
				jsLinksValue.Integrity = jsLinksAttrs["integrity"].(types.String).ValueString()
				jsLinksValue.Label = jsLinksAttrs["label"].(types.String).ValueString()
				jsLinksValue.Referrerpolicy = jsLinksAttrs["referrerpolicy"].(types.String).ValueString()
				jsLinksValue.Type = jsLinksAttrs["type"].(types.String).ValueString()
				jsLinksValue.Value = jsLinksAttrs["value"].(types.String).ValueString()
				settingsValue.JsLinks = append(settingsValue.JsLinks, jsLinksValue)
			}
		}
		settingsValue.LogLevel = settingsAttrs["log_level"].(types.Int32).ValueInt32Pointer()
		if !settingsAttrs["require_authentication_to_initiate"].IsNull() && !settingsAttrs["require_authentication_to_initiate"].IsUnknown() {
			settingsValue.RequireAuthenticationToInitiate = &pingone.DaVinciFlowSettingsRequestRequireAuthenticationToInitiate{
				Bool: settingsAttrs["require_authentication_to_initiate"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["scrub_sensitive_info"].IsNull() && !settingsAttrs["scrub_sensitive_info"].IsUnknown() {
			settingsValue.ScrubSensitiveInfo = &pingone.DaVinciFlowSettingsRequestScrubSensitiveInfo{
				Bool: settingsAttrs["scrub_sensitive_info"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["sensitive_info_fields"].IsNull() && !settingsAttrs["sensitive_info_fields"].IsUnknown() {
			settingsValue.SensitiveInfoFields = []string{}
			for _, sensitiveInfoFieldsElement := range settingsAttrs["sensitive_info_fields"].(types.Set).Elements() {
				settingsValue.SensitiveInfoFields = append(settingsValue.SensitiveInfoFields, sensitiveInfoFieldsElement.(types.String).ValueString())
			}
		}
		if !settingsAttrs["use_csp"].IsNull() && !settingsAttrs["use_csp"].IsUnknown() {
			settingsValue.UseCSP = &pingone.DaVinciFlowSettingsRequestUseCSP{
				Bool: settingsAttrs["use_csp"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_css"].IsNull() && !settingsAttrs["use_custom_css"].IsUnknown() {
			settingsValue.UseCustomCSS = &pingone.DaVinciFlowSettingsRequestUseCustomCSS{
				Bool: settingsAttrs["use_custom_css"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_flow_player"].IsNull() && !settingsAttrs["use_custom_flow_player"].IsUnknown() {
			settingsValue.UseCustomFlowPlayer = &pingone.DaVinciFlowSettingsRequestUseCustomFlowPlayer{
				Bool: settingsAttrs["use_custom_flow_player"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_custom_script"].IsNull() && !settingsAttrs["use_custom_script"].IsUnknown() {
			settingsValue.UseCustomScript = &pingone.DaVinciFlowSettingsRequestUseCustomScript{
				Bool: settingsAttrs["use_custom_script"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["use_intermediate_loading_screen"].IsNull() && !settingsAttrs["use_intermediate_loading_screen"].IsUnknown() {
			settingsValue.UseIntermediateLoadingScreen = &pingone.DaVinciFlowSettingsRequestUseIntermediateLoadingScreen{
				Bool: settingsAttrs["use_intermediate_loading_screen"].(types.Bool).ValueBoolPointer(),
			}
		}
		if !settingsAttrs["validate_on_save"].IsNull() && !settingsAttrs["validate_on_save"].IsUnknown() {
			settingsValue.ValidateOnSave = &pingone.DaVinciFlowSettingsRequestValidateOnSave{
				Bool: settingsAttrs["validate_on_save"].(types.Bool).ValueBoolPointer(),
			}
		}
		result.Settings = settingsValue
	}

	// trigger
	if !model.Trigger.IsNull() && !model.Trigger.IsUnknown() {
		triggerValue := &pingone.DaVinciFlowTriggerRequest{}
		triggerAttrs := model.Trigger.Attributes()
		if !triggerAttrs["configuration"].IsNull() && !triggerAttrs["configuration"].IsUnknown() {
			triggerConfigurationValue := &pingone.DaVinciFlowTriggerRequestConfiguration{}
			triggerConfigurationAttrs := triggerAttrs["configuration"].(types.Object).Attributes()
			if !triggerConfigurationAttrs["mfa"].IsNull() && !triggerConfigurationAttrs["mfa"].IsUnknown() {
				triggerConfigurationMfaValue := pingone.DaVinciFlowTriggerRequestConfigurationMFA{}
				triggerConfigurationMfaAttrs := triggerConfigurationAttrs["mfa"].(types.Object).Attributes()
				triggerConfigurationMfaValue.Enabled = triggerConfigurationMfaAttrs["enabled"].(types.Bool).ValueBool()
				triggerConfigurationMfaValue.Time = triggerConfigurationMfaAttrs["time"].(types.Float32).ValueFloat32()
				triggerConfigurationMfaValue.TimeFormat = triggerConfigurationMfaAttrs["time_format"].(types.String).ValueString()
				triggerConfigurationValue.Mfa = triggerConfigurationMfaValue
			}
			if !triggerConfigurationAttrs["pwd"].IsNull() && !triggerConfigurationAttrs["pwd"].IsUnknown() {
				triggerConfigurationPwdValue := pingone.DaVinciFlowTriggerRequestConfigurationPassword{}
				triggerConfigurationPwdAttrs := triggerConfigurationAttrs["pwd"].(types.Object).Attributes()
				triggerConfigurationPwdValue.Enabled = triggerConfigurationPwdAttrs["enabled"].(types.Bool).ValueBool()
				triggerConfigurationPwdValue.Time = triggerConfigurationPwdAttrs["time"].(types.Float32).ValueFloat32()
				triggerConfigurationPwdValue.TimeFormat = triggerConfigurationPwdAttrs["time_format"].(types.String).ValueString()
				triggerConfigurationValue.Pwd = triggerConfigurationPwdValue
			}
			triggerValue.Configuration = triggerConfigurationValue
		}
		triggerTypeValue, err := pingone.NewDaVinciFlowTriggerRequestTypeFromValue(triggerAttrs["type"].(types.String).ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			triggerValue.Type = *triggerTypeValue
		}
		result.Trigger = triggerValue
	}

	return result, respDiags
}

func (state *davinciFlowResourceModel) readClientResponse(response *pingone.DaVinciFlowResponse) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	// color
	state.Color = types.StringPointerValue(response.Color)
	// connectors
	connectorsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	connectorsElementType := types.ObjectType{AttrTypes: connectorsAttrTypes}
	var connectorsValue types.Set
	if response.Connectors == nil {
		connectorsValue = types.SetNull(connectorsElementType)
	} else {
		var connectorsValues []attr.Value
		for _, connectorsResponseValue := range response.Connectors {
			connectorsValue, diags := types.ObjectValue(connectorsAttrTypes, map[string]attr.Value{
				"id": types.StringValue(connectorsResponseValue.Id),
			})
			respDiags.Append(diags...)
			connectorsValues = append(connectorsValues, connectorsValue)
		}
		connectorsValue, diags = types.SetValue(connectorsElementType, connectorsValues)
		respDiags.Append(diags...)
	}
	state.Connectors = connectorsValue
	// current_version
	state.CurrentVersion = types.Float32PointerValue(response.CurrentVersion)
	// description
	state.Description = types.StringPointerValue(response.Description)
	// enabled
	state.Enabled = types.BoolPointerValue(response.Enabled)
	// graph_data
	graphDataElementsEdgesDataAttrTypes := map[string]attr.Type{
		"id":     types.StringType,
		"source": types.StringType,
		"target": types.StringType,
	}
	graphDataElementsEdgesPositionAttrTypes := map[string]attr.Type{
		"x": types.NumberType,
		"y": types.NumberType,
	}
	graphDataElementsEdgesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsEdgesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsEdgesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsEdgesElementType := types.ObjectType{AttrTypes: graphDataElementsEdgesAttrTypes}
	graphDataElementsNodesDataAttrTypes := map[string]attr.Type{
		"capability_name": types.StringType,
		"connection_id":   types.StringType,
		"connector_id":    types.StringType,
		"id":              types.StringType,
		"id_unique":       types.StringType,
		"label":           types.StringType,
		"name":            types.StringType,
		"node_type":       types.StringType,
		"properties":      jsontypes.NormalizedType{},
		"status":          types.StringType,
		"type":            types.StringType,
	}
	graphDataElementsNodesPositionAttrTypes := map[string]attr.Type{
		"x": types.NumberType,
		"y": types.NumberType,
	}
	graphDataElementsNodesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsNodesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsNodesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsNodesElementType := types.ObjectType{AttrTypes: graphDataElementsNodesAttrTypes}
	graphDataElementsAttrTypes := map[string]attr.Type{
		"edges": types.MapType{ElemType: graphDataElementsEdgesElementType},
		"nodes": types.MapType{ElemType: graphDataElementsNodesElementType},
	}
	graphDataPanAttrTypes := map[string]attr.Type{
		"x": types.NumberType,
		"y": types.NumberType,
	}
	graphDataAttrTypes := map[string]attr.Type{
		"box_selection_enabled": types.BoolType,
		"data":                  jsontypes.NormalizedType{},
		"elements":              types.ObjectType{AttrTypes: graphDataElementsAttrTypes},
		"max_zoom":              types.NumberType,
		"min_zoom":              types.NumberType,
		"pan":                   types.ObjectType{AttrTypes: graphDataPanAttrTypes},
		"panning_enabled":       types.BoolType,
		"renderer":              jsontypes.NormalizedType{},
		"user_panning_enabled":  types.BoolType,
		"user_zooming_enabled":  types.BoolType,
		"zoom":                  types.Int32Type,
		"zooming_enabled":       types.BoolType,
	}
	var graphDataValue types.Object
	if response.GraphData == nil {
		graphDataValue = types.ObjectNull(graphDataAttrTypes)
	} else {
		var graphDataDataValue jsontypes.Normalized
		if response.GraphData.Data == nil {
			graphDataDataValue = jsontypes.NewNormalizedNull()
		} else {
			graphDataDataBytes, err := json.Marshal(response.GraphData.Data)
			if err != nil {
				respDiags.AddError(
					"Error Marshaling graphData.data",
					fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
				)
			} else {
				graphDataDataValue = jsontypes.NewNormalizedValue(string(graphDataDataBytes))
			}
		}
		graphDataElementsEdgesValues := make(map[string]attr.Value)
		for _, graphDataElementsEdgesResponseValue := range response.GraphData.Elements.Edges {
			graphDataElementsEdgesDataValue, diags := types.ObjectValue(graphDataElementsEdgesDataAttrTypes, map[string]attr.Value{
				"id":     types.StringValue(graphDataElementsEdgesResponseValue.Data.Id),
				"source": types.StringValue(graphDataElementsEdgesResponseValue.Data.Source),
				"target": types.StringValue(graphDataElementsEdgesResponseValue.Data.Target),
			})
			respDiags.Append(diags...)
			graphDataElementsEdgesPositionValue, diags := types.ObjectValue(graphDataElementsEdgesPositionAttrTypes, map[string]attr.Value{
				"x": types.NumberValue(graphDataElementsEdgesResponseValue.Position.X.Float),
				"y": types.NumberValue(graphDataElementsEdgesResponseValue.Position.Y.Float),
			})
			respDiags.Append(diags...)
			graphDataElementsEdgesValue, diags := types.ObjectValue(graphDataElementsEdgesAttrTypes, map[string]attr.Value{
				"classes":    types.StringPointerValue(graphDataElementsEdgesResponseValue.Classes),
				"data":       graphDataElementsEdgesDataValue,
				"grabbable":  types.BoolValue(graphDataElementsEdgesResponseValue.Grabbable),
				"group":      types.StringValue(graphDataElementsEdgesResponseValue.Group),
				"locked":     types.BoolValue(graphDataElementsEdgesResponseValue.Locked),
				"pannable":   types.BoolValue(graphDataElementsEdgesResponseValue.Pannable),
				"position":   graphDataElementsEdgesPositionValue,
				"removed":    types.BoolValue(graphDataElementsEdgesResponseValue.Removed),
				"selectable": types.BoolValue(graphDataElementsEdgesResponseValue.Selectable),
				"selected":   types.BoolValue(graphDataElementsEdgesResponseValue.Selected),
			})
			respDiags.Append(diags...)
			// Use the unique key for the edge
			graphDataElementsEdgesValueKey := davinciFlowEdgeKey(graphDataElementsEdgesResponseValue.Data.Id, graphDataElementsEdgesResponseValue.Data.Source, graphDataElementsEdgesResponseValue.Data.Target)
			graphDataElementsEdgesValues[graphDataElementsEdgesValueKey] = graphDataElementsEdgesValue
		}
		graphDataElementsEdgesValue, diags := types.MapValue(graphDataElementsEdgesElementType, graphDataElementsEdgesValues)
		respDiags.Append(diags...)
		graphDataElementsNodesValues := make(map[string]attr.Value)
		for _, graphDataElementsNodesResponseValue := range response.GraphData.Elements.Nodes {
			var graphDataElementsNodesDataPropertiesValue jsontypes.Normalized
			if graphDataElementsNodesResponseValue.Data.Properties == nil {
				graphDataElementsNodesDataPropertiesValue = jsontypes.NewNormalizedNull()
			} else {
				graphDataElementsNodesDataPropertiesBytes, err := json.Marshal(graphDataElementsNodesResponseValue.Data.Properties)
				if err != nil {
					respDiags.AddError(
						"Error Marshaling graphData.elements.nodes.data.properties",
						fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
					)
				} else {
					graphDataElementsNodesDataPropertiesValue = jsontypes.NewNormalizedValue(string(graphDataElementsNodesDataPropertiesBytes))
				}
			}
			graphDataElementsNodesDataValue, diags := types.ObjectValue(graphDataElementsNodesDataAttrTypes, map[string]attr.Value{
				"capability_name": types.StringPointerValue(graphDataElementsNodesResponseValue.Data.CapabilityName),
				"connection_id":   types.StringPointerValue(graphDataElementsNodesResponseValue.Data.ConnectionId),
				"connector_id":    types.StringPointerValue(graphDataElementsNodesResponseValue.Data.ConnectorId),
				"id":              types.StringValue(graphDataElementsNodesResponseValue.Data.Id),
				"id_unique":       types.StringPointerValue(graphDataElementsNodesResponseValue.Data.IdUnique),
				"label":           types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Label),
				"name":            types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Name),
				"node_type":       types.StringValue(graphDataElementsNodesResponseValue.Data.NodeType),
				"properties":      graphDataElementsNodesDataPropertiesValue,
				"status":          types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Status),
				"type":            types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Type),
			})
			respDiags.Append(diags...)
			graphDataElementsNodesPositionValue, diags := types.ObjectValue(graphDataElementsNodesPositionAttrTypes, map[string]attr.Value{
				"x": types.NumberValue(graphDataElementsNodesResponseValue.Position.X.Float),
				"y": types.NumberValue(graphDataElementsNodesResponseValue.Position.Y.Float),
			})
			respDiags.Append(diags...)
			graphDataElementsNodesValue, diags := types.ObjectValue(graphDataElementsNodesAttrTypes, map[string]attr.Value{
				"classes":    types.StringPointerValue(graphDataElementsNodesResponseValue.Classes),
				"data":       graphDataElementsNodesDataValue,
				"grabbable":  types.BoolValue(graphDataElementsNodesResponseValue.Grabbable),
				"group":      types.StringValue(graphDataElementsNodesResponseValue.Group),
				"locked":     types.BoolValue(graphDataElementsNodesResponseValue.Locked),
				"pannable":   types.BoolValue(graphDataElementsNodesResponseValue.Pannable),
				"position":   graphDataElementsNodesPositionValue,
				"removed":    types.BoolValue(graphDataElementsNodesResponseValue.Removed),
				"selectable": types.BoolValue(graphDataElementsNodesResponseValue.Selectable),
				"selected":   types.BoolValue(graphDataElementsNodesResponseValue.Selected),
			})
			respDiags.Append(diags...)
			// Use the unique key for the node
			var graphDataElementsNodesValueKey string
			if graphDataElementsNodesResponseValue.Data.IdUnique != nil && *graphDataElementsNodesResponseValue.Data.IdUnique != "" {
				graphDataElementsNodesValueKey = *graphDataElementsNodesResponseValue.Data.IdUnique
			} else {
				graphDataElementsNodesValueKey = graphDataElementsNodesResponseValue.Data.Id
			}
			graphDataElementsNodesValues[graphDataElementsNodesValueKey] = graphDataElementsNodesValue
		}
		graphDataElementsNodesValue, diags := types.MapValue(graphDataElementsNodesElementType, graphDataElementsNodesValues)
		respDiags.Append(diags...)
		graphDataElementsValue, diags := types.ObjectValue(graphDataElementsAttrTypes, map[string]attr.Value{
			"edges": graphDataElementsEdgesValue,
			"nodes": graphDataElementsNodesValue,
		})
		respDiags.Append(diags...)
		var maxZoomValue types.Number
		if response.GraphData.MaxZoom == nil || response.GraphData.MaxZoom.Float == nil {
			maxZoomValue = types.NumberNull()
		} else {
			maxZoomValue = types.NumberValue(response.GraphData.MaxZoom.Float)
		}
		var minZoomValue types.Number
		if response.GraphData.MinZoom == nil || response.GraphData.MinZoom.Float == nil {
			minZoomValue = types.NumberNull()
		} else {
			minZoomValue = types.NumberValue(response.GraphData.MinZoom.Float)
		}
		graphDataPanValue, diags := types.ObjectValue(graphDataPanAttrTypes, map[string]attr.Value{
			"x": types.NumberValue(response.GraphData.Pan.X.Float),
			"y": types.NumberValue(response.GraphData.Pan.Y.Float),
		})
		respDiags.Append(diags...)
		graphDataRendererValue := jsontypes.NewNormalizedNull()
		graphDataRendererBytes, err := json.Marshal(response.GraphData.Renderer)
		if err != nil {
			respDiags.AddError(
				"Error Marshaling graphData.renderer",
				fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
			)
		} else {
			graphDataRendererValue = jsontypes.NewNormalizedValue(string(graphDataRendererBytes))
		}
		graphDataValue, diags = types.ObjectValue(graphDataAttrTypes, map[string]attr.Value{
			"box_selection_enabled": types.BoolValue(response.GraphData.BoxSelectionEnabled),
			"data":                  graphDataDataValue,
			"elements":              graphDataElementsValue,
			"max_zoom":              maxZoomValue,
			"min_zoom":              minZoomValue,
			"pan":                   graphDataPanValue,
			"panning_enabled":       types.BoolValue(response.GraphData.PanningEnabled),
			"renderer":              graphDataRendererValue,
			"user_panning_enabled":  types.BoolValue(response.GraphData.UserPanningEnabled),
			"user_zooming_enabled":  types.BoolValue(response.GraphData.UserZoomingEnabled),
			// floor the zoom to an integer to match the schema
			"zoom":            types.Int32Value(int32(response.GraphData.Zoom)),
			"zooming_enabled": types.BoolPointerValue(response.GraphData.ZoomingEnabled),
		})
		respDiags.Append(diags...)
	}
	state.GraphData = graphDataValue
	// id
	state.Id = types.StringValue(response.Id)
	// input_schema
	inputSchemaAttrTypes := map[string]attr.Type{
		"description":            types.StringType,
		"is_expanded":            types.BoolType,
		"preferred_control_type": types.StringType,
		"preferred_data_type":    types.StringType,
		"property_name":          types.StringType,
		"required":               types.BoolType,
	}
	inputSchemaElementType := types.ObjectType{AttrTypes: inputSchemaAttrTypes}
	var inputSchemaValue types.List
	if response.InputSchema == nil {
		inputSchemaValue = types.ListNull(inputSchemaElementType)
	} else {
		var inputSchemaValues []attr.Value
		for _, inputSchemaResponseValue := range response.InputSchema {
			inputSchemaPreferredControlTypeValue := types.StringValue(string(inputSchemaResponseValue.PreferredControlType))
			inputSchemaPreferredDataTypeValue := types.StringValue(string(inputSchemaResponseValue.PreferredDataType))
			inputSchemaValue, diags := types.ObjectValue(inputSchemaAttrTypes, map[string]attr.Value{
				"description":            types.StringPointerValue(inputSchemaResponseValue.Description),
				"is_expanded":            types.BoolPointerValue(inputSchemaResponseValue.IsExpanded),
				"preferred_control_type": inputSchemaPreferredControlTypeValue,
				"preferred_data_type":    inputSchemaPreferredDataTypeValue,
				"property_name":          types.StringValue(inputSchemaResponseValue.PropertyName),
				"required":               types.BoolPointerValue(inputSchemaResponseValue.Required),
			})
			respDiags.Append(diags...)
			inputSchemaValues = append(inputSchemaValues, inputSchemaValue)
		}
		inputSchemaValue, diags = types.ListValue(inputSchemaElementType, inputSchemaValues)
		respDiags.Append(diags...)
	}
	state.InputSchema = inputSchemaValue
	// name
	state.Name = types.StringValue(response.Name)
	// output_schema
	outputSchemaOutputAttrTypes := map[string]attr.Type{
		"additional_properties": types.BoolType,
		"properties":            jsontypes.NormalizedType{},
		"type":                  types.StringType,
	}
	outputSchemaAttrTypes := map[string]attr.Type{
		"output": types.ObjectType{AttrTypes: outputSchemaOutputAttrTypes},
	}
	var outputSchemaValue types.Object
	if response.OutputSchema == nil {
		outputSchemaValue = types.ObjectNull(outputSchemaAttrTypes)
	} else {
		var outputSchemaOutputPropertiesValue jsontypes.Normalized
		if response.OutputSchema.Output.Properties == nil {
			outputSchemaOutputPropertiesValue = jsontypes.NewNormalizedNull()
		} else {
			outputSchemaOutputPropertiesBytes, err := json.Marshal(response.OutputSchema.Output.Properties)
			if err != nil {
				respDiags.AddError(
					"Error Marshaling outputSchema.output.properties",
					fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
				)
			} else {
				outputSchemaOutputPropertiesValue = jsontypes.NewNormalizedValue(string(outputSchemaOutputPropertiesBytes))
			}
		}
		outputSchemaOutputValue, diags := types.ObjectValue(outputSchemaOutputAttrTypes, map[string]attr.Value{
			"additional_properties": types.BoolPointerValue(response.OutputSchema.Output.AdditionalPropertiesField),
			"properties":            outputSchemaOutputPropertiesValue,
			"type":                  types.StringValue(string(response.OutputSchema.Output.Type)),
		})
		respDiags.Append(diags...)
		outputSchemaValue, diags = types.ObjectValue(outputSchemaAttrTypes, map[string]attr.Value{
			"output": outputSchemaOutputValue,
		})
		respDiags.Append(diags...)
	}
	state.OutputSchema = outputSchemaValue
	// published_version
	state.PublishedVersion = types.Float32PointerValue(response.PublishedVersion)
	// settings
	settingsJsLinksAttrTypes := map[string]attr.Type{
		"crossorigin":    types.StringType,
		"defer":          types.BoolType,
		"integrity":      types.StringType,
		"label":          types.StringType,
		"referrerpolicy": types.StringType,
		"type":           types.StringType,
		"value":          types.StringType,
	}
	settingsJsLinksElementType := types.ObjectType{AttrTypes: settingsJsLinksAttrTypes}
	settingsAttrTypes := map[string]attr.Type{
		"csp":                                types.StringType,
		"css":                                types.StringType,
		"css_links":                          types.SetType{ElemType: types.StringType},
		"custom_error_screen_brand_logo_url": types.StringType,
		"custom_error_show_footer":           types.BoolType,
		"custom_favicon_link":                types.StringType,
		"custom_logo_urlselection":           types.Int32Type,
		"custom_title":                       types.StringType,
		"default_error_screen_brand_logo":    types.BoolType,
		"flow_http_timeout_in_seconds":       types.Int32Type,
		"flow_timeout_in_seconds":            types.Int32Type,
		"intermediate_loading_screen_css":    types.StringType,
		"intermediate_loading_screen_html":   types.StringType,
		"js_custom_flow_player":              types.StringType,
		"js_links":                           types.SetType{ElemType: settingsJsLinksElementType},
		"log_level":                          types.Int32Type,
		"require_authentication_to_initiate": types.BoolType,
		"scrub_sensitive_info":               types.BoolType,
		"sensitive_info_fields":              types.SetType{ElemType: types.StringType},
		"use_csp":                            types.BoolType,
		"use_custom_css":                     types.BoolType,
		"use_custom_flow_player":             types.BoolType,
		"use_custom_script":                  types.BoolType,
		"use_intermediate_loading_screen":    types.BoolType,
		"validate_on_save":                   types.BoolType,
	}
	var settingsValue types.Object
	if response.Settings == nil {
		settingsValue = types.ObjectNull(settingsAttrTypes)
	} else {
		var settingsCssLinksValue types.Set
		if response.Settings.CssLinks == nil {
			settingsCssLinksValue = types.SetNull(types.StringType)
		} else {
			settingsCssLinksValue, diags = types.SetValueFrom(context.Background(), types.StringType, response.Settings.CssLinks)
			respDiags.Append(diags...)
		}
		var settingsCustomErrorShowFooterValue types.Bool
		if response.Settings.CustomErrorShowFooter == nil {
			settingsCustomErrorShowFooterValue = types.BoolNull()
		} else {
			settingsCustomErrorShowFooterValue = types.BoolPointerValue(response.Settings.CustomErrorShowFooter.Bool)
		}
		var settingsDefaultErrorScreenBrandLogoValue types.Bool
		if response.Settings.DefaultErrorScreenBrandLogo == nil {
			settingsDefaultErrorScreenBrandLogoValue = types.BoolNull()
		} else {
			settingsDefaultErrorScreenBrandLogoValue = types.BoolPointerValue(response.Settings.DefaultErrorScreenBrandLogo.Bool)
		}
		var flowTimeoutInSecondsValue types.Int32
		if response.Settings.FlowTimeoutInSeconds == nil {
			flowTimeoutInSecondsValue = types.Int32Null()
		} else {
			// Truncate timeout to int32 to match the schema
			flowTimeoutInSecondsValue = types.Int32Value(int32(*response.Settings.FlowTimeoutInSeconds))
		}
		var intermediateLoadingScreenCSSValue types.String
		if response.Settings.IntermediateLoadingScreenCSS == nil {
			intermediateLoadingScreenCSSValue = types.StringNull()
		} else {
			// If string is set or if neither object nor string is set, just use the .String value
			if response.Settings.IntermediateLoadingScreenCSS.String != nil || response.Settings.IntermediateLoadingScreenCSS.Object == nil {
				intermediateLoadingScreenCSSValue = types.StringPointerValue(response.Settings.IntermediateLoadingScreenCSS.String)
			} else {
				// Otherwise, marshal the .Object field to a JSON string
				intermediateLoadingScreenCSSValueBytes, err := json.Marshal(response.Settings.IntermediateLoadingScreenCSS.Object)
				if err != nil {
					respDiags.AddError(
						"Error Marshaling settings.intermediateLoadingScreenCSS.object",
						fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
					)
				}
				intermediateLoadingScreenCSSValue = types.StringValue(string(intermediateLoadingScreenCSSValueBytes))
			}
		}
		var intermediateLoadingScreenHTMLValue types.String
		if response.Settings.IntermediateLoadingScreenHTML == nil {
			intermediateLoadingScreenHTMLValue = types.StringNull()
		} else {
			// If string is set or if neither object nor string is set, just use the .String value
			if response.Settings.IntermediateLoadingScreenHTML.String != nil || response.Settings.IntermediateLoadingScreenHTML.Object == nil {
				intermediateLoadingScreenHTMLValue = types.StringPointerValue(response.Settings.IntermediateLoadingScreenHTML.String)
			} else {
				// Otherwise, marshal the .Object field to a JSON string
				intermediateLoadingScreenHTMLValueBytes, err := json.Marshal(response.Settings.IntermediateLoadingScreenHTML.Object)
				if err != nil {
					respDiags.AddError(
						"Error Marshaling settings.intermediateLoadingScreenHTML.object",
						fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
					)
				}
				intermediateLoadingScreenHTMLValue = types.StringValue(string(intermediateLoadingScreenHTMLValueBytes))
			}
		}
		var settingsJsLinksValue types.Set
		if response.Settings.JsLinks == nil {
			settingsJsLinksValue = types.SetNull(settingsJsLinksElementType)
		} else {
			var settingsJsLinksValues []attr.Value
			for _, settingsJsLinksResponseValue := range response.Settings.JsLinks {
				settingsJsLinksValue, diags := types.ObjectValue(settingsJsLinksAttrTypes, map[string]attr.Value{
					"crossorigin":    types.StringValue(settingsJsLinksResponseValue.Crossorigin),
					"defer":          types.BoolPointerValue(settingsJsLinksResponseValue.Defer.Bool),
					"integrity":      types.StringValue(settingsJsLinksResponseValue.Integrity),
					"label":          types.StringValue(settingsJsLinksResponseValue.Label),
					"referrerpolicy": types.StringValue(settingsJsLinksResponseValue.Referrerpolicy),
					"type":           types.StringValue(settingsJsLinksResponseValue.Type),
					"value":          types.StringValue(settingsJsLinksResponseValue.Value),
				})
				respDiags.Append(diags...)
				settingsJsLinksValues = append(settingsJsLinksValues, settingsJsLinksValue)
			}
			settingsJsLinksValue, diags = types.SetValue(settingsJsLinksElementType, settingsJsLinksValues)
			respDiags.Append(diags...)
		}
		var settingsRequireAuthenticationToInitiateValue types.Bool
		if response.Settings.RequireAuthenticationToInitiate == nil {
			settingsRequireAuthenticationToInitiateValue = types.BoolNull()
		} else {
			settingsRequireAuthenticationToInitiateValue = types.BoolPointerValue(response.Settings.RequireAuthenticationToInitiate.Bool)
		}
		var settingsScrubSensitiveInfoValue types.Bool
		if response.Settings.ScrubSensitiveInfo == nil {
			settingsScrubSensitiveInfoValue = types.BoolNull()
		} else {
			settingsScrubSensitiveInfoValue = types.BoolPointerValue(response.Settings.ScrubSensitiveInfo.Bool)
		}
		var settingsSensitiveInfoFieldsValue types.Set
		if response.Settings.SensitiveInfoFields == nil {
			settingsSensitiveInfoFieldsValue = types.SetNull(types.StringType)
		} else {
			settingsSensitiveInfoFieldsValue, diags = types.SetValueFrom(context.Background(), types.StringType, response.Settings.SensitiveInfoFields)
			respDiags.Append(diags...)
		}
		var settingsUseCSPValue types.Bool
		if response.Settings.UseCSP == nil {
			settingsUseCSPValue = types.BoolNull()
		} else {
			settingsUseCSPValue = types.BoolPointerValue(response.Settings.UseCSP.Bool)
		}
		var settingsUseCustomCSSValue types.Bool
		if response.Settings.UseCustomCSS == nil {
			settingsUseCustomCSSValue = types.BoolNull()
		} else {
			settingsUseCustomCSSValue = types.BoolPointerValue(response.Settings.UseCustomCSS.Bool)
		}
		var settingsUseCustomFlowPlayerValue types.Bool
		if response.Settings.UseCustomFlowPlayer == nil {
			settingsUseCustomFlowPlayerValue = types.BoolNull()
		} else {
			settingsUseCustomFlowPlayerValue = types.BoolPointerValue(response.Settings.UseCustomFlowPlayer.Bool)
		}
		var settingsUseCustomScriptValue types.Bool
		if response.Settings.UseCustomScript == nil {
			settingsUseCustomScriptValue = types.BoolNull()
		} else {
			settingsUseCustomScriptValue = types.BoolPointerValue(response.Settings.UseCustomScript.Bool)
		}
		var settingsUseIntermediateLoadingScreenValue types.Bool
		if response.Settings.UseIntermediateLoadingScreen == nil {
			settingsUseIntermediateLoadingScreenValue = types.BoolNull()
		} else {
			settingsUseIntermediateLoadingScreenValue = types.BoolPointerValue(response.Settings.UseIntermediateLoadingScreen.Bool)
		}
		var settingsValidateOnSaveValue types.Bool
		if response.Settings.ValidateOnSave == nil {
			settingsValidateOnSaveValue = types.BoolNull()
		} else {
			settingsValidateOnSaveValue = types.BoolPointerValue(response.Settings.ValidateOnSave.Bool)
		}
		settingsValue, diags = types.ObjectValue(settingsAttrTypes, map[string]attr.Value{
			"csp":                                types.StringPointerValue(response.Settings.Csp),
			"css":                                types.StringPointerValue(response.Settings.Css),
			"css_links":                          settingsCssLinksValue,
			"custom_error_screen_brand_logo_url": types.StringPointerValue(response.Settings.CustomErrorScreenBrandLogoUrl),
			"custom_error_show_footer":           settingsCustomErrorShowFooterValue,
			"custom_favicon_link":                types.StringPointerValue(response.Settings.CustomFaviconLink),
			"custom_logo_urlselection":           types.Int32PointerValue(response.Settings.CustomLogoURLSelection),
			"custom_title":                       types.StringPointerValue(response.Settings.CustomTitle),
			"default_error_screen_brand_logo":    settingsDefaultErrorScreenBrandLogoValue,
			"flow_http_timeout_in_seconds":       types.Int32PointerValue(response.Settings.FlowHttpTimeoutInSeconds),
			"flow_timeout_in_seconds":            flowTimeoutInSecondsValue,
			"intermediate_loading_screen_css":    intermediateLoadingScreenCSSValue,
			"intermediate_loading_screen_html":   intermediateLoadingScreenHTMLValue,
			"js_custom_flow_player":              types.StringPointerValue(response.Settings.JsCustomFlowPlayer),
			"js_links":                           settingsJsLinksValue,
			"log_level":                          types.Int32PointerValue(response.Settings.LogLevel),
			"require_authentication_to_initiate": settingsRequireAuthenticationToInitiateValue,
			"scrub_sensitive_info":               settingsScrubSensitiveInfoValue,
			"sensitive_info_fields":              settingsSensitiveInfoFieldsValue,
			"use_csp":                            settingsUseCSPValue,
			"use_custom_css":                     settingsUseCustomCSSValue,
			"use_custom_flow_player":             settingsUseCustomFlowPlayerValue,
			"use_custom_script":                  settingsUseCustomScriptValue,
			"use_intermediate_loading_screen":    settingsUseIntermediateLoadingScreenValue,
			"validate_on_save":                   settingsValidateOnSaveValue,
		})
		respDiags.Append(diags...)
	}
	state.Settings = settingsValue
	// trigger
	triggerConfigurationMfaAttrTypes := map[string]attr.Type{
		"enabled":     types.BoolType,
		"time":        types.Float32Type,
		"time_format": types.StringType,
	}
	triggerConfigurationPwdAttrTypes := map[string]attr.Type{
		"enabled":     types.BoolType,
		"time":        types.Float32Type,
		"time_format": types.StringType,
	}
	triggerConfigurationAttrTypes := map[string]attr.Type{
		"mfa": types.ObjectType{AttrTypes: triggerConfigurationMfaAttrTypes},
		"pwd": types.ObjectType{AttrTypes: triggerConfigurationPwdAttrTypes},
	}
	triggerAttrTypes := map[string]attr.Type{
		"configuration": types.ObjectType{AttrTypes: triggerConfigurationAttrTypes},
		"type":          types.StringType,
	}
	var triggerValue types.Object
	if response.Trigger == nil {
		triggerValue = types.ObjectNull(triggerAttrTypes)
	} else {
		var triggerConfigurationValue types.Object
		if response.Trigger.Configuration == nil {
			triggerConfigurationValue = types.ObjectNull(triggerConfigurationAttrTypes)
		} else {
			triggerConfigurationMfaValue, diags := types.ObjectValue(triggerConfigurationMfaAttrTypes, map[string]attr.Value{
				"enabled":     types.BoolValue(response.Trigger.Configuration.Mfa.Enabled),
				"time":        types.Float32Value(response.Trigger.Configuration.Mfa.Time),
				"time_format": types.StringValue(response.Trigger.Configuration.Mfa.TimeFormat),
			})
			respDiags.Append(diags...)
			triggerConfigurationPwdValue, diags := types.ObjectValue(triggerConfigurationPwdAttrTypes, map[string]attr.Value{
				"enabled":     types.BoolValue(response.Trigger.Configuration.Pwd.Enabled),
				"time":        types.Float32Value(response.Trigger.Configuration.Pwd.Time),
				"time_format": types.StringValue(response.Trigger.Configuration.Pwd.TimeFormat),
			})
			respDiags.Append(diags...)
			triggerConfigurationValue, diags = types.ObjectValue(triggerConfigurationAttrTypes, map[string]attr.Value{
				"mfa": triggerConfigurationMfaValue,
				"pwd": triggerConfigurationPwdValue,
			})
			respDiags.Append(diags...)
		}
		triggerTypeValue := types.StringValue(string(response.Trigger.Type))
		triggerValue, diags = types.ObjectValue(triggerAttrTypes, map[string]attr.Value{
			"configuration": triggerConfigurationValue,
			"type":          triggerTypeValue,
		})
		respDiags.Append(diags...)
	}
	state.Trigger = triggerValue
	return respDiags
}

func (r *davinciFlowResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var responseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.GetFlowById(ctx, environmentIdUuid, data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"GetFlowById",
		framework.CustomErrorResourceNotFoundWarning,
		framework.InsufficientPrivilegeRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Remove from state if resource is not found
	if responseData == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *davinciFlowResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Update API call logic
	clientData, diags := data.buildClientStructPut()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var responseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.ReplaceFlowById(ctx, environmentIdUuid, data.Id.ValueString()).DaVinciFlowReplaceRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"ReplaceFlowById",
		framework.DefaultCustomError,
		framework.InsufficientPrivilegeRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *davinciFlowResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Delete API call logic
	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fR, fErr := r.Client.DaVinciFlowsApi.DeleteFlowById(ctx, environmentIdUuid, data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), nil, fR, fErr)
		},
		"DeleteFlowById",
		framework.CustomErrorResourceNotFoundWarning,
		framework.InsufficientPrivilegeRetryable,
		nil,
	)...)
}

func (r *davinciFlowResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	idComponents := []framework.ImportComponent{
		{
			Label:  "environment_id",
			Regexp: verify.P1ResourceIDRegexp,
		},
		{
			Label:     "flow_id",
			Regexp:    verify.P1DVResourceIDRegexp,
			PrimaryID: true,
		},
	}

	attributes, err := framework.ParseImportID(req.ID, idComponents...)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			err.Error(),
		)
		return
	}

	for _, idComponent := range idComponents {
		pathKey := idComponent.Label

		if idComponent.PrimaryID {
			pathKey = "id"
		}

		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root(pathKey), attributes[idComponent.Label])...)
	}
}
