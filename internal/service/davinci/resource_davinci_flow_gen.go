// Copyright Â© 2025 Ping Identity Corporation
// Code generated by ping-terraform-plugin-framework-generator

package davinci

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/int32validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int32default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/pingidentity/pingone-go-client/pingone"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework"
	"github.com/pingidentity/terraform-provider-pingone/internal/verify"
)

var (
	_ resource.Resource                = &davinciFlowResource{}
	_ resource.ResourceWithConfigure   = &davinciFlowResource{}
	_ resource.ResourceWithImportState = &davinciFlowResource{}
)

func NewDavinciFlowResource() resource.Resource {
	return &davinciFlowResource{}
}

type davinciFlowResource serviceClientType

func (r *davinciFlowResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_davinci_flow"
}

func (r *davinciFlowResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	resourceConfig, ok := req.ProviderData.(framework.ResourceType)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected the provider client, got: %T. Please report this issue to the provider maintainers.", req.ProviderData),
		)

		return
	}

	r.Client = resourceConfig.Client
	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialised",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.",
		)
		return
	}
}

type davinciFlowResourceModel struct {
	Color          types.String  `tfsdk:"color"`
	Connectors     types.Set     `tfsdk:"connectors"`
	CurrentVersion types.Float32 `tfsdk:"current_version"`
	// DeployedAt     types.String  `tfsdk:"deployed_at"`
	Description types.String `tfsdk:"description"`
	// DvlinterErrorCount   types.Float32 `tfsdk:"dvlinter_error_count"`
	// DvlinterWarningCount types.Float32 `tfsdk:"dvlinter_warning_count"`
	Enabled       types.Bool   `tfsdk:"enabled"`
	EnvironmentId types.String `tfsdk:"environment_id"`
	GraphData     types.Object `tfsdk:"graph_data"`
	Id            types.String `tfsdk:"id"`
	InputSchema   types.List   `tfsdk:"input_schema"`
	Name          types.String `tfsdk:"name"`
	OutputSchema  types.Object `tfsdk:"output_schema"`
	// PublishedVersion types.Float32 `tfsdk:"published_version"`
	Settings types.Object `tfsdk:"settings"`
	Trigger  types.Object `tfsdk:"trigger"`
}

func (r *davinciFlowResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	graphDataElementsEdgesDataAttrTypes := map[string]attr.Type{
		"id":     types.StringType,
		"source": types.StringType,
		"target": types.StringType,
	}
	graphDataElementsEdgesPositionAttrTypes := map[string]attr.Type{
		"x": types.Float32Type,
		"y": types.Float32Type,
	}
	graphDataElementsEdgesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsEdgesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsEdgesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsEdgesElementType := types.ObjectType{AttrTypes: graphDataElementsEdgesAttrTypes}
	settingsJsLinksAttrTypes := map[string]attr.Type{
		"crossorigin":    types.StringType,
		"defer":          types.BoolType,
		"integrity":      types.StringType,
		"label":          types.StringType,
		"referrerpolicy": types.StringType,
		"type":           types.StringType,
		"value":          types.StringType,
	}
	settingsJsLinksElementType := types.ObjectType{AttrTypes: settingsJsLinksAttrTypes}
	settingsAttrTypes := map[string]attr.Type{
		"csp":                                types.StringType,
		"css":                                types.StringType,
		"css_links":                          types.SetType{ElemType: types.StringType},
		"custom_error_screen_brand_logo_url": types.StringType,
		"custom_error_show_footer":           types.BoolType,
		"custom_favicon_link":                types.StringType,
		"custom_logo_urlselection":           types.Int32Type,
		"custom_title":                       types.StringType,
		"default_error_screen_brand_logo":    types.BoolType,
		"flow_http_timeout_in_seconds":       types.Int32Type,
		"flow_timeout_in_seconds":            types.Int32Type,
		"intermediate_loading_screen_css":    types.StringType,
		"intermediate_loading_screen_html":   types.StringType,
		"js_custom_flow_player":              types.StringType,
		"js_links":                           types.SetType{ElemType: settingsJsLinksElementType},
		"log_level":                          types.Int32Type,
		"require_authentication_to_initiate": types.BoolType,
		"scrub_sensitive_info":               types.BoolType,
		"sensitive_info_fields":              types.SetType{ElemType: types.StringType},
		"use_csp":                            types.BoolType,
		"use_custom_css":                     types.BoolType,
		"use_custom_flow_player":             types.BoolType,
		"use_custom_script":                  types.BoolType,
		"use_intermediate_loading_screen":    types.BoolType,
		"validate_on_save":                   types.BoolType,
	}
	resp.Schema = schema.Schema{
		Description: "Resource to create and manage a davinci flow.",
		Attributes: map[string]schema.Attribute{
			"color": schema.StringAttribute{
				Optional: true,
			},
			"connectors": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Computed: true,
			},
			"current_version": schema.Float32Attribute{
				Computed: true,
			},
			// "deployed_at": schema.StringAttribute{
			// 	Computed: true,
			// },
			"description": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1024),
					stringvalidator.LengthAtLeast(1),
					// stringvalidator.RegexMatches(regexp.MustCompile("^\\s*[\\p{L}\\p{M}\\p{N}\\p{So}/.'_ -]*(?!.*((<)|(\\$\\{)))"), ""),
					// stringvalidator.RegexMatches(regexp.MustCompile("^\\s*[\\p{L}\\p{M}\\p{N}\\p{So}/.'_ -]?(?!.*((<)|(\\$\\{)))"), ""),
				},
			},
			// "dvlinter_error_count": schema.Float32Attribute{
			// 	Computed: true,
			// },
			// "dvlinter_warning_count": schema.Float32Attribute{
			// 	Computed: true,
			// },
			"enabled": schema.BoolAttribute{
				Computed: true,
			},
			"environment_id": schema.StringAttribute{
				Required:    true,
				Description: "The ID of the environment to create and manage the flow in. Must be a valid PingOne resource ID. This field is immutable and will trigger a replace plan if changed.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"), "Must be a valid UUID"),
				},
			},
			"graph_data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					// "all_linter_errors": schema.SetNestedAttribute{
					// 	NestedObject: schema.NestedAttributeObject{
					// 		Attributes: map[string]schema.Attribute{
					// 			"code": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 			"flow_id": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 			"message": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 			"node_id": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 			"recommendation": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 			"type": schema.StringAttribute{
					// 				Computed: true,
					// 			},
					// 		},
					// 	},
					// 	Computed: true,
					// },
					"box_selection_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"data": schema.StringAttribute{
						CustomType: jsontypes.NormalizedType{},
						Optional:   true,
					},
					"elements": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"edges": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"classes": schema.StringAttribute{
											Optional: true,
										},
										"data": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"source": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"target": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
											},
											Required: true,
										},
										"grabbable": schema.BoolAttribute{
											Optional: true,
										},
										"group": schema.StringAttribute{
											Optional: true,
										},
										"locked": schema.BoolAttribute{
											Optional: true,
										},
										"pannable": schema.BoolAttribute{
											Optional: true,
										},
										"position": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"x": schema.Float32Attribute{
													Required: true,
												},
												"y": schema.Float32Attribute{
													Required: true,
												},
											},
											Optional: true,
										},
										"removed": schema.BoolAttribute{
											Optional: true,
										},
										"selectable": schema.BoolAttribute{
											Optional: true,
										},
										"selected": schema.BoolAttribute{
											Optional: true,
										},
									},
								},
								Optional: true,
								Computed: true,
								Default:  setdefault.StaticValue(types.SetValueMust(graphDataElementsEdgesElementType, nil)),
							},
							"nodes": schema.SetNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"classes": schema.StringAttribute{
											Optional: true,
										},
										"data": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"capability_name": schema.StringAttribute{
													Optional: true,
												},
												"connection_id": schema.StringAttribute{
													Computed: true,
												},
												"connector_id": schema.StringAttribute{
													Optional: true,
												},
												"id": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												// "id_unique": schema.StringAttribute{
												// 	Computed: true,
												// },
												"label": schema.StringAttribute{
													Optional: true,
												},
												// "linter_error": schema.SetNestedAttribute{
												// 	NestedObject: schema.NestedAttributeObject{
												// 		Attributes: map[string]schema.Attribute{
												// 			"code": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 			"flow_id": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 			"message": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 			"node_id": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 			"recommendation": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 			"type": schema.StringAttribute{
												// 				Computed: true,
												// 			},
												// 		},
												// 	},
												// 	Computed: true,
												// },
												"name": schema.StringAttribute{
													Computed: true,
												},
												"node_type": schema.StringAttribute{
													Required: true,
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(1),
													},
												},
												"properties": schema.StringAttribute{
													CustomType: jsontypes.NormalizedType{},
													Optional:   true,
												},
												"status": schema.StringAttribute{
													Optional: true,
												},
												"type": schema.StringAttribute{
													Optional: true,
												},
											},
											Required: true,
										},
										"grabbable": schema.BoolAttribute{
											Optional: true,
										},
										"group": schema.StringAttribute{
											Optional: true,
										},
										"locked": schema.BoolAttribute{
											Optional: true,
										},
										"pannable": schema.BoolAttribute{
											Optional: true,
										},
										"position": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"x": schema.Float32Attribute{
													Required: true,
												},
												"y": schema.Float32Attribute{
													Required: true,
												},
											},
											Optional: true,
										},
										"removed": schema.BoolAttribute{
											Optional: true,
										},
										"selectable": schema.BoolAttribute{
											Optional: true,
										},
										"selected": schema.BoolAttribute{
											Optional: true,
										},
									},
								},
								Optional: true,
							},
						},
						Optional: true,
					},
					"max_zoom": schema.NumberAttribute{
						Optional: true,
					},
					"min_zoom": schema.NumberAttribute{
						Optional: true,
					},
					"pan": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"x": schema.Float32Attribute{
								Required: true,
							},
							"y": schema.Float32Attribute{
								Required: true,
							},
						},
						Optional: true,
					},
					"panning_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"renderer": schema.StringAttribute{
						CustomType: jsontypes.NormalizedType{},
						Optional:   true,
					},
					"user_panning_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"user_zooming_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"zoom": schema.Int32Attribute{
						Optional: true,
					},
					"zooming_enabled": schema.BoolAttribute{
						Optional: true,
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: "The ID of this resource.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					// stringvalidator.RegexMatches(regexp.MustCompile("^(?=\\S)[\\p{L}\\p{M}\\p{N}\\p{So}/.'_ -]*(?!.*((<)|(\\$\\{)))"), ""),
					stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"), "Must be a valid UUID"),
				},
			},
			"input_schema": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Optional: true,
							Computed: true,
						},
						"is_expanded": schema.BoolAttribute{
							Optional: true,
							Computed: true,
						},
						"preferred_control_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Options are \"button\", \"colorPicker\", \"contentEditableTextArea\", \"cssArea\", \"dropDown\", \"dropDownMultiSelect\", \"dropDownMultiSelect2\", \"dropDownWithCreate\", \"functionArgumentList\", \"keyValueList\", \"label\", \"radioSelect\", \"textArea\", \"textField\", \"textFieldArrayView\", \"toggleSwitch\".",
							MarkdownDescription: "Options are `button`, `colorPicker`, `contentEditableTextArea`, `cssArea`, `dropDown`, `dropDownMultiSelect`, `dropDownMultiSelect2`, `dropDownWithCreate`, `functionArgumentList`, `keyValueList`, `label`, `radioSelect`, `textArea`, `textField`, `textFieldArrayView`, `toggleSwitch`.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"button",
									"colorPicker",
									"contentEditableTextArea",
									"cssArea",
									"dropDown",
									"dropDownMultiSelect",
									"dropDownMultiSelect2",
									"dropDownWithCreate",
									"functionArgumentList",
									"keyValueList",
									"label",
									"radioSelect",
									"textArea",
									"textField",
									"textFieldArrayView",
									"toggleSwitch",
								),
							},
						},
						"preferred_data_type": schema.StringAttribute{
							//Required: true,
							Optional: true,
							Computed: true,
							//TODO validator to simulate being required
							Description:         "Options are \"array\", \"boolean\", \"number\", \"object\", \"string\".",
							MarkdownDescription: "Options are `array`, `boolean`, `number`, `object`, `string`.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"array",
									"boolean",
									"number",
									"object",
									"string",
								),
								stringvalidator.LengthAtLeast(1),
							},
						},
						"property_name": schema.StringAttribute{
							//Required: true,
							Optional: true,
							Computed: true,
							//TODO validator to simulate being required
							Validators: []validator.String{
								stringvalidator.LengthAtLeast(1),
							},
						},
						"required": schema.BoolAttribute{
							Optional: true,
							Computed: true,
						},
					},
				},
				Optional: true,
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 256),
					// stringvalidator.RegexMatches(regexp.MustCompile("^\\s*([\\p{L}\\p{M}\\p{N}\\p{So}/.'_-]).?(?!.*((<)|(\\$\\{)))"), ""),
				},
			},
			"output_schema": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"output": schema.StringAttribute{
						CustomType: jsontypes.NormalizedType{},
						Optional:   true,
					},
				},
				Optional: true,
			},
			// "published_version": schema.Float32Attribute{
			// 	Computed: true,
			// },
			"settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"csp": schema.StringAttribute{
						Optional: true,
					},
					"css": schema.StringAttribute{
						Optional: true,
					},
					"css_links": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"custom_error_screen_brand_logo_url": schema.StringAttribute{
						Optional: true,
					},
					"custom_error_show_footer": schema.BoolAttribute{
						Optional: true,
					},
					"custom_favicon_link": schema.StringAttribute{
						Optional: true,
					},
					"custom_logo_urlselection": schema.Int32Attribute{
						Optional: true,
					},
					"custom_title": schema.StringAttribute{
						Optional: true,
					},
					"default_error_screen_brand_logo": schema.BoolAttribute{
						Optional: true,
					},
					"flow_http_timeout_in_seconds": schema.Int32Attribute{
						Optional: true,
					},
					"flow_timeout_in_seconds": schema.Int32Attribute{
						Optional: true,
					},
					"intermediate_loading_screen_css": schema.StringAttribute{
						Optional: true,
					},
					"intermediate_loading_screen_html": schema.StringAttribute{
						Optional: true,
					},
					"js_custom_flow_player": schema.StringAttribute{
						Optional: true,
					},
					"js_links": schema.SetNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"crossorigin": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"defer": schema.BoolAttribute{
									Required: true,
								},
								"integrity": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"label": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"referrerpolicy": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"type": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
								"value": schema.StringAttribute{
									Required: true,
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(1),
									},
								},
							},
						},
						Optional: true,
					},
					"log_level": schema.Int32Attribute{
						Optional: true,
						Computed: true,
						Default:  int32default.StaticInt32(4),
						Validators: []validator.Int32{
							int32validator.Between(1, 4),
						},
					},
					"require_authentication_to_initiate": schema.BoolAttribute{
						Optional: true,
					},
					"scrub_sensitive_info": schema.BoolAttribute{
						Optional: true,
					},
					"sensitive_info_fields": schema.SetAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"use_csp": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_css": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_flow_player": schema.BoolAttribute{
						Optional: true,
					},
					"use_custom_script": schema.BoolAttribute{
						Optional: true,
					},
					"use_intermediate_loading_screen": schema.BoolAttribute{
						Optional: true,
					},
					"validate_on_save": schema.BoolAttribute{
						Optional: true,
					},
				},
				Optional: true,
				Computed: true,
				Default: objectdefault.StaticValue(types.ObjectValueMust(settingsAttrTypes, map[string]attr.Value{
					"csp":                                types.StringNull(),
					"css":                                types.StringNull(),
					"css_links":                          types.SetNull(types.StringType),
					"custom_error_screen_brand_logo_url": types.StringNull(),
					"custom_error_show_footer":           types.BoolNull(),
					"custom_favicon_link":                types.StringNull(),
					"custom_logo_urlselection":           types.Int32Null(),
					"custom_title":                       types.StringNull(),
					"default_error_screen_brand_logo":    types.BoolNull(),
					"flow_http_timeout_in_seconds":       types.Int32Null(),
					"flow_timeout_in_seconds":            types.Int32Null(),
					"intermediate_loading_screen_css":    types.StringNull(),
					"intermediate_loading_screen_html":   types.StringNull(),
					"js_custom_flow_player":              types.StringNull(),
					"js_links":                           types.SetNull(settingsJsLinksElementType),
					"log_level":                          types.Int32Value(4),
					"require_authentication_to_initiate": types.BoolNull(),
					"scrub_sensitive_info":               types.BoolNull(),
					"sensitive_info_fields":              types.SetNull(types.StringType),
					"use_csp":                            types.BoolNull(),
					"use_custom_css":                     types.BoolNull(),
					"use_custom_flow_player":             types.BoolNull(),
					"use_custom_script":                  types.BoolNull(),
					"use_intermediate_loading_screen":    types.BoolNull(),
					"validate_on_save":                   types.BoolNull(),
				})),
			},
			"trigger": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"configuration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"mfa": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Computed: true,
									},
									"time": schema.Float32Attribute{
										Computed: true,
									},
									"time_format": schema.StringAttribute{
										Computed: true,
									},
								},
								Computed: true,
							},
							"pwd": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Computed: true,
									},
									"time": schema.Float32Attribute{
										Computed: true,
									},
									"time_format": schema.StringAttribute{
										Computed: true,
									},
								},
								Computed: true,
							},
						},
						Optional: true,
					},
					"type": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AUTHENTICATION",
							),
							stringvalidator.LengthAtLeast(1),
						},
					},
				},
				Optional: true,
			},
		},
	}
}

func (model *davinciFlowResourceModel) buildClientStructPost() (*pingone.DaVinciFlowCreateRequest, diag.Diagnostics) {
	result := &pingone.DaVinciFlowCreateRequest{}
	var respDiags diag.Diagnostics
	// color
	if !model.Color.IsNull() && !model.Color.IsUnknown() {
		result.Color = model.Color.ValueStringPointer()
	}
	// description
	if !model.Description.IsNull() && !model.Description.IsUnknown() {
		result.Description = model.Description.ValueStringPointer()
	}
	// graph_data
	if !model.GraphData.IsNull() && !model.GraphData.IsUnknown() {
		graphDataValue := &pingone.DaVinciFlowGraphDataRequest{}
		graphDataAttrs := model.GraphData.Attributes()
		graphDataValue.BoxSelectionEnabled = graphDataAttrs["box_selection_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["data"].IsNull() && !graphDataAttrs["data"].IsUnknown() {
			var unmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["data"].(jsontypes.Normalized).ValueString()), &unmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for data could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Data = unmarshaled
		}
		// graphDataValue.Data = graphDataAttrs["data"].(types.String).ValueStringPointer()
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsValue := &pingone.DaVinciFlowGraphDataRequestElements{}
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			if !graphDataElementsAttrs["edges"].IsNull() && !graphDataElementsAttrs["edges"].IsUnknown() {
				graphDataElementsValue.Edges = []pingone.DaVinciFlowGraphDataRequestElementsEdge{}
				for _, edgesElement := range graphDataElementsAttrs["edges"].(types.Set).Elements() {
					edgesValue := pingone.DaVinciFlowGraphDataRequestElementsEdge{}
					edgesAttrs := edgesElement.(types.Object).Attributes()
					edgesValue.Classes = edgesAttrs["classes"].(types.String).ValueStringPointer()
					edgesDataValue := pingone.DaVinciFlowGraphDataRequestElementsEdgeData{}
					edgesDataAttrs := edgesAttrs["data"].(types.Object).Attributes()
					edgesDataValue.Id = edgesDataAttrs["id"].(types.String).ValueString()
					edgesDataValue.Source = edgesDataAttrs["source"].(types.String).ValueString()
					edgesDataValue.Target = edgesDataAttrs["target"].(types.String).ValueString()
					edgesValue.Data = edgesDataValue
					edgesValue.Grabbable = edgesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					edgesValue.Group = edgesAttrs["group"].(types.String).ValueStringPointer()
					edgesValue.Locked = edgesAttrs["locked"].(types.Bool).ValueBoolPointer()
					edgesValue.Pannable = edgesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !edgesAttrs["position"].IsNull() && !edgesAttrs["position"].IsUnknown() {
						edgesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsEdgePosition{}
						edgesPositionAttrs := edgesAttrs["position"].(types.Object).Attributes()
						edgesPositionValue.X = edgesPositionAttrs["x"].(types.Float32).ValueFloat32()
						edgesPositionValue.Y = edgesPositionAttrs["y"].(types.Float32).ValueFloat32()
						edgesValue.Position = edgesPositionValue
					}
					edgesValue.Removed = edgesAttrs["removed"].(types.Bool).ValueBoolPointer()
					edgesValue.Selectable = edgesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					edgesValue.Selected = edgesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Edges = append(graphDataElementsValue.Edges, edgesValue)
				}
			}
			if !graphDataElementsAttrs["nodes"].IsNull() && !graphDataElementsAttrs["nodes"].IsUnknown() {
				graphDataElementsValue.Nodes = []pingone.DaVinciFlowGraphDataRequestElementsNode{}
				for _, nodesElement := range graphDataElementsAttrs["nodes"].(types.Set).Elements() {
					nodesValue := pingone.DaVinciFlowGraphDataRequestElementsNode{}
					nodesAttrs := nodesElement.(types.Object).Attributes()
					nodesValue.Classes = nodesAttrs["classes"].(types.String).ValueStringPointer()
					nodesDataValue := pingone.DaVinciFlowGraphDataRequestElementsNodeData{}
					nodesDataAttrs := nodesAttrs["data"].(types.Object).Attributes()
					nodesDataValue.CapabilityName = nodesDataAttrs["capability_name"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectorId = nodesDataAttrs["connector_id"].(types.String).ValueStringPointer()
					nodesDataValue.Id = nodesDataAttrs["id"].(types.String).ValueString()
					nodesDataValue.Label = nodesDataAttrs["label"].(types.String).ValueStringPointer()
					nodesDataValue.NodeType = nodesDataAttrs["node_type"].(types.String).ValueString()
					if !nodesDataAttrs["properties"].IsNull() && !nodesDataAttrs["properties"].IsUnknown() {
						var unmarshaled map[string]interface{}
						err := json.Unmarshal([]byte(nodesDataAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
						if err != nil {
							respDiags.AddError(
								"Error Parsing JSON val",
								fmt.Sprintf("The value provided for properties could not be parsed as json: %s", err.Error()),
							)
						}
						nodesDataValue.Properties = unmarshaled
					}
					// nodesDataValue.Properties = nodesDataAttrs["properties"].(types.String).ValueStringPointer()
					nodesDataValue.Status = nodesDataAttrs["status"].(types.String).ValueStringPointer()
					nodesDataValue.Type = nodesDataAttrs["type"].(types.String).ValueStringPointer()
					nodesValue.Data = nodesDataValue
					nodesValue.Grabbable = nodesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					nodesValue.Group = nodesAttrs["group"].(types.String).ValueStringPointer()
					nodesValue.Locked = nodesAttrs["locked"].(types.Bool).ValueBoolPointer()
					nodesValue.Pannable = nodesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !nodesAttrs["position"].IsNull() && !nodesAttrs["position"].IsUnknown() {
						nodesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsNodePosition{}
						nodesPositionAttrs := nodesAttrs["position"].(types.Object).Attributes()
						nodesPositionValue.X = nodesPositionAttrs["x"].(types.Float32).ValueFloat32()
						nodesPositionValue.Y = nodesPositionAttrs["y"].(types.Float32).ValueFloat32()
						nodesValue.Position = nodesPositionValue
					}
					nodesValue.Removed = nodesAttrs["removed"].(types.Bool).ValueBoolPointer()
					nodesValue.Selectable = nodesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					nodesValue.Selected = nodesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Nodes = append(graphDataElementsValue.Nodes, nodesValue)
				}
			}
			graphDataValue.Elements = graphDataElementsValue
		}
		if !graphDataAttrs["max_zoom"].IsNull() && !graphDataAttrs["max_zoom"].IsUnknown() {
			graphDataValue.MaxZoom = &pingone.BigFloat{
				Float: graphDataAttrs["max_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["min_zoom"].IsNull() && !graphDataAttrs["min_zoom"].IsUnknown() {
			graphDataValue.MinZoom = &pingone.BigFloat{
				Float: graphDataAttrs["min_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["pan"].IsNull() && !graphDataAttrs["pan"].IsUnknown() {
			graphDataPanValue := &pingone.DaVinciFlowGraphDataRequestPan{}
			graphDataPanAttrs := graphDataAttrs["pan"].(types.Object).Attributes()
			graphDataPanValue.X = graphDataPanAttrs["x"].(types.Float32).ValueFloat32()
			graphDataPanValue.Y = graphDataPanAttrs["y"].(types.Float32).ValueFloat32()
			graphDataValue.Pan = graphDataPanValue
		}
		graphDataValue.PanningEnabled = graphDataAttrs["panning_enabled"].(types.Bool).ValueBoolPointer()
		if !graphDataAttrs["renderer"].IsNull() && !graphDataAttrs["renderer"].IsUnknown() {
			var newUnmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(graphDataAttrs["renderer"].(jsontypes.Normalized).ValueString()), &newUnmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for renderer could not be parsed as json: %s", err.Error()),
				)
			}
			graphDataValue.Renderer = newUnmarshaled
		}
		// graphDataValue.Renderer = graphDataAttrs["renderer"].(types.String).ValueStringPointer()
		graphDataValue.UserPanningEnabled = graphDataAttrs["user_panning_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.UserZoomingEnabled = graphDataAttrs["user_zooming_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.Zoom = graphDataAttrs["zoom"].(types.Int32).ValueInt32Pointer()
		graphDataValue.ZoomingEnabled = graphDataAttrs["zooming_enabled"].(types.Bool).ValueBoolPointer()
		result.GraphData = graphDataValue
	}

	// input_schema
	if !model.InputSchema.IsNull() && !model.InputSchema.IsUnknown() {
		result.InputSchema = []pingone.DaVinciFlowInputSchemaRequestItem{}
		for _, inputSchemaElement := range model.InputSchema.Elements() {
			inputSchemaValue := pingone.DaVinciFlowInputSchemaRequestItem{}
			inputSchemaAttrs := inputSchemaElement.(types.Object).Attributes()
			inputSchemaValue.Description = inputSchemaAttrs["description"].(types.String).ValueStringPointer()
			inputSchemaValue.IsExpanded = inputSchemaAttrs["is_expanded"].(types.Bool).ValueBoolPointer()
			if !inputSchemaAttrs["preferred_control_type"].IsNull() && !inputSchemaAttrs["preferred_control_type"].IsUnknown() {
				inputSchemaPreferredControlTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredControlTypeFromValue(inputSchemaAttrs["preferred_control_type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("preferred_control_type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for preferred_control_type is not valid: %s", err.Error()),
					)
				} else {
					inputSchemaValue.PreferredControlType = inputSchemaPreferredControlTypeValue
				}
			}
			inputSchemaPreferredDataTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredDataTypeFromValue(inputSchemaAttrs["preferred_data_type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("preferred_data_type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for preferred_data_type is not valid: %s", err.Error()),
				)
			} else {
				inputSchemaValue.PreferredDataType = *inputSchemaPreferredDataTypeValue
			}
			inputSchemaValue.PropertyName = inputSchemaAttrs["property_name"].(types.String).ValueString()
			inputSchemaValue.Required = inputSchemaAttrs["required"].(types.Bool).ValueBoolPointer()
			result.InputSchema = append(result.InputSchema, inputSchemaValue)
		}
	}

	// name
	result.Name = model.Name.ValueString()
	// output_schema
	if !model.OutputSchema.IsNull() && !model.OutputSchema.IsUnknown() {
		outputSchemaValue := &pingone.DaVinciFlowCreateRequestOutputSchema{}
		outputSchemaAttrs := model.OutputSchema.Attributes()
		if !outputSchemaAttrs["output"].IsNull() && !outputSchemaAttrs["output"].IsUnknown() {
			var unmarshaled map[string]interface{}
			err := json.Unmarshal([]byte(outputSchemaAttrs["output"].(jsontypes.Normalized).ValueString()), &unmarshaled)
			if err != nil {
				respDiags.AddError(
					"Error Parsing JSON val",
					fmt.Sprintf("The value provided for output could not be parsed as json: %s", err.Error()),
				)
			}
			outputSchemaValue.Output = unmarshaled
		}
		// outputSchemaValue.Output = outputSchemaAttrs["output"].(types.String).ValueStringPointer()
		result.OutputSchema = outputSchemaValue
	}

	// settings
	if !model.Settings.IsNull() && !model.Settings.IsUnknown() {
		settingsValue := &pingone.DaVinciFlowSettingsRequest{}
		settingsAttrs := model.Settings.Attributes()
		settingsValue.Csp = settingsAttrs["csp"].(types.String).ValueStringPointer()
		settingsValue.Css = settingsAttrs["css"].(types.String).ValueStringPointer()
		if !settingsAttrs["css_links"].IsNull() && !settingsAttrs["css_links"].IsUnknown() {
			settingsValue.CssLinks = []string{}
			for _, cssLinksElement := range settingsAttrs["css_links"].(types.Set).Elements() {
				settingsValue.CssLinks = append(settingsValue.CssLinks, cssLinksElement.(types.String).ValueString())
			}
		}
		settingsValue.CustomErrorScreenBrandLogoUrl = settingsAttrs["custom_error_screen_brand_logo_url"].(types.String).ValueStringPointer()
		settingsValue.CustomErrorShowFooter = settingsAttrs["custom_error_show_footer"].(types.Bool).ValueBoolPointer()
		settingsValue.CustomFaviconLink = settingsAttrs["custom_favicon_link"].(types.String).ValueStringPointer()
		settingsValue.CustomLogoURLSelection = settingsAttrs["custom_logo_urlselection"].(types.Int32).ValueInt32Pointer()
		settingsValue.CustomTitle = settingsAttrs["custom_title"].(types.String).ValueStringPointer()
		settingsValue.DefaultErrorScreenBrandLogo = settingsAttrs["default_error_screen_brand_logo"].(types.Bool).ValueBoolPointer()
		settingsValue.FlowHttpTimeoutInSeconds = settingsAttrs["flow_http_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.FlowTimeoutInSeconds = settingsAttrs["flow_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.IntermediateLoadingScreenCSS = settingsAttrs["intermediate_loading_screen_css"].(types.String).ValueStringPointer()
		settingsValue.IntermediateLoadingScreenHTML = settingsAttrs["intermediate_loading_screen_html"].(types.String).ValueStringPointer()
		settingsValue.JsCustomFlowPlayer = settingsAttrs["js_custom_flow_player"].(types.String).ValueStringPointer()
		if !settingsAttrs["js_links"].IsNull() && !settingsAttrs["js_links"].IsUnknown() {
			settingsValue.JsLinks = []pingone.DaVinciFlowSettingsRequestJsLink{}
			for _, jsLinksElement := range settingsAttrs["js_links"].(types.Set).Elements() {
				jsLinksValue := pingone.DaVinciFlowSettingsRequestJsLink{}
				jsLinksAttrs := jsLinksElement.(types.Object).Attributes()
				jsLinksValue.Crossorigin = jsLinksAttrs["crossorigin"].(types.String).ValueString()
				jsLinksValue.Defer = jsLinksAttrs["defer"].(types.Bool).ValueBool()
				jsLinksValue.Integrity = jsLinksAttrs["integrity"].(types.String).ValueString()
				jsLinksValue.Label = jsLinksAttrs["label"].(types.String).ValueString()
				jsLinksValue.Referrerpolicy = jsLinksAttrs["referrerpolicy"].(types.String).ValueString()
				jsLinksValue.Type = jsLinksAttrs["type"].(types.String).ValueString()
				jsLinksValue.Value = jsLinksAttrs["value"].(types.String).ValueString()
				settingsValue.JsLinks = append(settingsValue.JsLinks, jsLinksValue)
			}
		}
		settingsValue.LogLevel = settingsAttrs["log_level"].(types.Int32).ValueInt32Pointer()
		settingsValue.RequireAuthenticationToInitiate = settingsAttrs["require_authentication_to_initiate"].(types.Bool).ValueBoolPointer()
		settingsValue.ScrubSensitiveInfo = settingsAttrs["scrub_sensitive_info"].(types.Bool).ValueBoolPointer()
		if !settingsAttrs["sensitive_info_fields"].IsNull() && !settingsAttrs["sensitive_info_fields"].IsUnknown() {
			settingsValue.SensitiveInfoFields = []string{}
			for _, sensitiveInfoFieldsElement := range settingsAttrs["sensitive_info_fields"].(types.Set).Elements() {
				settingsValue.SensitiveInfoFields = append(settingsValue.SensitiveInfoFields, sensitiveInfoFieldsElement.(types.String).ValueString())
			}
		}
		settingsValue.UseCSP = settingsAttrs["use_csp"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomCSS = settingsAttrs["use_custom_css"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomFlowPlayer = settingsAttrs["use_custom_flow_player"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomScript = settingsAttrs["use_custom_script"].(types.Bool).ValueBoolPointer()
		settingsValue.UseIntermediateLoadingScreen = settingsAttrs["use_intermediate_loading_screen"].(types.Bool).ValueBoolPointer()
		settingsValue.ValidateOnSave = settingsAttrs["validate_on_save"].(types.Bool).ValueBoolPointer()
		result.Settings = settingsValue
	}

	// trigger
	if !model.Trigger.IsNull() && !model.Trigger.IsUnknown() {
		triggerValue := &pingone.DaVinciFlowCreateRequestTrigger{}
		triggerAttrs := model.Trigger.Attributes()
		triggerTypeValue, err := pingone.NewDaVinciFlowCreateRequestTriggerTypeFromValue(triggerAttrs["type"].(types.String).ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			triggerValue.Type = *triggerTypeValue
		}
		result.Trigger = triggerValue
	}

	return result, respDiags
}

func (model *davinciFlowResourceModel) buildClientStructPut() (*pingone.DaVinciFlowReplaceRequest, diag.Diagnostics) {
	result := &pingone.DaVinciFlowReplaceRequest{}
	var respDiags diag.Diagnostics
	// color
	if !model.Color.IsNull() && !model.Color.IsUnknown() {
		result.Color = model.Color.ValueStringPointer()
	}
	// description
	if !model.Description.IsNull() && !model.Description.IsUnknown() {
		result.Description = model.Description.ValueStringPointer()
	}
	// graph_data
	if !model.GraphData.IsNull() && !model.GraphData.IsUnknown() {
		graphDataValue := &pingone.DaVinciFlowGraphDataRequest{}
		graphDataAttrs := model.GraphData.Attributes()
		graphDataValue.BoxSelectionEnabled = graphDataAttrs["box_selection_enabled"].(types.Bool).ValueBoolPointer()
		var unmarshaled map[string]interface{}
		err := json.Unmarshal([]byte(graphDataAttrs["data"].(jsontypes.Normalized).ValueString()), &unmarshaled)
		if err != nil {
			respDiags.AddError(
				"Error Parsing JSON val",
				fmt.Sprintf("The value provided for data could not be parsed as json: %s", err.Error()),
			)
		}
		graphDataValue.Data = unmarshaled
		// graphDataValue.Data = graphDataAttrs["data"].(types.String).ValueStringPointer()
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsValue := &pingone.DaVinciFlowGraphDataRequestElements{}
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			if !graphDataElementsAttrs["edges"].IsNull() && !graphDataElementsAttrs["edges"].IsUnknown() {
				graphDataElementsValue.Edges = []pingone.DaVinciFlowGraphDataRequestElementsEdge{}
				for _, edgesElement := range graphDataElementsAttrs["edges"].(types.Set).Elements() {
					edgesValue := pingone.DaVinciFlowGraphDataRequestElementsEdge{}
					edgesAttrs := edgesElement.(types.Object).Attributes()
					edgesValue.Classes = edgesAttrs["classes"].(types.String).ValueStringPointer()
					edgesDataValue := pingone.DaVinciFlowGraphDataRequestElementsEdgeData{}
					edgesDataAttrs := edgesAttrs["data"].(types.Object).Attributes()
					edgesDataValue.Id = edgesDataAttrs["id"].(types.String).ValueString()
					edgesDataValue.Source = edgesDataAttrs["source"].(types.String).ValueString()
					edgesDataValue.Target = edgesDataAttrs["target"].(types.String).ValueString()
					edgesValue.Data = edgesDataValue
					edgesValue.Grabbable = edgesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					edgesValue.Group = edgesAttrs["group"].(types.String).ValueStringPointer()
					edgesValue.Locked = edgesAttrs["locked"].(types.Bool).ValueBoolPointer()
					edgesValue.Pannable = edgesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !edgesAttrs["position"].IsNull() && !edgesAttrs["position"].IsUnknown() {
						edgesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsEdgePosition{}
						edgesPositionAttrs := edgesAttrs["position"].(types.Object).Attributes()
						edgesPositionValue.X = edgesPositionAttrs["x"].(types.Float32).ValueFloat32()
						edgesPositionValue.Y = edgesPositionAttrs["y"].(types.Float32).ValueFloat32()
						edgesValue.Position = edgesPositionValue
					}
					edgesValue.Removed = edgesAttrs["removed"].(types.Bool).ValueBoolPointer()
					edgesValue.Selectable = edgesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					edgesValue.Selected = edgesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Edges = append(graphDataElementsValue.Edges, edgesValue)
				}
			}
			if !graphDataElementsAttrs["nodes"].IsNull() && !graphDataElementsAttrs["nodes"].IsUnknown() {
				graphDataElementsValue.Nodes = []pingone.DaVinciFlowGraphDataRequestElementsNode{}
				for _, nodesElement := range graphDataElementsAttrs["nodes"].(types.Set).Elements() {
					nodesValue := pingone.DaVinciFlowGraphDataRequestElementsNode{}
					nodesAttrs := nodesElement.(types.Object).Attributes()
					nodesValue.Classes = nodesAttrs["classes"].(types.String).ValueStringPointer()
					nodesDataValue := pingone.DaVinciFlowGraphDataRequestElementsNodeData{}
					nodesDataAttrs := nodesAttrs["data"].(types.Object).Attributes()
					nodesDataValue.CapabilityName = nodesDataAttrs["capability_name"].(types.String).ValueStringPointer()
					nodesDataValue.ConnectorId = nodesDataAttrs["connector_id"].(types.String).ValueStringPointer()
					nodesDataValue.Id = nodesDataAttrs["id"].(types.String).ValueString()
					nodesDataValue.Label = nodesDataAttrs["label"].(types.String).ValueStringPointer()
					nodesDataValue.NodeType = nodesDataAttrs["node_type"].(types.String).ValueString()
					var unmarshaled map[string]interface{}
					err := json.Unmarshal([]byte(nodesDataAttrs["properties"].(jsontypes.Normalized).ValueString()), &unmarshaled)
					if err != nil {
						respDiags.AddError(
							"Error Parsing JSON val",
							fmt.Sprintf("The value provided for properties could not be parsed as json: %s", err.Error()),
						)
					}
					nodesDataValue.Properties = unmarshaled
					// nodesDataValue.Properties = nodesDataAttrs["properties"].(types.String).ValueStringPointer()
					nodesDataValue.Status = nodesDataAttrs["status"].(types.String).ValueStringPointer()
					nodesDataValue.Type = nodesDataAttrs["type"].(types.String).ValueStringPointer()
					nodesValue.Data = nodesDataValue
					nodesValue.Grabbable = nodesAttrs["grabbable"].(types.Bool).ValueBoolPointer()
					nodesValue.Group = nodesAttrs["group"].(types.String).ValueStringPointer()
					nodesValue.Locked = nodesAttrs["locked"].(types.Bool).ValueBoolPointer()
					nodesValue.Pannable = nodesAttrs["pannable"].(types.Bool).ValueBoolPointer()
					if !nodesAttrs["position"].IsNull() && !nodesAttrs["position"].IsUnknown() {
						nodesPositionValue := &pingone.DaVinciFlowGraphDataRequestElementsNodePosition{}
						nodesPositionAttrs := nodesAttrs["position"].(types.Object).Attributes()
						nodesPositionValue.X = nodesPositionAttrs["x"].(types.Float32).ValueFloat32()
						nodesPositionValue.Y = nodesPositionAttrs["y"].(types.Float32).ValueFloat32()
						nodesValue.Position = nodesPositionValue
					}
					nodesValue.Removed = nodesAttrs["removed"].(types.Bool).ValueBoolPointer()
					nodesValue.Selectable = nodesAttrs["selectable"].(types.Bool).ValueBoolPointer()
					nodesValue.Selected = nodesAttrs["selected"].(types.Bool).ValueBoolPointer()
					graphDataElementsValue.Nodes = append(graphDataElementsValue.Nodes, nodesValue)
				}
			}
			graphDataValue.Elements = graphDataElementsValue
		}
		if !graphDataAttrs["max_zoom"].IsNull() && !graphDataAttrs["max_zoom"].IsUnknown() {
			graphDataValue.MaxZoom = &pingone.BigFloat{
				Float: graphDataAttrs["max_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["min_zoom"].IsNull() && !graphDataAttrs["min_zoom"].IsUnknown() {
			graphDataValue.MinZoom = &pingone.BigFloat{
				Float: graphDataAttrs["min_zoom"].(types.Number).ValueBigFloat(),
			}
		}
		if !graphDataAttrs["pan"].IsNull() && !graphDataAttrs["pan"].IsUnknown() {
			graphDataPanValue := &pingone.DaVinciFlowGraphDataRequestPan{}
			graphDataPanAttrs := graphDataAttrs["pan"].(types.Object).Attributes()
			graphDataPanValue.X = graphDataPanAttrs["x"].(types.Float32).ValueFloat32()
			graphDataPanValue.Y = graphDataPanAttrs["y"].(types.Float32).ValueFloat32()
			graphDataValue.Pan = graphDataPanValue
		}
		graphDataValue.PanningEnabled = graphDataAttrs["panning_enabled"].(types.Bool).ValueBoolPointer()
		var newUnmarshaled map[string]interface{}
		err = json.Unmarshal([]byte(graphDataAttrs["renderer"].(jsontypes.Normalized).ValueString()), &newUnmarshaled)
		if err != nil {
			respDiags.AddError(
				"Error Parsing JSON val",
				fmt.Sprintf("The value provided for renderer could not be parsed as json: %s", err.Error()),
			)
		}
		graphDataValue.Renderer = newUnmarshaled
		// graphDataValue.Renderer = graphDataAttrs["renderer"].(types.String).ValueStringPointer()
		graphDataValue.UserPanningEnabled = graphDataAttrs["user_panning_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.UserZoomingEnabled = graphDataAttrs["user_zooming_enabled"].(types.Bool).ValueBoolPointer()
		graphDataValue.Zoom = graphDataAttrs["zoom"].(types.Int32).ValueInt32Pointer()
		graphDataValue.ZoomingEnabled = graphDataAttrs["zooming_enabled"].(types.Bool).ValueBoolPointer()
		result.GraphData = graphDataValue
	}

	// input_schema
	if !model.InputSchema.IsNull() && !model.InputSchema.IsUnknown() {
		result.InputSchema = []pingone.DaVinciFlowInputSchemaRequestItem{}
		for _, inputSchemaElement := range model.InputSchema.Elements() {
			inputSchemaValue := pingone.DaVinciFlowInputSchemaRequestItem{}
			inputSchemaAttrs := inputSchemaElement.(types.Object).Attributes()
			inputSchemaValue.Description = inputSchemaAttrs["description"].(types.String).ValueStringPointer()
			inputSchemaValue.IsExpanded = inputSchemaAttrs["is_expanded"].(types.Bool).ValueBoolPointer()
			if !inputSchemaAttrs["preferred_control_type"].IsNull() && !inputSchemaAttrs["preferred_control_type"].IsUnknown() {
				inputSchemaPreferredControlTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredControlTypeFromValue(inputSchemaAttrs["preferred_control_type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("preferred_control_type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for preferred_control_type is not valid: %s", err.Error()),
					)
				} else {
					inputSchemaValue.PreferredControlType = inputSchemaPreferredControlTypeValue
				}
			}
			inputSchemaPreferredDataTypeValue, err := pingone.NewDaVinciFlowInputSchemaRequestItemPreferredDataTypeFromValue(inputSchemaAttrs["preferred_data_type"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("preferred_data_type"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for preferred_data_type is not valid: %s", err.Error()),
				)
			} else {
				inputSchemaValue.PreferredDataType = *inputSchemaPreferredDataTypeValue
			}
			inputSchemaValue.PropertyName = inputSchemaAttrs["property_name"].(types.String).ValueString()
			inputSchemaValue.Required = inputSchemaAttrs["required"].(types.Bool).ValueBoolPointer()
			result.InputSchema = append(result.InputSchema, inputSchemaValue)
		}
	}

	// name
	result.Name = model.Name.ValueString()
	// output_schema
	if !model.OutputSchema.IsNull() && !model.OutputSchema.IsUnknown() {
		outputSchemaValue := &pingone.DaVinciFlowReplaceRequestOutputSchema{}
		outputSchemaAttrs := model.OutputSchema.Attributes()
		var unmarshaled map[string]interface{}
		err := json.Unmarshal([]byte(outputSchemaAttrs["output"].(jsontypes.Normalized).ValueString()), &unmarshaled)
		if err != nil {
			respDiags.AddError(
				"Error Parsing JSON val",
				fmt.Sprintf("The value provided for output could not be parsed as json: %s", err.Error()),
			)
		}
		outputSchemaValue.Output = unmarshaled
		// outputSchemaValue.Output = outputSchemaAttrs["output"].(types.String).ValueStringPointer()
		result.OutputSchema = outputSchemaValue
	}

	// settings
	if !model.Settings.IsNull() && !model.Settings.IsUnknown() {
		settingsValue := &pingone.DaVinciFlowSettingsRequest{}
		settingsAttrs := model.Settings.Attributes()
		settingsValue.Csp = settingsAttrs["csp"].(types.String).ValueStringPointer()
		settingsValue.Css = settingsAttrs["css"].(types.String).ValueStringPointer()
		if !settingsAttrs["css_links"].IsNull() && !settingsAttrs["css_links"].IsUnknown() {
			settingsValue.CssLinks = []string{}
			for _, cssLinksElement := range settingsAttrs["css_links"].(types.Set).Elements() {
				settingsValue.CssLinks = append(settingsValue.CssLinks, cssLinksElement.(types.String).ValueString())
			}
		}
		settingsValue.CustomErrorScreenBrandLogoUrl = settingsAttrs["custom_error_screen_brand_logo_url"].(types.String).ValueStringPointer()
		settingsValue.CustomErrorShowFooter = settingsAttrs["custom_error_show_footer"].(types.Bool).ValueBoolPointer()
		settingsValue.CustomFaviconLink = settingsAttrs["custom_favicon_link"].(types.String).ValueStringPointer()
		settingsValue.CustomLogoURLSelection = settingsAttrs["custom_logo_urlselection"].(types.Int32).ValueInt32Pointer()
		settingsValue.CustomTitle = settingsAttrs["custom_title"].(types.String).ValueStringPointer()
		settingsValue.DefaultErrorScreenBrandLogo = settingsAttrs["default_error_screen_brand_logo"].(types.Bool).ValueBoolPointer()
		settingsValue.FlowHttpTimeoutInSeconds = settingsAttrs["flow_http_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.FlowTimeoutInSeconds = settingsAttrs["flow_timeout_in_seconds"].(types.Int32).ValueInt32Pointer()
		settingsValue.IntermediateLoadingScreenCSS = settingsAttrs["intermediate_loading_screen_css"].(types.String).ValueStringPointer()
		settingsValue.IntermediateLoadingScreenHTML = settingsAttrs["intermediate_loading_screen_html"].(types.String).ValueStringPointer()
		settingsValue.JsCustomFlowPlayer = settingsAttrs["js_custom_flow_player"].(types.String).ValueStringPointer()
		if !settingsAttrs["js_links"].IsNull() && !settingsAttrs["js_links"].IsUnknown() {
			settingsValue.JsLinks = []pingone.DaVinciFlowSettingsRequestJsLink{}
			for _, jsLinksElement := range settingsAttrs["js_links"].(types.Set).Elements() {
				jsLinksValue := pingone.DaVinciFlowSettingsRequestJsLink{}
				jsLinksAttrs := jsLinksElement.(types.Object).Attributes()
				jsLinksValue.Crossorigin = jsLinksAttrs["crossorigin"].(types.String).ValueString()
				jsLinksValue.Defer = jsLinksAttrs["defer"].(types.Bool).ValueBool()
				jsLinksValue.Integrity = jsLinksAttrs["integrity"].(types.String).ValueString()
				jsLinksValue.Label = jsLinksAttrs["label"].(types.String).ValueString()
				jsLinksValue.Referrerpolicy = jsLinksAttrs["referrerpolicy"].(types.String).ValueString()
				jsLinksValue.Type = jsLinksAttrs["type"].(types.String).ValueString()
				jsLinksValue.Value = jsLinksAttrs["value"].(types.String).ValueString()
				settingsValue.JsLinks = append(settingsValue.JsLinks, jsLinksValue)
			}
		}
		settingsValue.LogLevel = settingsAttrs["log_level"].(types.Int32).ValueInt32Pointer()
		settingsValue.RequireAuthenticationToInitiate = settingsAttrs["require_authentication_to_initiate"].(types.Bool).ValueBoolPointer()
		settingsValue.ScrubSensitiveInfo = settingsAttrs["scrub_sensitive_info"].(types.Bool).ValueBoolPointer()
		if !settingsAttrs["sensitive_info_fields"].IsNull() && !settingsAttrs["sensitive_info_fields"].IsUnknown() {
			settingsValue.SensitiveInfoFields = []string{}
			for _, sensitiveInfoFieldsElement := range settingsAttrs["sensitive_info_fields"].(types.Set).Elements() {
				settingsValue.SensitiveInfoFields = append(settingsValue.SensitiveInfoFields, sensitiveInfoFieldsElement.(types.String).ValueString())
			}
		}
		settingsValue.UseCSP = settingsAttrs["use_csp"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomCSS = settingsAttrs["use_custom_css"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomFlowPlayer = settingsAttrs["use_custom_flow_player"].(types.Bool).ValueBoolPointer()
		settingsValue.UseCustomScript = settingsAttrs["use_custom_script"].(types.Bool).ValueBoolPointer()
		settingsValue.UseIntermediateLoadingScreen = settingsAttrs["use_intermediate_loading_screen"].(types.Bool).ValueBoolPointer()
		settingsValue.ValidateOnSave = settingsAttrs["validate_on_save"].(types.Bool).ValueBoolPointer()
		result.Settings = settingsValue
	}

	// trigger
	if !model.Trigger.IsNull() && !model.Trigger.IsUnknown() {
		triggerValue := &pingone.DaVinciFlowReplaceRequestTrigger{}
		triggerAttrs := model.Trigger.Attributes()
		triggerTypeValue, err := pingone.NewDaVinciFlowReplaceRequestTriggerTypeFromValue(triggerAttrs["type"].(types.String).ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			triggerValue.Type = *triggerTypeValue
		}
		result.Trigger = triggerValue
	}

	return result, respDiags
}

func (state *davinciFlowResourceModel) readClientResponse(response *pingone.DaVinciFlowResponse) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	// color
	state.Color = types.StringPointerValue(response.Color)
	// connectors
	connectorsAttrTypes := map[string]attr.Type{
		"id": types.StringType,
	}
	connectorsElementType := types.ObjectType{AttrTypes: connectorsAttrTypes}
	var connectorsValue types.Set
	if response.Connectors == nil {
		connectorsValue = types.SetNull(connectorsElementType)
	} else {
		var connectorsValues []attr.Value
		for _, connectorsResponseValue := range response.Connectors {
			connectorsValue, diags := types.ObjectValue(connectorsAttrTypes, map[string]attr.Value{
				"id": types.StringValue(connectorsResponseValue.Id),
			})
			respDiags.Append(diags...)
			connectorsValues = append(connectorsValues, connectorsValue)
		}
		connectorsValue, diags = types.SetValue(connectorsElementType, connectorsValues)
		respDiags.Append(diags...)
	}
	state.Connectors = connectorsValue
	// current_version
	state.CurrentVersion = types.Float32PointerValue(response.CurrentVersion)
	// deployed_at
	// var deployedAtValue types.String
	// if response.DeployedAt == nil {
	// 	deployedAtValue = types.StringNull()
	// } else {
	// 	deployedAtValue = types.StringValue(response.DeployedAt.Format(time.RFC3339))
	// }
	// state.DeployedAt = deployedAtValue
	// description
	state.Description = types.StringPointerValue(response.Description)
	// dvlinter_error_count
	// state.DvlinterErrorCount = types.Float32PointerValue(response.DvlinterErrorCount)
	// dvlinter_warning_count
	// state.DvlinterWarningCount = types.Float32PointerValue(response.DvlinterWarningCount)
	// enabled
	state.Enabled = types.BoolPointerValue(response.Enabled)
	// graph_data
	// graphDataAllLinterErrorsAttrTypes := map[string]attr.Type{
	// 	"code":           types.StringType,
	// 	"flow_id":        types.StringType,
	// 	"message":        types.StringType,
	// 	"node_id":        types.StringType,
	// 	"recommendation": types.StringType,
	// 	"type":           types.StringType,
	// }
	// graphDataAllLinterErrorsElementType := types.ObjectType{AttrTypes: graphDataAllLinterErrorsAttrTypes}
	graphDataElementsEdgesDataAttrTypes := map[string]attr.Type{
		"id":     types.StringType,
		"source": types.StringType,
		"target": types.StringType,
	}
	graphDataElementsEdgesPositionAttrTypes := map[string]attr.Type{
		"x": types.Float32Type,
		"y": types.Float32Type,
	}
	graphDataElementsEdgesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsEdgesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsEdgesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsEdgesElementType := types.ObjectType{AttrTypes: graphDataElementsEdgesAttrTypes}
	// graphDataElementsNodesDataLinterErrorAttrTypes := map[string]attr.Type{
	// 	"code":           types.StringType,
	// 	"flow_id":        types.StringType,
	// 	"message":        types.StringType,
	// 	"node_id":        types.StringType,
	// 	"recommendation": types.StringType,
	// 	"type":           types.StringType,
	// }
	// graphDataElementsNodesDataLinterErrorElementType := types.ObjectType{AttrTypes: graphDataElementsNodesDataLinterErrorAttrTypes}
	graphDataElementsNodesDataAttrTypes := map[string]attr.Type{
		"capability_name": types.StringType,
		"connection_id":   types.StringType,
		"connector_id":    types.StringType,
		"id":              types.StringType,
		// "id_unique":       types.StringType,
		"label": types.StringType,
		// "linter_error":    types.SetType{ElemType: graphDataElementsNodesDataLinterErrorElementType},
		"name":       types.StringType,
		"node_type":  types.StringType,
		"properties": jsontypes.NormalizedType{},
		"status":     types.StringType,
		"type":       types.StringType,
	}
	graphDataElementsNodesPositionAttrTypes := map[string]attr.Type{
		"x": types.Float32Type,
		"y": types.Float32Type,
	}
	graphDataElementsNodesAttrTypes := map[string]attr.Type{
		"classes":    types.StringType,
		"data":       types.ObjectType{AttrTypes: graphDataElementsNodesDataAttrTypes},
		"grabbable":  types.BoolType,
		"group":      types.StringType,
		"locked":     types.BoolType,
		"pannable":   types.BoolType,
		"position":   types.ObjectType{AttrTypes: graphDataElementsNodesPositionAttrTypes},
		"removed":    types.BoolType,
		"selectable": types.BoolType,
		"selected":   types.BoolType,
	}
	graphDataElementsNodesElementType := types.ObjectType{AttrTypes: graphDataElementsNodesAttrTypes}
	graphDataElementsAttrTypes := map[string]attr.Type{
		"edges": types.SetType{ElemType: graphDataElementsEdgesElementType},
		"nodes": types.SetType{ElemType: graphDataElementsNodesElementType},
	}
	graphDataPanAttrTypes := map[string]attr.Type{
		"x": types.Float32Type,
		"y": types.Float32Type,
	}
	graphDataAttrTypes := map[string]attr.Type{
		// "all_linter_errors":     types.SetType{ElemType: graphDataAllLinterErrorsElementType},
		"box_selection_enabled": types.BoolType,
		"data":                  jsontypes.NormalizedType{},
		"elements":              types.ObjectType{AttrTypes: graphDataElementsAttrTypes},
		"max_zoom":              types.NumberType,
		"min_zoom":              types.NumberType,
		"pan":                   types.ObjectType{AttrTypes: graphDataPanAttrTypes},
		"panning_enabled":       types.BoolType,
		"renderer":              jsontypes.NormalizedType{},
		"user_panning_enabled":  types.BoolType,
		"user_zooming_enabled":  types.BoolType,
		"zoom":                  types.Int32Type,
		"zooming_enabled":       types.BoolType,
	}
	var graphDataValue types.Object
	if response.GraphData == nil {
		graphDataValue = types.ObjectNull(graphDataAttrTypes)
	} else {
		// var graphDataAllLinterErrorsValue types.Set
		// if response.GraphData.AllLinterErrors == nil {
		// 	graphDataAllLinterErrorsValue = types.SetNull(graphDataAllLinterErrorsElementType)
		// } else {
		// 	var graphDataAllLinterErrorsValues []attr.Value
		// 	for _, graphDataAllLinterErrorsResponseValue := range response.GraphData.AllLinterErrors {
		// 		graphDataAllLinterErrorsValue, diags := types.ObjectValue(graphDataAllLinterErrorsAttrTypes, map[string]attr.Value{
		// 			"code":           types.StringValue(graphDataAllLinterErrorsResponseValue.Code),
		// 			"flow_id":        types.StringValue(graphDataAllLinterErrorsResponseValue.FlowId),
		// 			"message":        types.StringValue(graphDataAllLinterErrorsResponseValue.Message),
		// 			"node_id":        types.StringPointerValue(graphDataAllLinterErrorsResponseValue.NodeId),
		// 			"recommendation": types.StringValue(graphDataAllLinterErrorsResponseValue.Recommendation),
		// 			"type":           types.StringValue(graphDataAllLinterErrorsResponseValue.Type),
		// 		})
		// 		respDiags.Append(diags...)
		// 		graphDataAllLinterErrorsValues = append(graphDataAllLinterErrorsValues, graphDataAllLinterErrorsValue)
		// 	}
		// 	graphDataAllLinterErrorsValue, diags = types.SetValue(graphDataAllLinterErrorsElementType, graphDataAllLinterErrorsValues)
		// 	respDiags.Append(diags...)
		// }
		graphDataDataValue := jsontypes.NewNormalizedNull()
		graphDataDataBytes, err := json.Marshal(response.GraphData.Data)
		if err != nil {
			respDiags.AddError(
				"Error Marshaling graphData.data",
				fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
			)
		} else {
			graphDataDataValue = jsontypes.NewNormalizedValue(string(graphDataDataBytes))
		}
		var graphDataElementsEdgesValues []attr.Value
		for _, graphDataElementsEdgesResponseValue := range response.GraphData.Elements.Edges {
			graphDataElementsEdgesDataValue, diags := types.ObjectValue(graphDataElementsEdgesDataAttrTypes, map[string]attr.Value{
				"id":     types.StringValue(graphDataElementsEdgesResponseValue.Data.Id),
				"source": types.StringValue(graphDataElementsEdgesResponseValue.Data.Source),
				"target": types.StringValue(graphDataElementsEdgesResponseValue.Data.Target),
			})
			respDiags.Append(diags...)
			graphDataElementsEdgesPositionValue, diags := types.ObjectValue(graphDataElementsEdgesPositionAttrTypes, map[string]attr.Value{
				"x": types.Float32Value(graphDataElementsEdgesResponseValue.Position.X),
				"y": types.Float32Value(graphDataElementsEdgesResponseValue.Position.Y),
			})
			respDiags.Append(diags...)
			graphDataElementsEdgesValue, diags := types.ObjectValue(graphDataElementsEdgesAttrTypes, map[string]attr.Value{
				"classes":    types.StringPointerValue(graphDataElementsEdgesResponseValue.Classes),
				"data":       graphDataElementsEdgesDataValue,
				"grabbable":  types.BoolValue(graphDataElementsEdgesResponseValue.Grabbable),
				"group":      types.StringValue(graphDataElementsEdgesResponseValue.Group),
				"locked":     types.BoolValue(graphDataElementsEdgesResponseValue.Locked),
				"pannable":   types.BoolValue(graphDataElementsEdgesResponseValue.Pannable),
				"position":   graphDataElementsEdgesPositionValue,
				"removed":    types.BoolValue(graphDataElementsEdgesResponseValue.Removed),
				"selectable": types.BoolValue(graphDataElementsEdgesResponseValue.Selectable),
				"selected":   types.BoolValue(graphDataElementsEdgesResponseValue.Selected),
			})
			respDiags.Append(diags...)
			graphDataElementsEdgesValues = append(graphDataElementsEdgesValues, graphDataElementsEdgesValue)
		}
		graphDataElementsEdgesValue, diags := types.SetValue(graphDataElementsEdgesElementType, graphDataElementsEdgesValues)
		respDiags.Append(diags...)
		var graphDataElementsNodesValues []attr.Value
		for _, graphDataElementsNodesResponseValue := range response.GraphData.Elements.Nodes {
			// var graphDataElementsNodesDataLinterErrorValue types.Set
			// if graphDataElementsNodesResponseValue.Data.LinterError == nil {
			// 	graphDataElementsNodesDataLinterErrorValue = types.SetNull(graphDataElementsNodesDataLinterErrorElementType)
			// } else {
			// 	var graphDataElementsNodesDataLinterErrorValues []attr.Value
			// 	for _, graphDataElementsNodesDataLinterErrorResponseValue := range graphDataElementsNodesResponseValue.Data.LinterError {
			// 		graphDataElementsNodesDataLinterErrorValue, diags := types.ObjectValue(graphDataElementsNodesDataLinterErrorAttrTypes, map[string]attr.Value{
			// 			"code":           types.StringValue(graphDataElementsNodesDataLinterErrorResponseValue.Code),
			// 			"flow_id":        types.StringValue(graphDataElementsNodesDataLinterErrorResponseValue.FlowId),
			// 			"message":        types.StringValue(graphDataElementsNodesDataLinterErrorResponseValue.Message),
			// 			"node_id":        types.StringPointerValue(graphDataElementsNodesDataLinterErrorResponseValue.NodeId),
			// 			"recommendation": types.StringValue(graphDataElementsNodesDataLinterErrorResponseValue.Recommendation),
			// 			"type":           types.StringValue(graphDataElementsNodesDataLinterErrorResponseValue.Type),
			// 		})
			// 		respDiags.Append(diags...)
			// 		graphDataElementsNodesDataLinterErrorValues = append(graphDataElementsNodesDataLinterErrorValues, graphDataElementsNodesDataLinterErrorValue)
			// 	}
			// 	graphDataElementsNodesDataLinterErrorValue, diags = types.SetValue(graphDataElementsNodesDataLinterErrorElementType, graphDataElementsNodesDataLinterErrorValues)
			// 	respDiags.Append(diags...)
			// }
			graphDataElementsNodesDataPropertiesValue := jsontypes.NewNormalizedNull()
			graphDataElementsNodesDataPropertiesBytes, err := json.Marshal(graphDataElementsNodesResponseValue.Data.Properties)
			if err != nil {
				respDiags.AddError(
					"Error Marshaling graphData.elements.nodes.data.properties",
					fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
				)
			} else {
				graphDataElementsNodesDataPropertiesValue = jsontypes.NewNormalizedValue(string(graphDataElementsNodesDataPropertiesBytes))
			}
			graphDataElementsNodesDataValue, diags := types.ObjectValue(graphDataElementsNodesDataAttrTypes, map[string]attr.Value{
				"capability_name": types.StringPointerValue(graphDataElementsNodesResponseValue.Data.CapabilityName),
				"connection_id":   types.StringPointerValue(graphDataElementsNodesResponseValue.Data.ConnectionId),
				"connector_id":    types.StringPointerValue(graphDataElementsNodesResponseValue.Data.ConnectorId),
				"id":              types.StringValue(graphDataElementsNodesResponseValue.Data.Id),
				// "id_unique":       types.StringPointerValue(graphDataElementsNodesResponseValue.Data.IdUnique),
				"label": types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Label),
				// "linter_error":    graphDataElementsNodesDataLinterErrorValue,
				"name":       types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Name),
				"node_type":  types.StringValue(graphDataElementsNodesResponseValue.Data.NodeType),
				"properties": graphDataElementsNodesDataPropertiesValue,
				"status":     types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Status),
				"type":       types.StringPointerValue(graphDataElementsNodesResponseValue.Data.Type),
			})
			respDiags.Append(diags...)
			graphDataElementsNodesPositionValue, diags := types.ObjectValue(graphDataElementsNodesPositionAttrTypes, map[string]attr.Value{
				"x": types.Float32Value(graphDataElementsNodesResponseValue.Position.X),
				"y": types.Float32Value(graphDataElementsNodesResponseValue.Position.Y),
			})
			respDiags.Append(diags...)
			graphDataElementsNodesValue, diags := types.ObjectValue(graphDataElementsNodesAttrTypes, map[string]attr.Value{
				"classes":    types.StringPointerValue(graphDataElementsNodesResponseValue.Classes),
				"data":       graphDataElementsNodesDataValue,
				"grabbable":  types.BoolValue(graphDataElementsNodesResponseValue.Grabbable),
				"group":      types.StringValue(graphDataElementsNodesResponseValue.Group),
				"locked":     types.BoolValue(graphDataElementsNodesResponseValue.Locked),
				"pannable":   types.BoolValue(graphDataElementsNodesResponseValue.Pannable),
				"position":   graphDataElementsNodesPositionValue,
				"removed":    types.BoolValue(graphDataElementsNodesResponseValue.Removed),
				"selectable": types.BoolValue(graphDataElementsNodesResponseValue.Selectable),
				"selected":   types.BoolValue(graphDataElementsNodesResponseValue.Selected),
			})
			respDiags.Append(diags...)
			graphDataElementsNodesValues = append(graphDataElementsNodesValues, graphDataElementsNodesValue)
		}
		graphDataElementsNodesValue, diags := types.SetValue(graphDataElementsNodesElementType, graphDataElementsNodesValues)
		respDiags.Append(diags...)
		graphDataElementsValue, diags := types.ObjectValue(graphDataElementsAttrTypes, map[string]attr.Value{
			"edges": graphDataElementsEdgesValue,
			"nodes": graphDataElementsNodesValue,
		})
		respDiags.Append(diags...)
		graphDataPanValue, diags := types.ObjectValue(graphDataPanAttrTypes, map[string]attr.Value{
			"x": types.Float32Value(response.GraphData.Pan.X),
			"y": types.Float32Value(response.GraphData.Pan.Y),
		})
		respDiags.Append(diags...)
		graphDataRendererValue := jsontypes.NewNormalizedNull()
		graphDataRendererBytes, err := json.Marshal(response.GraphData.Renderer)
		if err != nil {
			respDiags.AddError(
				"Error Marshaling graphData.renderer",
				fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
			)
		} else {
			graphDataRendererValue = jsontypes.NewNormalizedValue(string(graphDataRendererBytes))
		}
		graphDataValue, diags = types.ObjectValue(graphDataAttrTypes, map[string]attr.Value{
			// "all_linter_errors":     graphDataAllLinterErrorsValue,
			"box_selection_enabled": types.BoolValue(response.GraphData.BoxSelectionEnabled),
			"data":                  graphDataDataValue,
			"elements":              graphDataElementsValue,
			"max_zoom":              types.NumberValue(response.GraphData.MaxZoom.Float),
			"min_zoom":              types.NumberValue(response.GraphData.MinZoom.Float),
			"pan":                   graphDataPanValue,
			"panning_enabled":       types.BoolValue(response.GraphData.PanningEnabled),
			"renderer":              graphDataRendererValue,
			"user_panning_enabled":  types.BoolValue(response.GraphData.UserPanningEnabled),
			"user_zooming_enabled":  types.BoolValue(response.GraphData.UserZoomingEnabled),
			"zoom":                  types.Int32Value(int32(response.GraphData.Zoom)),
			"zooming_enabled":       types.BoolPointerValue(response.GraphData.ZoomingEnabled),
		})
		respDiags.Append(diags...)
	}
	state.GraphData = graphDataValue
	// id
	state.Id = types.StringValue(response.Id)
	// input_schema
	inputSchemaAttrTypes := map[string]attr.Type{
		"description":            types.StringType,
		"is_expanded":            types.BoolType,
		"preferred_control_type": types.StringType,
		"preferred_data_type":    types.StringType,
		"property_name":          types.StringType,
		"required":               types.BoolType,
	}
	inputSchemaElementType := types.ObjectType{AttrTypes: inputSchemaAttrTypes}
	var inputSchemaValue types.List
	if response.InputSchema == nil {
		inputSchemaValue = types.ListNull(inputSchemaElementType)
	} else {
		var inputSchemaValues []attr.Value
		for _, inputSchemaResponseValue := range response.InputSchema {
			inputSchemaPreferredControlTypeValue := types.StringValue(string(inputSchemaResponseValue.PreferredControlType))
			inputSchemaPreferredDataTypeValue := types.StringValue(string(inputSchemaResponseValue.PreferredDataType))
			inputSchemaValue, diags := types.ObjectValue(inputSchemaAttrTypes, map[string]attr.Value{
				"description":            types.StringPointerValue(inputSchemaResponseValue.Description),
				"is_expanded":            types.BoolPointerValue(inputSchemaResponseValue.IsExpanded),
				"preferred_control_type": inputSchemaPreferredControlTypeValue,
				"preferred_data_type":    inputSchemaPreferredDataTypeValue,
				"property_name":          types.StringValue(inputSchemaResponseValue.PropertyName),
				"required":               types.BoolPointerValue(inputSchemaResponseValue.Required),
			})
			respDiags.Append(diags...)
			inputSchemaValues = append(inputSchemaValues, inputSchemaValue)
		}
		inputSchemaValue, diags = types.ListValue(inputSchemaElementType, inputSchemaValues)
		respDiags.Append(diags...)
	}
	state.InputSchema = inputSchemaValue
	// name
	state.Name = types.StringValue(response.Name)
	// output_schema
	outputSchemaAttrTypes := map[string]attr.Type{
		"output": jsontypes.NormalizedType{},
	}
	var outputSchemaValue types.Object
	if response.OutputSchema == nil {
		outputSchemaValue = types.ObjectNull(outputSchemaAttrTypes)
	} else {
		outputSchemaOutputValue := jsontypes.NewNormalizedNull()
		outputSchemaOutputBytes, err := json.Marshal(response.OutputSchema.Output)
		if err != nil {
			respDiags.AddError(
				"Error Marshaling outputSchema.output",
				fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
			)
		} else {
			outputSchemaOutputValue = jsontypes.NewNormalizedValue(string(outputSchemaOutputBytes))
		}
		outputSchemaValue, diags = types.ObjectValue(outputSchemaAttrTypes, map[string]attr.Value{
			"output": outputSchemaOutputValue,
		})
		respDiags.Append(diags...)
	}
	state.OutputSchema = outputSchemaValue
	// published_version
	// state.PublishedVersion = types.Float32PointerValue(response.PublishedVersion)
	// settings
	settingsJsLinksAttrTypes := map[string]attr.Type{
		"crossorigin":    types.StringType,
		"defer":          types.BoolType,
		"integrity":      types.StringType,
		"label":          types.StringType,
		"referrerpolicy": types.StringType,
		"type":           types.StringType,
		"value":          types.StringType,
	}
	settingsJsLinksElementType := types.ObjectType{AttrTypes: settingsJsLinksAttrTypes}
	settingsAttrTypes := map[string]attr.Type{
		"csp":                                types.StringType,
		"css":                                types.StringType,
		"css_links":                          types.SetType{ElemType: types.StringType},
		"custom_error_screen_brand_logo_url": types.StringType,
		"custom_error_show_footer":           types.BoolType,
		"custom_favicon_link":                types.StringType,
		"custom_logo_urlselection":           types.Int32Type,
		"custom_title":                       types.StringType,
		"default_error_screen_brand_logo":    types.BoolType,
		"flow_http_timeout_in_seconds":       types.Int32Type,
		"flow_timeout_in_seconds":            types.Int32Type,
		"intermediate_loading_screen_css":    types.StringType,
		"intermediate_loading_screen_html":   types.StringType,
		"js_custom_flow_player":              types.StringType,
		"js_links":                           types.SetType{ElemType: settingsJsLinksElementType},
		"log_level":                          types.Int32Type,
		"require_authentication_to_initiate": types.BoolType,
		"scrub_sensitive_info":               types.BoolType,
		"sensitive_info_fields":              types.SetType{ElemType: types.StringType},
		"use_csp":                            types.BoolType,
		"use_custom_css":                     types.BoolType,
		"use_custom_flow_player":             types.BoolType,
		"use_custom_script":                  types.BoolType,
		"use_intermediate_loading_screen":    types.BoolType,
		"validate_on_save":                   types.BoolType,
	}
	var settingsValue types.Object
	if response.Settings == nil {
		settingsValue = types.ObjectNull(settingsAttrTypes)
	} else {
		var settingsCssLinksValue types.Set
		if response.Settings.CssLinks == nil {
			settingsCssLinksValue = types.SetNull(types.StringType)
		} else {
			settingsCssLinksValue, diags = types.SetValueFrom(context.Background(), types.StringType, response.Settings.CssLinks)
			respDiags.Append(diags...)
		}
		var settingsJsLinksValue types.Set
		if response.Settings.JsLinks == nil {
			settingsJsLinksValue = types.SetNull(settingsJsLinksElementType)
		} else {
			var settingsJsLinksValues []attr.Value
			for _, settingsJsLinksResponseValue := range response.Settings.JsLinks {
				settingsJsLinksValue, diags := types.ObjectValue(settingsJsLinksAttrTypes, map[string]attr.Value{
					"crossorigin":    types.StringValue(settingsJsLinksResponseValue.Crossorigin),
					"defer":          types.BoolValue(settingsJsLinksResponseValue.Defer),
					"integrity":      types.StringValue(settingsJsLinksResponseValue.Integrity),
					"label":          types.StringValue(settingsJsLinksResponseValue.Label),
					"referrerpolicy": types.StringValue(settingsJsLinksResponseValue.Referrerpolicy),
					"type":           types.StringValue(settingsJsLinksResponseValue.Type),
					"value":          types.StringValue(settingsJsLinksResponseValue.Value),
				})
				respDiags.Append(diags...)
				settingsJsLinksValues = append(settingsJsLinksValues, settingsJsLinksValue)
			}
			settingsJsLinksValue, diags = types.SetValue(settingsJsLinksElementType, settingsJsLinksValues)
			respDiags.Append(diags...)
		}
		var settingsSensitiveInfoFieldsValue types.Set
		if response.Settings.SensitiveInfoFields == nil {
			settingsSensitiveInfoFieldsValue = types.SetNull(types.StringType)
		} else {
			settingsSensitiveInfoFieldsValue, diags = types.SetValueFrom(context.Background(), types.StringType, response.Settings.SensitiveInfoFields)
			respDiags.Append(diags...)
		}
		settingsValue, diags = types.ObjectValue(settingsAttrTypes, map[string]attr.Value{
			"csp":                                types.StringPointerValue(response.Settings.Csp),
			"css":                                types.StringPointerValue(response.Settings.Css),
			"css_links":                          settingsCssLinksValue,
			"custom_error_screen_brand_logo_url": types.StringPointerValue(response.Settings.CustomErrorScreenBrandLogoUrl),
			"custom_error_show_footer":           types.BoolPointerValue(response.Settings.CustomErrorShowFooter),
			"custom_favicon_link":                types.StringPointerValue(response.Settings.CustomFaviconLink),
			"custom_logo_urlselection":           types.Int32PointerValue(response.Settings.CustomLogoURLSelection),
			"custom_title":                       types.StringPointerValue(response.Settings.CustomTitle),
			"default_error_screen_brand_logo":    types.BoolPointerValue(response.Settings.DefaultErrorScreenBrandLogo),
			"flow_http_timeout_in_seconds":       types.Int32PointerValue(response.Settings.FlowHttpTimeoutInSeconds),
			"flow_timeout_in_seconds":            types.Int32PointerValue(response.Settings.FlowTimeoutInSeconds),
			"intermediate_loading_screen_css":    types.StringPointerValue(response.Settings.IntermediateLoadingScreenCSS),
			"intermediate_loading_screen_html":   types.StringPointerValue(response.Settings.IntermediateLoadingScreenHTML),
			"js_custom_flow_player":              types.StringPointerValue(response.Settings.JsCustomFlowPlayer),
			"js_links":                           settingsJsLinksValue,
			"log_level":                          types.Int32PointerValue(response.Settings.LogLevel),
			"require_authentication_to_initiate": types.BoolPointerValue(response.Settings.RequireAuthenticationToInitiate),
			"scrub_sensitive_info":               types.BoolPointerValue(response.Settings.ScrubSensitiveInfo),
			"sensitive_info_fields":              settingsSensitiveInfoFieldsValue,
			"use_csp":                            types.BoolPointerValue(response.Settings.UseCSP),
			"use_custom_css":                     types.BoolPointerValue(response.Settings.UseCustomCSS),
			"use_custom_flow_player":             types.BoolPointerValue(response.Settings.UseCustomFlowPlayer),
			"use_custom_script":                  types.BoolPointerValue(response.Settings.UseCustomScript),
			"use_intermediate_loading_screen":    types.BoolPointerValue(response.Settings.UseIntermediateLoadingScreen),
			"validate_on_save":                   types.BoolPointerValue(response.Settings.ValidateOnSave),
		})
		respDiags.Append(diags...)
	}
	state.Settings = settingsValue
	// trigger
	triggerConfigurationMfaAttrTypes := map[string]attr.Type{
		"enabled":     types.BoolType,
		"time":        types.Float32Type,
		"time_format": types.StringType,
	}
	triggerConfigurationPwdAttrTypes := map[string]attr.Type{
		"enabled":     types.BoolType,
		"time":        types.Float32Type,
		"time_format": types.StringType,
	}
	triggerConfigurationAttrTypes := map[string]attr.Type{
		"mfa": types.ObjectType{AttrTypes: triggerConfigurationMfaAttrTypes},
		"pwd": types.ObjectType{AttrTypes: triggerConfigurationPwdAttrTypes},
	}
	triggerAttrTypes := map[string]attr.Type{
		"configuration": types.ObjectType{AttrTypes: triggerConfigurationAttrTypes},
		"type":          types.StringType,
	}
	var triggerValue types.Object
	if response.Trigger == nil {
		triggerValue = types.ObjectNull(triggerAttrTypes)
	} else {
		var triggerConfigurationValue types.Object
		if response.Trigger.Configuration == nil {
			triggerConfigurationValue = types.ObjectNull(triggerConfigurationAttrTypes)
		} else {
			triggerConfigurationMfaValue, diags := types.ObjectValue(triggerConfigurationMfaAttrTypes, map[string]attr.Value{
				"enabled":     types.BoolValue(response.Trigger.Configuration.Mfa.Enabled),
				"time":        types.Float32Value(response.Trigger.Configuration.Mfa.Time),
				"time_format": types.StringValue(response.Trigger.Configuration.Mfa.TimeFormat),
			})
			respDiags.Append(diags...)
			triggerConfigurationPwdValue, diags := types.ObjectValue(triggerConfigurationPwdAttrTypes, map[string]attr.Value{
				"enabled":     types.BoolValue(response.Trigger.Configuration.Pwd.Enabled),
				"time":        types.Float32Value(response.Trigger.Configuration.Pwd.Time),
				"time_format": types.StringValue(response.Trigger.Configuration.Pwd.TimeFormat),
			})
			respDiags.Append(diags...)
			triggerConfigurationValue, diags = types.ObjectValue(triggerConfigurationAttrTypes, map[string]attr.Value{
				"mfa": triggerConfigurationMfaValue,
				"pwd": triggerConfigurationPwdValue,
			})
			respDiags.Append(diags...)
		}
		var triggerTypePtrValue *string
		if response.Trigger.Type != nil {
			triggerTypeStringValue := string(*response.Trigger.Type)
			triggerTypePtrValue = &triggerTypeStringValue
		}
		triggerTypeValue := types.StringPointerValue(triggerTypePtrValue)
		triggerValue, diags = types.ObjectValue(triggerAttrTypes, map[string]attr.Value{
			"configuration": triggerConfigurationValue,
			"type":          triggerTypeValue,
		})
		respDiags.Append(diags...)
	}
	state.Trigger = triggerValue
	return respDiags
}

func (r *davinciFlowResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	clientData, diags := data.buildClientStructPost()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var responseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.CreateFlow(ctx, environmentIdUuid).DaVinciFlowCreateRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"CreateFlow",
		framework.DefaultCustomError,
		framework.DefaultRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *davinciFlowResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var responseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.GetFlowById(ctx, environmentIdUuid, data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"GetFlowById",
		framework.CustomErrorResourceNotFoundWarning,
		framework.DefaultRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Remove from state if resource is not found
	if responseData == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *davinciFlowResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Update API call logic
	clientData, diags := data.buildClientStructPut()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var responseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.ReplaceFlowById(ctx, environmentIdUuid, data.Id.ValueString()).DaVinciFlowReplaceRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"ReplaceFlowById",
		framework.DefaultCustomError,
		framework.DefaultRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *davinciFlowResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Delete API call logic
	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fR, fErr := r.Client.DaVinciFlowsApi.DeleteFlowById(ctx, environmentIdUuid, data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), nil, fR, fErr)
		},
		"DeleteFlowById",
		framework.CustomErrorResourceNotFoundWarning,
		framework.DefaultRetryable,
		nil,
	)...)
}

func (r *davinciFlowResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	idComponents := []framework.ImportComponent{
		{
			Label:  "environment_id",
			Regexp: verify.P1ResourceIDRegexp,
		},
		{
			Label:     "flow_id",
			Regexp:    verify.P1DVResourceIDRegexp,
			PrimaryID: true,
		},
	}

	attributes, err := framework.ParseImportID(req.ID, idComponents...)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			err.Error(),
		)
		return
	}

	for _, idComponent := range idComponents {
		pathKey := idComponent.Label

		if idComponent.PrimaryID {
			pathKey = "id"
		}

		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root(pathKey), attributes[idComponent.Label])...)
	}
}
