// Copyright Â© 2025 Ping Identity Corporation
// Code generated by ping-terraform-plugin-framework-generator

//go:build beta

package davinci

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/pingidentity/pingone-go-client/pingone"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework"
)

var (
	_ resource.ResourceWithValidateConfig = &davinciFlowResource{}
	_ resource.ResourceWithModifyPlan     = &davinciFlowResource{}

	inputSchemaElemAttrTypes = map[string]attr.Type{
		"description":            types.StringType,
		"is_expanded":            types.BoolType,
		"preferred_control_type": types.StringType,
		"preferred_data_type":    types.StringType,
		"property_name":          types.StringType,
		"required":               types.BoolType,
	}

	inputSchemaDefault = types.ListValueMust(
		types.ObjectType{AttrTypes: inputSchemaElemAttrTypes},
		[]attr.Value{
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("A string that specifies an identifier to pre-fill the username field of a sign-on screen."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("string"),
				"property_name":          types.StringValue("loginHint"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An integer that specifies the maximum amount of time allowed (in seconds) since the user last authenticated. If the user's last sign on in the session is greater than the integer value specified in this property, then existing session information cannot be used to skip authentication or influence any authentication logic. This value is set automatically to 0 if prompt=login is set for an OIDC application or if ForceAuthn=true is set for a SAML application. Otherwise, this value is set to the max_age property value for OIDC applications, if present, or omitted otherwise."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("number"),
				"property_name":          types.StringValue("maxSecondsSinceLastSignOn"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the OIDC authorization request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("authorizationRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the SAML request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("samlRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the WS-FED request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("wsFedRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies the configuration information about the PingOne application that initiated the authentication request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("application"),
				"required":               types.BoolValue(true),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("Internal information that is only useful to P1. This is meant to be opaque and may be changed or removed in the future."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("relayState"),
				"required":               types.BoolValue(true),
			}),
		},
	)
)

func (r *davinciFlowResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data *davinciFlowResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() || data == nil {
		return
	}

	// Ensure that if trigger.type is set to AUTHENTICATION, input_schema is not set.
	if !data.Trigger.IsNull() && !data.Trigger.IsUnknown() {
		triggerType := data.Trigger.Attributes()["type"].(types.String).ValueString()
		if triggerType == "AUTHENTICATION" && !data.InputSchema.IsNull() && !data.InputSchema.IsUnknown() {
			resp.Diagnostics.AddAttributeError(
				path.Root("input_schema"),
				"Attribute value conflict",
				"input_schema must not be configured when trigger.type is set to AUTHENTICATION",
			)
		}
	}

	// Warn if log_level is set to Debug (3)
	if !data.Settings.IsNull() && !data.Settings.IsUnknown() {
		settingsAttrs := data.Settings.Attributes()
		logLevel := settingsAttrs["log_level"].(types.Int32)
		if !logLevel.IsNull() && !logLevel.IsUnknown() && logLevel.ValueInt32() == 3 {
			resp.Diagnostics.AddAttributeWarning(
				path.Root("settings").AtMapKey("log_level"),
				"DaVinci flow settings.log_level set to Debug",
				"The flow log level is set to Debug (3). For standard operation, it's recommended to set the log level to Info (2) or None (1) unless active troubleshooting is needed.",
			)
		}
	}
}

func (r *davinciFlowResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	var config, plan *davinciFlowResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() || plan == nil || config == nil {
		return
	}

	// If trigger.type is set to AUTHENTICATION and input_schema is Unknown, set the default value
	triggerTypeAuthentication := false
	if !plan.Trigger.IsNull() && !plan.Trigger.IsUnknown() {
		triggerTypeAuthentication = plan.Trigger.Attributes()["type"].(types.String).ValueString() == "AUTHENTICATION"
	}

	if plan.InputSchema.IsUnknown() {
		if triggerTypeAuthentication {
			plan.InputSchema = inputSchemaDefault
		} else if config.InputSchema.IsNull() {
			// Set to null if not configured
			plan.InputSchema = types.ListNull(types.ObjectType{AttrTypes: inputSchemaElemAttrTypes})
		}
		resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
	}
}

func (m *davinciFlowResourceModel) getGraphDataElementsNodes() *types.Map {
	if !m.GraphData.IsNull() && !m.GraphData.IsUnknown() {
		graphDataAttrs := m.GraphData.Attributes()
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			nodesSet, ok := graphDataElementsAttrs["nodes"].(types.Map)
			if ok {
				return &nodesSet
			}
		}
	}
	return nil
}

func (r *davinciFlowResource) isUpdateRequiredAfterCreate(plan, createResponse davinciFlowResourceModel) bool {
	planNodes := plan.getGraphDataElementsNodes()
	createResponseNodes := createResponse.getGraphDataElementsNodes()

	// Check that the create returned all the nodes, but the content did not match the plan
	return len(planNodes.Elements()) == len(createResponseNodes.Elements()) && !planNodes.Equal(createResponseNodes)
}

func (r *davinciFlowResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data, createResponseModel davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	clientData, diags := data.buildClientStructPost()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var createResponseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.CreateFlow(ctx, environmentIdUuid).DaVinciFlowCreateRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"CreateFlow",
		framework.DefaultCustomError,
		framework.DefaultCreateReadRetryable,
		&createResponseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read create response into new model
	resp.Diagnostics.Append(createResponseModel.readClientResponse(createResponseData)...)

	// Currently certain fields require an update call after initial create to set (TRIAGE-29360)
	// If the node count is correct but the contents are not equal, an update is necessary
	if r.isUpdateRequiredAfterCreate(data, createResponseModel) {
		// Update API call logic
		putClientData, diags := data.buildClientStructPut()
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}

		var updateResponseData *pingone.DaVinciFlowResponse
		resp.Diagnostics.Append(framework.ParseResponse(
			ctx,

			func() (any, *http.Response, error) {
				fO, fR, fErr := r.Client.DaVinciFlowsApi.ReplaceFlowById(ctx, environmentIdUuid, createResponseData.Id).DaVinciFlowReplaceRequest(*putClientData).Execute()
				return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
			},
			"ReplaceFlowById-Create",
			framework.DefaultCustomError,
			framework.DefaultCreateReadRetryable,
			&updateResponseData,
		)...)

		if resp.Diagnostics.HasError() {
			return
		}

		// Read response into the model
		resp.Diagnostics.Append(data.readClientResponse(updateResponseData)...)
	} else {
		// Just use the create response directly
		resp.Diagnostics.Append(data.readClientResponse(createResponseData)...)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (plan *davinciFlowResourceModel) getPlannedNodeDataProperties(nodeId string) jsontypes.Normalized {
	plannedNodeDataProperties := jsontypes.NewNormalizedNull()
	if !plan.GraphData.IsNull() && !plan.GraphData.IsUnknown() {
		plannedGraphDataAttrs := plan.GraphData.Attributes()
		if !plannedGraphDataAttrs["elements"].IsNull() && !plannedGraphDataAttrs["elements"].IsUnknown() {
			plannedGraphDataElementsAttrs := plannedGraphDataAttrs["elements"].(types.Object).Attributes()
			if !plannedGraphDataElementsAttrs["nodes"].IsNull() && !plannedGraphDataElementsAttrs["nodes"].IsUnknown() {
				plannedGraphDataElementsNodesMap := plannedGraphDataElementsAttrs["nodes"].(types.Map)
				plannedNodeAttrValue, ok := plannedGraphDataElementsNodesMap.Elements()[nodeId]
				if ok {
					plannedNodeAttrs := plannedNodeAttrValue.(types.Object).Attributes()
					if !plannedNodeAttrs["data"].IsNull() && !plannedNodeAttrs["data"].IsUnknown() {
						plannedNodeDataAttrs := plannedNodeAttrs["data"].(types.Object).Attributes()
						if !plannedNodeDataAttrs["properties"].IsNull() && !plannedNodeDataAttrs["properties"].IsUnknown() {
							plannedNodeDataProperties = plannedNodeDataAttrs["properties"].(jsontypes.Normalized)
						}
					}
				}
			}
		}
	}
	return plannedNodeDataProperties
}

// Get a normalized json type from the response, ignoring json keys that were not included in the planned data.properties value
func (m *davinciFlowResourceModel) normalizeNodeDataProperties(planProperties jsontypes.Normalized, responseProperties map[string]interface{}) (jsontypes.Normalized, diag.Diagnostics) {
	if planProperties.IsNull() || planProperties.IsUnknown() {
		// We have no known keys, so just accept whatever the API returned
		return buildJsonNormalizedValueFromMap(responseProperties)
	}

	var diags diag.Diagnostics
	var normalizedProperties jsontypes.Normalized

	// Get a map of the known keys from the planned properties
	plannedPropertiesMap := make(map[string]interface{})
	err := json.Unmarshal([]byte(planProperties.ValueString()), &plannedPropertiesMap)
	if err != nil {
		diags.AddError(
			"Error Unmarshaling planned graphData.elements.nodes.data.properties",
			fmt.Sprintf("An error occurred while unmarshaling: %s", err.Error()),
		)
		return normalizedProperties, diags
	}

	// Make a deep copy of responseProperties to avoid mutating the input
	responsePropertiesBytes, err := json.Marshal(responseProperties)
	if err != nil {
		diags.AddError(
			"Error Marshaling response properties",
			fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
		)
		return normalizedProperties, diags
	}
	var responsePropertiesCopy map[string]interface{}
	err = json.Unmarshal(responsePropertiesBytes, &responsePropertiesCopy)
	if err != nil {
		diags.AddError(
			"Error Unmarshaling response properties",
			fmt.Sprintf("An error occurred while unmarshaling: %s", err.Error()),
		)
		return normalizedProperties, diags
	}

	// Remove keys from the response that were not in the plan
	cleanedResponseProperties, removeDiags := removeUnknownKeysFromJsonMap(plannedPropertiesMap, responsePropertiesCopy)
	diags.Append(removeDiags...)

	normalizedProperties, normalizeDiags := buildJsonNormalizedValueFromMap(cleanedResponseProperties)
	diags.Append(normalizeDiags...)
	return normalizedProperties, diags
}

// removeUnknownKeysFromJsonMap removes keys from actualJson that are not present in expectedJson.
// This function mutates actualJson in place for nested objects.
func removeUnknownKeysFromJsonMap(expectedJson map[string]interface{}, actualJson map[string]interface{}) (map[string]interface{}, diag.Diagnostics) {
	var diags diag.Diagnostics

	for key := range actualJson {
		if _, ok := expectedJson[key]; !ok {
			diags.AddWarning("API returned properties key not present in plan",
				fmt.Sprintf("The key '%s' was returned by the API but is not present in the planned properties", key))
			delete(actualJson, key)
		} else {
			// If the value is a nested object, recurse
			plannedNested, isPlannedNested := expectedJson[key].(map[string]interface{})
			responseNested, isResponseNested := actualJson[key].(map[string]interface{})
			if plannedNested != nil && responseNested != nil && isPlannedNested && isResponseNested {
				nestedJson, nestedDiags := removeUnknownKeysFromJsonMap(plannedNested, responseNested)
				diags.Append(nestedDiags...)
				actualJson[key] = nestedJson
				continue
			}

			// If the value is an array, recurse using the array handler
			plannedArray, isPlannedArray := expectedJson[key].([]interface{})
			responseArray, isResponseArray := actualJson[key].([]interface{})
			if plannedArray != nil && responseArray != nil && isPlannedArray && isResponseArray {
				cleanedArray, arrayDiags := removeUnknownKeysFromJsonArray(plannedArray, responseArray)
				diags.Append(arrayDiags...)
				actualJson[key] = cleanedArray
			}
		}
	}

	return actualJson, diags
}

// removeUnknownKeysFromJsonArray processes array elements, recursing into nested objects and arrays.
// This function mutates nested objects and arrays within actualArray in place.
func removeUnknownKeysFromJsonArray(expectedArray []interface{}, actualArray []interface{}) ([]interface{}, diag.Diagnostics) {
	var diags diag.Diagnostics
	cleanedArray := make([]interface{}, len(actualArray))

	for i := 0; i < len(actualArray); i++ {
		// Find corresponding planned element
		var plannedElement interface{}
		if i < len(expectedArray) {
			plannedElement = expectedArray[i]

			// Handle nested objects
			plannedMap, isPlannedMap := plannedElement.(map[string]interface{})
			responseMap, isResponseMap := actualArray[i].(map[string]interface{})
			if plannedMap != nil && responseMap != nil && isPlannedMap && isResponseMap {
				cleanedElement, nestedDiags := removeUnknownKeysFromJsonMap(plannedMap, responseMap)
				diags.Append(nestedDiags...)
				cleanedArray[i] = cleanedElement
				continue
			}

			// Handle nested arrays
			plannedNestedArray, isPlannedArray := plannedElement.([]interface{})
			responseNestedArray, isResponseArray := actualArray[i].([]interface{})
			if plannedNestedArray != nil && responseNestedArray != nil && isPlannedArray && isResponseArray {
				cleanedElement, nestedDiags := removeUnknownKeysFromJsonArray(plannedNestedArray, responseNestedArray)
				diags.Append(nestedDiags...)
				cleanedArray[i] = cleanedElement
				continue
			}
		}

		// If not a map or array, or no planned element, keep as-is
		cleanedArray[i] = actualArray[i]
	}

	return cleanedArray, diags
}

func buildJsonNormalizedValueFromMap(jsonMap map[string]interface{}) (jsontypes.Normalized, diag.Diagnostics) {
	var diags diag.Diagnostics
	normalizedProperties := jsontypes.NewNormalizedNull()
	graphDataElementsNodesDataPropertiesBytes, err := json.Marshal(jsonMap)
	if err != nil {
		diags.AddError(
			"Error Marshaling graphData.elements.nodes.data.properties",
			fmt.Sprintf("An error occurred while marshaling: %s", err.Error()),
		)
	} else {
		normalizedProperties = jsontypes.NewNormalizedValue(string(graphDataElementsNodesDataPropertiesBytes))
	}
	return normalizedProperties, diags
}
