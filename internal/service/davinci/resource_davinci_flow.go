// Copyright Â© 2025 Ping Identity Corporation
// Code generated by ping-terraform-plugin-framework-generator

package davinci

import (
	"context"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/pingidentity/pingone-go-client/pingone"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework"
)

var (
	_ resource.ResourceWithValidateConfig = &davinciFlowResource{}
	_ resource.ResourceWithModifyPlan     = &davinciFlowResource{}

	inputSchemaElemAttrTypes = map[string]attr.Type{
		"description":            types.StringType,
		"is_expanded":            types.BoolType,
		"preferred_control_type": types.StringType,
		"preferred_data_type":    types.StringType,
		"property_name":          types.StringType,
		"required":               types.BoolType,
	}

	inputSchemaDefault = types.ListValueMust(
		types.ObjectType{AttrTypes: inputSchemaElemAttrTypes},
		[]attr.Value{
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("A string that specifies an identifier to pre-fill the username field of a sign-on screen."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("string"),
				"property_name":          types.StringValue("loginHint"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An integer that specifies the maximum amount of time allowed (in seconds) since the user last authenticated. If the user's last sign on in the session is greater than the integer value specified in this property, then existing session information cannot be used to skip authentication or influence any authentication logic. This value is set automatically to 0 if prompt=login is set for an OIDC application or if ForceAuthn=true is set for a SAML application. Otherwise, this value is set to the max_age property value for OIDC applications, if present, or omitted otherwise."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("number"),
				"property_name":          types.StringValue("maxSecondsSinceLastSignOn"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the OIDC authorization request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("authorizationRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the SAML request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("samlRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies all the parameters from the WS-FED request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("wsFedRequest"),
				"required":               types.BoolValue(false),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("An object that specifies the configuration information about the PingOne application that initiated the authentication request."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("application"),
				"required":               types.BoolValue(true),
			}),
			types.ObjectValueMust(inputSchemaElemAttrTypes, map[string]attr.Value{
				"description":            types.StringValue("Internal information that is only useful to P1. This is meant to be opaque and may be changed or removed in the future."),
				"is_expanded":            types.BoolValue(true),
				"preferred_control_type": types.StringValue("textField"),
				"preferred_data_type":    types.StringValue("object"),
				"property_name":          types.StringValue("relayState"),
				"required":               types.BoolValue(true),
			}),
		},
	)
)

func (r *davinciFlowResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data *davinciFlowResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() || data == nil {
		return
	}

	// Ensure that if trigger.type is set to AUTHENTICATION, input_schema is not set.
	if !data.Trigger.IsNull() && !data.Trigger.IsUnknown() {
		triggerType := data.Trigger.Attributes()["type"].(types.String).ValueString()
		if triggerType == "AUTHENTICATION" && !data.InputSchema.IsNull() && !data.InputSchema.IsUnknown() {
			resp.Diagnostics.AddAttributeError(
				path.Root("input_schema"),
				"Attribute value conflict",
				"input_schema must not be configured when trigger.type is set to AUTHENTICATION",
			)
		}
	}
}

func (r *davinciFlowResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	var config, plan *davinciFlowResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() || plan == nil || config == nil {
		return
	}

	// If trigger.type is set to AUTHENTICATION and input_schema is Unknown, set the default value
	triggerTypeAuthentication := false
	if !plan.Trigger.IsNull() && !plan.Trigger.IsUnknown() {
		triggerTypeAuthentication = plan.Trigger.Attributes()["type"].(types.String).ValueString() == "AUTHENTICATION"
	}

	if plan.InputSchema.IsUnknown() {
		if triggerTypeAuthentication {
			plan.InputSchema = inputSchemaDefault
		} else if config.InputSchema.IsNull() {
			// Set to null if not configured
			plan.InputSchema = types.ListNull(types.ObjectType{AttrTypes: inputSchemaElemAttrTypes})
		}
		resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
	}
}

func (m *davinciFlowResourceModel) getGraphDataElementsNodes() *types.Set {
	if !m.GraphData.IsNull() && !m.GraphData.IsUnknown() {
		graphDataAttrs := m.GraphData.Attributes()
		if !graphDataAttrs["elements"].IsNull() && !graphDataAttrs["elements"].IsUnknown() {
			graphDataElementsAttrs := graphDataAttrs["elements"].(types.Object).Attributes()
			nodesSet, ok := graphDataElementsAttrs["nodes"].(types.Set)
			if ok {
				return &nodesSet
			}
		}
	}
	return nil
}

func (r *davinciFlowResource) isUpdateRequiredAfterCreate(plan, createResponse davinciFlowResourceModel) bool {
	planNodes := plan.getGraphDataElementsNodes()
	createResponseNodes := createResponse.getGraphDataElementsNodes()

	// Check that the create returned all the nodes, but the content did not match the plan
	return len(planNodes.Elements()) == len(createResponseNodes.Elements()) && !planNodes.Equal(createResponseNodes)
}

func (r *davinciFlowResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data, createResponseModel davinciFlowResourceModel

	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	clientData, diags := data.buildClientStructPost()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	environmentIdUuid, err := uuid.Parse(data.EnvironmentId.ValueString())
	if err != nil {
		resp.Diagnostics.AddAttributeError(
			path.Root("environment_id"),
			"Attribute Validation Error",
			fmt.Sprintf("The value '%s' for attribute '%s' is not a valid UUID: %s", data.EnvironmentId.ValueString(), "EnvironmentId", err.Error()),
		)
		return
	}
	var createResponseData *pingone.DaVinciFlowResponse
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.DaVinciFlowsApi.CreateFlow(ctx, environmentIdUuid).DaVinciFlowCreateRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"CreateFlow",
		framework.DefaultCustomError,
		framework.DefaultRetryable,
		&createResponseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read create response into new model
	resp.Diagnostics.Append(createResponseModel.readClientResponse(createResponseData)...)

	// Currently certain fields require an update call after initial create to set (TRIAGE-29360)
	// If the node count is correct but the contents are not equal, an update is necessary
	if r.isUpdateRequiredAfterCreate(data, createResponseModel) {
		// Update API call logic
		putClientData, diags := data.buildClientStructPut()
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}

		var updateResponseData *pingone.DaVinciFlowResponse
		resp.Diagnostics.Append(framework.ParseResponse(
			ctx,

			func() (any, *http.Response, error) {
				fO, fR, fErr := r.Client.DaVinciFlowsApi.ReplaceFlowById(ctx, environmentIdUuid, createResponseData.Id).DaVinciFlowReplaceRequest(*putClientData).Execute()
				return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client, data.EnvironmentId.ValueString(), fO, fR, fErr)
			},
			"ReplaceFlowById-Create",
			framework.DefaultCustomError,
			framework.DefaultRetryable,
			&updateResponseData,
		)...)

		if resp.Diagnostics.HasError() {
			return
		}

		// Read response into the model
		resp.Diagnostics.Append(data.readClientResponse(updateResponseData)...)
	} else {
		// Just use the create response directly
		resp.Diagnostics.Append(data.readClientResponse(createResponseData)...)
	}

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
