// Copyright Â© 2025 Ping Identity Corporation
// Code generated by ping-terraform-plugin-framework-generator

package sso

import (
	"context"
	"fmt"
	"net/http"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int32validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/patrickcping/pingone-go-sdk-v2/management"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework"
	"github.com/pingidentity/terraform-provider-pingone/internal/framework/customtypes/pingonetypes"
	"github.com/pingidentity/terraform-provider-pingone/internal/sdk"
	"github.com/pingidentity/terraform-provider-pingone/internal/verify"
)

var (
	_ resource.Resource                   = &applicationv2Resource{}
	_ resource.ResourceWithConfigure      = &applicationv2Resource{}
	_ resource.ResourceWithImportState    = &applicationv2Resource{}
	_ resource.ResourceWithModifyPlan     = &applicationv2Resource{}
	_ resource.ResourceWithValidateConfig = &applicationv2Resource{}
)

func NewApplicationv2Resource() resource.Resource {
	return &applicationv2Resource{}
}

type applicationv2Resource serviceClientType

func (r *applicationv2Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_applicationv2"
}

func (r *applicationv2Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	resourceConfig, ok := req.ProviderData.(framework.ResourceType)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected the provider client, got: %T. Please report this issue to the provider maintainers.", req.ProviderData),
		)

		return
	}

	r.Client = resourceConfig.Client.API
	if r.Client == nil {
		resp.Diagnostics.AddError(
			"Client not initialised",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.",
		)
		return
	}
}

type applicationv2ResourceModel struct {
	AccessControl                                 types.Object                 `tfsdk:"access_control"`
	AcsUrls                                       types.List                   `tfsdk:"acs_urls"`
	AdditionalRefreshTokenReplayProtectionEnabled types.Bool                   `tfsdk:"additional_refresh_token_replay_protection_enabled"`
	AllowWildcardInRedirectUris                   types.Bool                   `tfsdk:"allow_wildcard_in_redirect_uris"`
	AssertionDuration                             types.Int32                  `tfsdk:"assertion_duration"`
	AssertionSigned                               types.Bool                   `tfsdk:"assertion_signed"`
	AssignActorRoles                              types.Bool                   `tfsdk:"assign_actor_roles"`
	BundleId                                      types.String                 `tfsdk:"bundle_id"`
	CorsSettings                                  types.Object                 `tfsdk:"cors_settings"`
	DefaultTargetUrl                              types.String                 `tfsdk:"default_target_url"`
	Description                                   types.String                 `tfsdk:"description"`
	DeviceCustomVerificationUri                   types.String                 `tfsdk:"device_custom_verification_uri"`
	DevicePathId                                  types.String                 `tfsdk:"device_path_id"`
	DevicePollingInterval                         types.Int32                  `tfsdk:"device_polling_interval"`
	DeviceTimeout                                 types.Int32                  `tfsdk:"device_timeout"`
	EnableRequestedAuthnContext                   types.Bool                   `tfsdk:"enable_requested_authn_context"`
	Enabled                                       types.Bool                   `tfsdk:"enabled"`
	EnvironmentId                                 pingonetypes.ResourceIDValue `tfsdk:"environment_id"`
	GrantTypes                                    types.Set                    `tfsdk:"grant_types"`
	HiddenFromAppPortal                           types.Bool                   `tfsdk:"hidden_from_app_portal"`
	HomePageUrl                                   types.String                 `tfsdk:"home_page_url"`
	Icon                                          types.Object                 `tfsdk:"icon"`
	Id                                            pingonetypes.ResourceIDValue `tfsdk:"id"`
	IdpSigning                                    types.Object                 `tfsdk:"idp_signing"`
	InitiateLoginUri                              types.String                 `tfsdk:"initiate_login_uri"`
	Jwks                                          types.String                 `tfsdk:"jwks"`
	JwksUrl                                       types.String                 `tfsdk:"jwks_url"`
	Kerberos                                      types.Object                 `tfsdk:"kerberos"`
	LoginPageUrl                                  types.String                 `tfsdk:"login_page_url"`
	Mobile                                        types.Object                 `tfsdk:"mobile"`
	Name                                          types.String                 `tfsdk:"name"`
	NameIdFormat                                  types.String                 `tfsdk:"name_id_format"`
	PackageName                                   types.String                 `tfsdk:"package_name"`
	ParRequirement                                types.String                 `tfsdk:"par_requirement"`
	ParTimeout                                    types.Int32                  `tfsdk:"par_timeout"`
	PkceEnforcement                               types.String                 `tfsdk:"pkce_enforcement"`
	PostLogoutRedirectUris                        types.List                   `tfsdk:"post_logout_redirect_uris"`
	Protocol                                      types.String                 `tfsdk:"protocol"`
	RedirectUris                                  types.List                   `tfsdk:"redirect_uris"`
	RefreshTokenDuration                          types.Int32                  `tfsdk:"refresh_token_duration"`
	RefreshTokenRollingDuration                   types.Int32                  `tfsdk:"refresh_token_rolling_duration"`
	RefreshTokenRollingGracePeriodDuration        types.Int32                  `tfsdk:"refresh_token_rolling_grace_period_duration"`
	RequireSignedRequestObject                    types.Bool                   `tfsdk:"require_signed_request_object"`
	ResponseSigned                                types.Bool                   `tfsdk:"response_signed"`
	ResponseTypes                                 types.List                   `tfsdk:"response_types"`
	SessionNotOnOrAfterDuration                   types.Int32                  `tfsdk:"session_not_on_or_after_duration"`
	Signing                                       types.Object                 `tfsdk:"signing"`
	SloBinding                                    types.String                 `tfsdk:"slo_binding"`
	SloEndpoint                                   types.String                 `tfsdk:"slo_endpoint"`
	SloResponseEndpoint                           types.String                 `tfsdk:"slo_response_endpoint"`
	SloWindow                                     types.Int32                  `tfsdk:"slo_window"`
	SpEncryption                                  types.Object                 `tfsdk:"sp_encryption"`
	SpEntityId                                    types.String                 `tfsdk:"sp_entity_id"`
	SpVerification                                types.Object                 `tfsdk:"sp_verification"`
	SupportUnsignedRequestObject                  types.Bool                   `tfsdk:"support_unsigned_request_object"`
	Tags                                          types.List                   `tfsdk:"tags"`
	TargetLinkUri                                 types.String                 `tfsdk:"target_link_uri"`
	Template                                      types.Object                 `tfsdk:"template"`
	TokenEndpointAuthMethod                       types.String                 `tfsdk:"token_endpoint_auth_method"`
	Type                                          types.String                 `tfsdk:"type"`
}

func (r *applicationv2Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Resource to create and manage an application.",
		Attributes: map[string]schema.Attribute{
			"access_control": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"group": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Required: true,
										},
									},
								},
								Required:    true,
								Description: "A set that specifies the group IDs for the groups the actor must belong to for access to the application.",
							},
							"type": schema.StringAttribute{
								Required:            true,
								Description:         "A string that specifies the group type required to access the application. Options are \"ANY_GROUP\" (the actor must belong to at least one group listed in the \"groups\" property) and \"ALL_GROUPS\" (the actor must belong to all groups listed in the \"groups\" property).",
								MarkdownDescription: "A string that specifies the group type required to access the application. Options are `ANY_GROUP` (the actor must belong to at least one group listed in the `groups` property) and `ALL_GROUPS` (the actor must belong to all groups listed in the `groups` property).",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ANY_GROUP",
										"ALL_GROUPS",
									),
								},
							},
						},
						Optional: true,
					},
					"role": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"type": schema.StringAttribute{
								Required:    true,
								Description: "A string that specifies the user role required to access the application. Options are ADMIN_USERS_ONLY. A user is an admin user if the user has one or more of the following roles Organization Admin, Environment Admin, Identity Data Admin, or Client Application Developer.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ADMIN_USERS_ONLY",
									),
								},
							},
						},
						Optional: true,
					},
				},
				Optional: true,
			},
			"acs_urls": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "A string that specifies the Assertion Consumer Service URLs. The first URL in the list is used as default (there must be at least one URL). This is a required property.",
			},
			"additional_refresh_token_replay_protection_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "When set to \"true\" (the default), if you attempt to reuse the refresh token, the authorization server immediately revokes the reused refresh token, as well as all descendant tokens. Setting this to null equates to a \"false\" setting. The default value is \"true\".",
				MarkdownDescription: "When set to `true` (the default), if you attempt to reuse the refresh token, the authorization server immediately revokes the reused refresh token, as well as all descendant tokens. Setting this to null equates to a `false` setting. The default value is `true`.",
			},
			"allow_wildcard_in_redirect_uris": schema.BoolAttribute{
				Optional:    true,
				Description: "A boolean to specify whether wildcards are allowed in redirect URIs. For more information, see [Wildcards in Redirect URIs](https://docs.pingidentity.com/csh?context=p1_c_wildcard_redirect_uri).",
			},
			"assertion_duration": schema.Int32Attribute{
				Optional:    true,
				Description: "An integer that specifies the assertion validity duration in seconds. This is a required property.",
			},
			"assertion_signed": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A boolean that specifies whether the SAML assertion itself should be signed. The default value is \"true\". The default value is \"true\".",
				MarkdownDescription: "A boolean that specifies whether the SAML assertion itself should be signed. The default value is `true`. The default value is `true`.",
			},
			"assign_actor_roles": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Description: "A boolean that specifies whether the permissions service should assign default roles to the application. This property is set only on the POST request. The property is ignored when included in a PUT request. The default value is \"false\".",
			},
			"bundle_id": schema.StringAttribute{
				Optional:            true,
				Description:         "**Deprecation Notice** This field is deprecated and will be removed in a future release. Use \"mobile.bundleId\" instead.  A string that specifies the bundle associated with the application, for push notifications in native apps. The value of the bundleId property is unique per environment, and once defined, is immutable.\n",
				MarkdownDescription: "**Deprecation Notice** This field is deprecated and will be removed in a future release. Use `mobile.bundleId` instead.  A string that specifies the bundle associated with the application, for push notifications in native apps. The value of the bundleId property is unique per environment, and once defined, is immutable.\n",
				DeprecationMessage:  "This attribute is deprecated.",
			},
			"cors_settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"behavior": schema.StringAttribute{
						Required:            true,
						Description:         "The behavior of CORS for the application. \"ALLOWS_NO_ORIGINS\" rejects all CORS requests.  \"ALLOW_SPECIFIC_ORIGINS\" rejects all CORS requests except those listed in \"corsSettings.origins\". Options are \"ALLOW_NO_ORIGINS\", \"ALLOW_SPECIFIC_ORIGINS\".",
						MarkdownDescription: "The behavior of CORS for the application. `ALLOWS_NO_ORIGINS` rejects all CORS requests.  `ALLOW_SPECIFIC_ORIGINS` rejects all CORS requests except those listed in `corsSettings.origins`. Options are `ALLOW_NO_ORIGINS`, `ALLOW_SPECIFIC_ORIGINS`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ALLOW_NO_ORIGINS",
								"ALLOW_SPECIFIC_ORIGINS",
							),
						},
					},
					"origins": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Must be non-empty when \"corsSettings.behavior\" is \"ALLOW_SPECIFIC_ORIGINS\" and must be omitted or empty when \"corsSettings.behavior\" is \"ALLOW_NO_ORIGINS\".  Limited to 20 values.  Values are the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value is an \"http\" or \"https\" URL without a path.  The host may be a domain name (including \"localhost\"), or an IPv4 address.  Subdomains may use the wildcard (*) to match any string.",
						MarkdownDescription: "Must be non-empty when `corsSettings.behavior` is `ALLOW_SPECIFIC_ORIGINS` and must be omitted or empty when `corsSettings.behavior` is `ALLOW_NO_ORIGINS`.  Limited to 20 values.  Values are the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value is an `http` or `https` URL without a path.  The host may be a domain name (including `localhost`), or an IPv4 address.  Subdomains may use the wildcard (*) to match any string.",
						Validators: []validator.List{
							listvalidator.SizeAtMost(20),
						},
					},
				},
				Optional:            true,
				Description:         "Allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application.  If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. \"/as/authorize\" and \"/as/token\").  This is legacy behavior, and it is recommended that applications migrate to include specific \"corsSettings\".",
				MarkdownDescription: "Allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application.  If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. `/as/authorize` and `/as/token`).  This is legacy behavior, and it is recommended that applications migrate to include specific `corsSettings`.",
			},
			"default_target_url": schema.StringAttribute{
				Optional:    true,
				Description: "This is used as the RelayState parameter by the IdP to deep link into the application after authentication. This value can be overridden by the applicationUrl query parameter for GET Identity Provider Initiated SSO. Although both of these parameters are generally URLs, because they are used as deep links, this is not enforced. If neither defaultTargetUrl nor applicationUrl is specified during a SAML authentication flow, no RelayState value is supplied to the application. The defaultTargetUrl (or the applicationUrl) value is passed to the SAML application's ACS URL as a separate RelayState key value (not within the SAMLResponse key value).",
			},
			"description": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the description of the application.",
			},
			"device_custom_verification_uri": schema.StringAttribute{
				Optional:            true,
				Description:         "A string that specifies an optional custom verification URI that is returned for the \"/device_authorization\" endpoint.",
				MarkdownDescription: "A string that specifies an optional custom verification URI that is returned for the `/device_authorization` endpoint.",
			},
			"device_path_id": schema.StringAttribute{
				Optional:            true,
				Description:         "A string that specifies a unique identifier within an environment for a device authorization grant flow to provide a short identifier to the application. This property is ignored when the \"deviceCustomVerificationUri\" property is configured. The string can contain any letters, numbers, and some special characters (regex \"a-zA-Z0-9_-\"). It can have a length of no more than 50 characters (\"min\"/\"max\"=\"1\"/\"50\").",
				MarkdownDescription: "A string that specifies a unique identifier within an environment for a device authorization grant flow to provide a short identifier to the application. This property is ignored when the `deviceCustomVerificationUri` property is configured. The string can contain any letters, numbers, and some special characters (regex `a-zA-Z0-9_-`). It can have a length of no more than 50 characters (`min`/`max`=`1`/`50`).",
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_-]{1,50}$"), ""),
				},
			},
			"device_polling_interval": schema.Int32Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "An integer that specifies the frequency (in seconds) for the client to poll the \"/as/token\" endpoint. This property is required only for applications in which the \"grantTypes\" property is set to \"device_code\". The default value is \"5\" seconds. It can have a value of no more than \"60\" seconds (\"min\"/\"max\"=\"1\"/\"60\"). The default value is \"5\".",
				MarkdownDescription: "An integer that specifies the frequency (in seconds) for the client to poll the `/as/token` endpoint. This property is required only for applications in which the `grantTypes` property is set to `device_code`. The default value is `5` seconds. It can have a value of no more than `60` seconds (`min`/`max`=`1`/`60`). The default value is `5`.",
				Validators: []validator.Int32{
					int32validator.Between(1, 60),
				},
			},
			"device_timeout": schema.Int32Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "An integer that specifies the length of time (in seconds) that the \"userCode\" and \"deviceCode\" returned by the \"/device_authorization\" endpoint are valid. This property is required only for applications in which the \"grantTypes\" property is set to \"device_code\". The default value is \"600\" seconds. It can have a value of no more than \"3600\" seconds (\"min\"/\"max\"=\"1\"/\"3600\"). The default value is \"600\".",
				MarkdownDescription: "An integer that specifies the length of time (in seconds) that the `userCode` and `deviceCode` returned by the `/device_authorization` endpoint are valid. This property is required only for applications in which the `grantTypes` property is set to `device_code`. The default value is `600` seconds. It can have a value of no more than `3600` seconds (`min`/`max`=`1`/`3600`). The default value is `600`.",
				Validators: []validator.Int32{
					int32validator.Between(1, 3600),
				},
			},
			"enable_requested_authn_context": schema.BoolAttribute{
				Optional:            true,
				Description:         "Indicates whether \"requestedAuthnContext\" is taken into account in policy decision-making during authentication.",
				MarkdownDescription: "Indicates whether `requestedAuthnContext` is taken into account in policy decision-making during authentication.",
			},
			"enabled": schema.BoolAttribute{
				Required:    true,
				Description: "A string that specifies the current enabled state of the application. Options are ENABLED or DISABLED.",
			},
			"environment_id": framework.Attr_LinkID(
				framework.SchemaAttributeDescriptionFromMarkdown("The ID of the environment to create and manage the application in."),
			),
			"grant_types": schema.SetAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "A string that specifies the grant type for the authorization request. This is a required property. Options are AUTHORIZATION_CODE, IMPLICIT, REFRESH_TOKEN, CLIENT_CREDENTIALS.",
				Validators: []validator.Set{
					setvalidator.ValueStringsAre(stringvalidator.OneOf(
						"AUTHORIZATION_CODE",
						"IMPLICIT",
						"REFRESH_TOKEN",
						"CLIENT_CREDENTIALS",
						"DEVICE_CODE",
					)),
				},
			},
			"hidden_from_app_portal": schema.BoolAttribute{
				Optional:    true,
				Computed:    true,
				Description: "A boolean to specify whether the application is hidden in the application portal despite the configured group access policy. The default value is `false`.",
				Default:     booldefault.StaticBool(false),
			},
			"home_page_url": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the custom home page URL for the application.",
			},
			"icon": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"href": schema.StringAttribute{
						Required: true,
					},
					"id": schema.StringAttribute{
						Required: true,
					},
				},
				Optional:    true,
				Description: "The HREF and the ID for the application icon.",
			},
			"id": framework.Attr_ID(),
			"idp_signing": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"algorithm": schema.StringAttribute{
						Optional:            true,
						Description:         "Specifies the signature algorithm of the key. For RSA keys, options are \"SHA256withRSA\", \"SHA384withRSA\" and \"SHA512withRSA\". For elliptical curve (EC) keys, options are \"SHA256withECDSA\", \"SHA384withECDSA\", and \"SHA512withECDSA\". Options are \"SHA256withRSA\", \"SHA384withRSA\", \"SHA512withRSA\", \"SHA256withECDSA\", \"SHA384withECDSA\", \"SHA512withECDSA\".",
						MarkdownDescription: "Specifies the signature algorithm of the key. For RSA keys, options are `SHA256withRSA`, `SHA384withRSA` and `SHA512withRSA`. For elliptical curve (EC) keys, options are `SHA256withECDSA`, `SHA384withECDSA`, and `SHA512withECDSA`. Options are `SHA256withRSA`, `SHA384withRSA`, `SHA512withRSA`, `SHA256withECDSA`, `SHA384withECDSA`, `SHA512withECDSA`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SHA256withRSA",
								"SHA384withRSA",
								"SHA512withRSA",
								"SHA256withECDSA",
								"SHA384withECDSA",
								"SHA512withECDSA",
							),
						},
					},
					"key": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "A string that specifies the certificate to be used by the identity provider to sign assertions and responses. If this property is omitted, the default signing certificate for the environment is used.",
							},
						},
						Required: true,
					},
				},
				Optional: true,
			},
			"initiate_login_uri": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the URI to use for third-parties to begin the sign-on process for the application. If specified, PingOne redirects users to this URI to initiate SSO to PingOne. The application is responsible for implementing the relevant OIDC flow when the initiate login URI is requested. This property is required if you want the application to appear in the PingOne Application Portal. See the OIDC specification section of [Initiating Login from a Third Party](https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin) for more information.",
			},
			"jwks": schema.StringAttribute{
				Optional:            true,
				Description:         "A JWKS string that validates the signature of signed JWTs for applications that use the \"PRIVATE_KEY_JWT\" option for the \"tokenEndpointAuthMethod\". This property is required when \"tokenEndpointAuthMethod\" is \"PRIVATE_KEY_JWT\" and the \"jwksUrl\" property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional \"request\" property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the \"jwksUrl\" property is empty. For more infornmation about signing the request property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).",
				MarkdownDescription: "A JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `tokenEndpointAuthMethod`. This property is required when `tokenEndpointAuthMethod` is `PRIVATE_KEY_JWT` and the `jwksUrl` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwksUrl` property is empty. For more infornmation about signing the request property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).",
			},
			"jwks_url": schema.StringAttribute{
				Optional:            true,
				Description:         "A URL (supports \"https://\" only) that provides access to a JWKS string that validates the signature of signed JWTs for applications that use the \"PRIVATE_KEY_JWT\" option for the \"tokenEndpointAuthMethod\". This property is required when \"tokenEndpointAuthMethod\" is \"PRIVATE_KEY_JWT\" and the \"jwks\" property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional \"request\" property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the \"jwks\" property is empty. For more infornmation about signing the request property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).",
				MarkdownDescription: "A URL (supports `https://` only) that provides access to a JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `tokenEndpointAuthMethod`. This property is required when `tokenEndpointAuthMethod` is `PRIVATE_KEY_JWT` and the `jwks` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwks` property is empty. For more infornmation about signing the request property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).",
			},
			"kerberos": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"key": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The unique identifier for the Kerberos key.",
							},
						},
						Required:    true,
						Description: "A Relationship object containing the certificate issuer (root CA).",
					},
				},
				Optional:    true,
				Description: "Object containing Kerberos settings",
			},
			"login_page_url": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the custom login page URL for the application. If you set the loginPageUrl property for applications in an environment that sets a custom domain, the URL should include the top-level domain and at least one additional domain level. Warning To avoid issues with third-party cookies in some browsers, a custom domain must be used, giving your PingOne environment the same parent domain as your authentication application. For more information about custom domains, see Custom domains.",
			},
			"mobile": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bundle_id": schema.StringAttribute{
						Optional:    true,
						Description: "A string that specifies the bundle associated with the application, for push notifications in native apps. The value of the bundleId property is unique per environment, and once defined, is immutable.  this setting overrides the top-level bundleId field",
					},
					"huawei_app_id": schema.StringAttribute{
						Optional:            true,
						Description:         "The unique identifier for the app on the device and in the Huawei Mobile Service AppGallery. The value of the \"huaweiAppId\" property is unique per environment, and once defined, is immutable. Used only for applications for the Huawei ecosystem.",
						MarkdownDescription: "The unique identifier for the app on the device and in the Huawei Mobile Service AppGallery. The value of the `huaweiAppId` property is unique per environment, and once defined, is immutable. Used only for applications for the Huawei ecosystem.",
					},
					"huawei_package_name": schema.StringAttribute{
						Optional:            true,
						Description:         "The package name associated with the application, for push notifications in native apps. The value of the \"huaweiPackageName\" property is unique per environment, and once defined, is immutable. Used only for applications for the Huawei ecosystem.",
						MarkdownDescription: "The package name associated with the application, for push notifications in native apps. The value of the `huaweiPackageName` property is unique per environment, and once defined, is immutable. Used only for applications for the Huawei ecosystem.",
					},
					"integrity_detection": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cache_duration": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"amount": schema.Int32Attribute{
										Optional:    true,
										Description: "An integer that specifies the number of minutes or hours that specify the duration between successful integrity detection calls. Every attestation request entails a certain time tradeoff. You can choose to cache successful integrity detection calls for a predefined duration, between a minimum of 1 minute and a maximum of 48 hours. If mobile.integrityDetection.mode is ENABLED, the cache duration must be set.",
									},
									"units": schema.StringAttribute{
										Optional:            true,
										Description:         "Options are \"MINUTES\", \"HOURS\".",
										MarkdownDescription: "Options are `MINUTES`, `HOURS`.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"MINUTES",
												"HOURS",
											),
										},
									},
								},
								Optional: true,
							},
							"excluded_platforms": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "You can enable device integrity checking separately for Android and iOS by setting \"mobile.integrityDetection.mode\" to \"ENABLED\" and then using \"mobile.integrityDetection.excludedPlatforms\" to specify the OS where you do not want to use device integrity checking. The values to use are \"GOOGLE\" and \"IOS\" (all upper case). Note that this is implemented as an array even though currently you can only include a single value.  If \"GOOGLE\" is not included as a value, \"googlePlay\" is required to be set. Options are \"IOS\", \"GOOGLE\".",
								MarkdownDescription: "You can enable device integrity checking separately for Android and iOS by setting `mobile.integrityDetection.mode` to `ENABLED` and then using `mobile.integrityDetection.excludedPlatforms` to specify the OS where you do not want to use device integrity checking. The values to use are `GOOGLE` and `IOS` (all upper case). Note that this is implemented as an array even though currently you can only include a single value.  If `GOOGLE` is not included as a value, `googlePlay` is required to be set. Options are `IOS`, `GOOGLE`.",
								Validators: []validator.List{
									listvalidator.ValueStringsAre(stringvalidator.OneOf(
										"IOS",
										"GOOGLE",
									)),
									listvalidator.SizeAtMost(1),
								},
							},
							"google_play": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"decryption_key": schema.StringAttribute{
										Optional:            true,
										Sensitive:           true,
										Description:         "Play Integrity verdict decryption key from your Google Play Services account. This parameter must be provided if you have set \"mobile.integrityDetection.googlePlay.verificationType\" to \"INTERNAL\".",
										MarkdownDescription: "Play Integrity verdict decryption key from your Google Play Services account. This parameter must be provided if you have set `mobile.integrityDetection.googlePlay.verificationType` to `INTERNAL`.",
									},
									"service_account_credentials": schema.StringAttribute{
										Optional:            true,
										Sensitive:           true,
										Description:         "Contents of the JSON file that represents your Service Account Credentials. This parameter must be provided if you have set \"mobile.integrityDetection.googlePlay.verificationType\" to \"GOOGLE\".",
										MarkdownDescription: "Contents of the JSON file that represents your Service Account Credentials. This parameter must be provided if you have set `mobile.integrityDetection.googlePlay.verificationType` to `GOOGLE`.",
									},
									"verification_key": schema.StringAttribute{
										Optional:            true,
										Sensitive:           true,
										Description:         "Play Integrity verdict signature verification key from your Google Play Services account. This parameter must be provided if you have set \"mobile.integrityDetection.googlePlay.verificationType\" to \"INTERNAL\".",
										MarkdownDescription: "Play Integrity verdict signature verification key from your Google Play Services account. This parameter must be provided if you have set `mobile.integrityDetection.googlePlay.verificationType` to `INTERNAL`.",
									},
									"verification_type": schema.StringAttribute{
										Optional:            true,
										Description:         "The type of verification that should be used. The possible values are \"GOOGLE\" and \"INTERNAL\". Using internal verification will not count against your Google API call quota. The value you select for \"verificationType\" determines what other parameters you must provide. When set to \"GOOGLE\", you must provide \"serviceAccountCredentials\". When set to \"INTERNAL\", you must provide \"decryptionKey\" and \"verificationKey\". Options are \"GOOGLE\", \"INTERNAL\".",
										MarkdownDescription: "The type of verification that should be used. The possible values are `GOOGLE` and `INTERNAL`. Using internal verification will not count against your Google API call quota. The value you select for `verificationType` determines what other parameters you must provide. When set to `GOOGLE`, you must provide `serviceAccountCredentials`. When set to `INTERNAL`, you must provide `decryptionKey` and `verificationKey`. Options are `GOOGLE`, `INTERNAL`.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"GOOGLE",
												"INTERNAL",
											),
										},
									},
								},
								Optional:            true,
								Description:         "Object that contains the credentials required for using Google's Play Integrity API for integrity detection.  Required if \"excludedPlatforms\" does not contain \"GOOGLE\".",
								MarkdownDescription: "Object that contains the credentials required for using Google's Play Integrity API for integrity detection.  Required if `excludedPlatforms` does not contain `GOOGLE`.",
							},
							"mode": schema.StringAttribute{
								Optional:            true,
								Description:         "A string that specifies whether device integrity detection takes place on mobile devices, for the application's enrollment and authentication events ENABLED, DISABLED. Options are \"ENABLED\", \"DISABLED\".",
								MarkdownDescription: "A string that specifies whether device integrity detection takes place on mobile devices, for the application's enrollment and authentication events ENABLED, DISABLED. Options are `ENABLED`, `DISABLED`.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ENABLED",
										"DISABLED",
									),
								},
							},
						},
						Optional: true,
					},
					"package_name": schema.StringAttribute{
						Optional:    true,
						Description: "A string that specifies the package name associated with the application, for push notifications in native apps. The value of the mobile.packageName property is unique per environment, and once defined, is immutable.  this setting overrides the top-level packageName field.",
					},
					"passcode_refresh_duration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"duration": schema.Int32Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "The amount of time a passcode should be displayed before being replaced with a new passcode - must be between 30 and 60. The default value is \"30\".",
								MarkdownDescription: "The amount of time a passcode should be displayed before being replaced with a new passcode - must be between 30 and 60. The default value is `30`.",
								Validators: []validator.Int32{
									int32validator.Between(30, 60),
								},
							},
							"time_unit": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The type of time unit for \"mobile.passcodeRefreshDuration.duration\".  Must be SECONDS. Options are \"SECONDS\". The default value is \"SECONDS\".",
								MarkdownDescription: "The type of time unit for `mobile.passcodeRefreshDuration.duration`.  Must be SECONDS. Options are `SECONDS`. The default value is `SECONDS`.",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"SECONDS",
									),
								},
							},
						},
						Optional: true,
					},
					"uri_prefix": schema.StringAttribute{
						Optional:            true,
						Description:         "A string that specifies a URI prefix that enables direct triggering of the mobile application when scanning a QR code. The URI prefix can be set to a universal link with a valid value (which can be a URL address that starts with \"HTTP://\" or \"HTTPS://\", such as \"https://www.acme.com\"), or an app schema, which is just a string and requires no special validation.",
						MarkdownDescription: "A string that specifies a URI prefix that enables direct triggering of the mobile application when scanning a QR code. The URI prefix can be set to a universal link with a valid value (which can be a URL address that starts with `HTTP://` or `HTTPS://`, such as `https://www.acme.com`), or an app schema, which is just a string and requires no special validation.",
					},
				},
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: "A string that specifies the name of the application. This is a required property.",
			},
			"name_id_format": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the format of the Subject NameID attibute in the SAML assertion",
			},
			"package_name": schema.StringAttribute{
				Optional:            true,
				Description:         "**Deprecation Notice** This field is deprecated and will be removed in a future release. Use \"mobile.packageName\" instead.  A string that specifies the package name associated with the application, for push notifications in native apps. The value of the mobile.packageName property is unique per environment, and once defined, is immutable.\n",
				MarkdownDescription: "**Deprecation Notice** This field is deprecated and will be removed in a future release. Use `mobile.packageName` instead.  A string that specifies the package name associated with the application, for push notifications in native apps. The value of the mobile.packageName property is unique per environment, and once defined, is immutable.\n",
				DeprecationMessage:  "This attribute is deprecated.",
			},
			"par_requirement": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether pushed authorization requests (PAR) are required. Options are \"REQUIRED\" and \"OPTIONAL\". The default value is \"OPTIONAL\". The default value is \"OPTIONAL\".",
				MarkdownDescription: "Whether pushed authorization requests (PAR) are required. Options are `REQUIRED` and `OPTIONAL`. The default value is `OPTIONAL`. The default value is `OPTIONAL`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"REQUIRED",
						"OPTIONAL",
					),
				},
			},
			"par_timeout": schema.Int32Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "PAR timeout in seconds. Must be between \"1\" and \"600\". The default value is \"60\". The default value is \"60\".",
				MarkdownDescription: "PAR timeout in seconds. Must be between `1` and `600`. The default value is `60`. The default value is `60`.",
				Validators: []validator.Int32{
					int32validator.Between(1, 600),
				},
			},
			"pkce_enforcement": schema.StringAttribute{
				Optional:    true,
				Computed:    true,
				Description: "A string that specifies how PKCE request parameters are handled on the authorize request. Options are OPTIONAL PKCE code_challenge is optional and any code challenge method is acceptable. REQUIRED PKCE code_challenge is required and any code challenge method is acceptable. S256_REQUIRED PKCE code_challege is required and the code_challenge_method must be S256. Defaults to `OPTIONAL`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"OPTIONAL",
						"REQUIRED",
						"S256_REQUIRED",
					),
				},
			},
			"post_logout_redirect_uris": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "A string that specifies the URLs that the browser can be redirected to after logout.",
			},
			"protocol": schema.StringAttribute{
				Required:            true,
				Description:         "A string that specifies the protocol for the Application. Options are \"OPENID_CONNECT\", \"SAML\", \"WS-FED\", \"EXTERNAL_LINK\".",
				MarkdownDescription: "A string that specifies the protocol for the Application. Options are `OPENID_CONNECT`, `SAML`, `WS-FED`, `EXTERNAL_LINK`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"OPENID_CONNECT",
						"SAML",
						"WS-FED",
						"EXTERNAL_LINK",
					),
				},
			},
			"redirect_uris": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "A string that specifies the callback URI for the authentication response.",
			},
			"refresh_token_duration": schema.Int32Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "An integer that specifies the lifetime in seconds of the refresh token. If a value is not provided, the default value is 2592000, or 30 days. Valid values are between 60 and 2147483647. If the \"refreshTokenRollingDuration\" property is specified for the application, then this property must be less than or equal to the value of \"refreshTokenRollingDuration\". After this property is set, the value cannot be nullified. This value is used to generate the value for the exp claim when minting a new refresh token. The default value is \"2592000\".",
				MarkdownDescription: "An integer that specifies the lifetime in seconds of the refresh token. If a value is not provided, the default value is 2592000, or 30 days. Valid values are between 60 and 2147483647. If the `refreshTokenRollingDuration` property is specified for the application, then this property must be less than or equal to the value of `refreshTokenRollingDuration`. After this property is set, the value cannot be nullified. This value is used to generate the value for the exp claim when minting a new refresh token. The default value is `2592000`.",
				Validators: []validator.Int32{
					int32validator.Between(60, 2147483647),
				},
			},
			"refresh_token_rolling_duration": schema.Int32Attribute{
				Optional:    true,
				Description: "An integer that specifies the number of seconds a refresh token can be exchanged before re-authentication is required. If a value is not provided, the refresh token is valid forever. Valid values are between 60 and 2147483647. After this property is set, the value cannot be nullified. This value is used to generate the value for the exp claim when minting a new refresh token.",
				Validators: []validator.Int32{
					int32validator.AtMost(2147483647),
				},
			},
			"refresh_token_rolling_grace_period_duration": schema.Int32Attribute{
				Optional:    true,
				Description: "The number of seconds that a refresh token may be reused after having been exchanged for a new set of tokens. This is useful in the case of network errors on the client. Valid values are between 0 and 86400 seconds. Null is treated the same as 0.",
				Validators: []validator.Int32{
					int32validator.AtMost(86400),
				},
			},
			"require_signed_request_object": schema.BoolAttribute{
				Optional:            true,
				Description:         "Indicates that the Java Web Token (JWT) for the [request query](https://openid.net/specs/openid-connect-core-1_0.html#RequestObject) parameter is required to be signed. If \"false\" or null (default), a signed request object is not required. Both \"supportUnsignedRequestObject\" and this property cannot be set to \"true\".",
				MarkdownDescription: "Indicates that the Java Web Token (JWT) for the [request query](https://openid.net/specs/openid-connect-core-1_0.html#RequestObject) parameter is required to be signed. If `false` or null (default), a signed request object is not required. Both `supportUnsignedRequestObject` and this property cannot be set to `true`.",
			},
			"response_signed": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A boolean that specifies whether the SAML assertion response itself should be signed. The default value is \"false\". The default value is \"false\".",
				MarkdownDescription: "A boolean that specifies whether the SAML assertion response itself should be signed. The default value is `false`. The default value is `false`.",
			},
			"response_types": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "The code or token type returned by an authorization request. Options are \"TOKEN\", \"ID_TOKEN\", and \"CODE\". For hybrid flows that specify \"CODE\" with \"TOKEN\" or \"ID_TOKEN\", see [Hybrid grant type](https://apidocs.pingidentity.com/pingone/main/v1/api/#hybrid-grant-type).",
				MarkdownDescription: "The code or token type returned by an authorization request. Options are `TOKEN`, `ID_TOKEN`, and `CODE`. For hybrid flows that specify `CODE` with `TOKEN` or `ID_TOKEN`, see [Hybrid grant type](https://apidocs.pingidentity.com/pingone/main/v1/api/#hybrid-grant-type).",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(stringvalidator.OneOf(
						"TOKEN",
						"ID_TOKEN",
						"CODE",
					)),
				},
			},
			"session_not_on_or_after_duration": schema.Int32Attribute{
				Optional:            true,
				Description:         "Update this value if the SAML application requires a different \"SessionNotOnOrAfter\" attribute value within the \"AuthnStatement\" element than the \"NotOnOrAfter\" value set by the \"assertionDuration\" property.",
				MarkdownDescription: "Update this value if the SAML application requires a different `SessionNotOnOrAfter` attribute value within the `AuthnStatement` element than the `NotOnOrAfter` value set by the `assertionDuration` property.",
			},
			"signing": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"key_rotation_policy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:            true,
								Description:         "Reference to a KRP ID from certificate management. This property is required if \"signing\" is set.",
								MarkdownDescription: "Reference to a KRP ID from certificate management. This property is required if `signing` is set.",
							},
						},
						Required:            true,
						Description:         "Contains the Key Rotation Policy (KRP) ID. This property is required if \"signing\" is set.",
						MarkdownDescription: "Contains the Key Rotation Policy (KRP) ID. This property is required if `signing` is set.",
					},
				},
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.UseStateForUnknown(),
				},
				Description:         "Configuration for the signing key. If absent, application tokens will be signed and verified by the PingOne default key at runtime. This property only applies to OIDC applications of type \"WEB_APP\", \"NATIVE_APP\", \"SINGLE_PAGE_APP\", and \"CUSTOM_APP\".",
				MarkdownDescription: "Configuration for the signing key. If absent, application tokens will be signed and verified by the PingOne default key at runtime. This property only applies to OIDC applications of type `WEB_APP`, `NATIVE_APP`, `SINGLE_PAGE_APP`, and `CUSTOM_APP`.",
			},
			"slo_binding": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A string that specifies the binding protocol to be used for the logout response. Options are HTTP_REDIRECT or HTTP_POST. The default is HTTP_POST; existing configurations with no data default to HTTP_POST. The default value is \"HTTP_POST\".",
				MarkdownDescription: "A string that specifies the binding protocol to be used for the logout response. Options are HTTP_REDIRECT or HTTP_POST. The default is HTTP_POST; existing configurations with no data default to HTTP_POST. The default value is `HTTP_POST`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"HTTP_REDIRECT",
						"HTTP_POST",
					),
				},
			},
			"slo_endpoint": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the logout endpoint URL. This is an optional property. However, if a sloEndpoint logout endpoint URL is not defined, logout actions result in an error.",
			},
			"slo_response_endpoint": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the endpoint URL to submit the logout response. If a value is not provided, the sloEndpoint property value is used to submit SLO response.",
			},
			"slo_window": schema.Int32Attribute{
				Optional:            true,
				Description:         "Defines how long PingOne can exchange logout messages with the application, specifically a \"LogoutRequest\" from the application, since the initial request. PingOne can also send a \"LogoutRequest\" to the application when a single logout is initiated by the user from other session participants, such as an application or identity provider. This setting is per application. The SLO logout is separate from the user session logout that revokes all tokens.",
				MarkdownDescription: "Defines how long PingOne can exchange logout messages with the application, specifically a `LogoutRequest` from the application, since the initial request. PingOne can also send a `LogoutRequest` to the application when a single logout is initiated by the user from other session participants, such as an application or identity provider. This setting is per application. The SLO logout is separate from the user session logout that revokes all tokens.",
			},
			"sp_encryption": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"algorithm": schema.StringAttribute{
						Required:            true,
						Description:         "The algorithm to use when encrypting assertions. Options are \"AES_128\", \"AES_256\", \"TRIPLEDES\".",
						MarkdownDescription: "The algorithm to use when encrypting assertions. Options are `AES_128`, `AES_256`, `TRIPLEDES`.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"AES_128",
								"AES_256",
								"TRIPLEDES",
							),
						},
					},
					"certificate": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "Specify the unique identifier of the encryption public certificate that has been uploaded to PingOne.",
							},
						},
						Required:    true,
						Description: "Contains the ID of the encryption public certificate that has been uploaded to PingOne.",
					},
				},
				Optional:    true,
				Description: "Enables PingOne to encrypt SAML assertions to be sent to the application. Assertions are not encrypted by default.",
			},
			"sp_entity_id": schema.StringAttribute{
				Optional:    true,
				Description: "A string that specifies the service provider entity ID used to lookup the application. This is a required property and is unique within the environment.",
			},
			"sp_verification": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"authn_request_signed": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the Authn Request signing should be enforced. Default is \"false\". The default value is \"false\".",
						MarkdownDescription: "Whether the Authn Request signing should be enforced. Default is `false`. The default value is `false`.",
					},
					"certificates": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Required:    true,
									Description: "An array that specifies the certificate IDs used to verify the service provider signature.",
								},
							},
						},
						Required: true,
					},
				},
				Optional: true,
			},
			"support_unsigned_request_object": schema.BoolAttribute{
				Optional:    true,
				Description: "A boolean that specifies whether the [request query](https://openid.net/specs/openid-connect-core-1_0.html#RequestObject) parameter JWT is allowed to be unsigned. If false or null (default), an unsigned request object is not allowed.",
			},
			"tags": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "An array that specifies the list of labels associated with the application. Options are \"PING_FED_CONNECTION_INTEGRATION\".  Only applicable for creating worker applications.",
				MarkdownDescription: "An array that specifies the list of labels associated with the application. Options are `PING_FED_CONNECTION_INTEGRATION`.  Only applicable for creating worker applications.",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(stringvalidator.OneOf(
						"PING_FED_CONNECTION_INTEGRATION",
					)),
				},
			},
			"target_link_uri": schema.StringAttribute{
				Optional:            true,
				Description:         "The URI for the application. If specified, PingOne will redirect application users to this URI after a user is authenticated. In the PingOne admin console, this becomes the value of the \"target_link_uri\" parameter used for the Initiate Single Sign-On URL field.",
				MarkdownDescription: "The URI for the application. If specified, PingOne will redirect application users to this URI after a user is authenticated. In the PingOne admin console, this becomes the value of the `target_link_uri` parameter used for the Initiate Single Sign-On URL field.",
			},
			"template": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"configuration": schema.MapAttribute{
						ElementType: types.StringType,
						Required:    true,
						Description: "Contains a key/value map of the parameters required by the integration in Integration Catalog.",
					},
					"integration": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The UUID of the integration in Integration Catalog.",
							},
						},
						Required: true,
					},
					"version": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.StringAttribute{
								Required:    true,
								Description: "The UUID of the integration version in Integration Catalog.",
							},
						},
						Required: true,
					},
				},
				Optional: true,
			},
			"token_endpoint_auth_method": schema.StringAttribute{
				Optional:            true,
				Description:         "A string that specifies the client authentication methods supported by the token endpoint. Options are \"NONE\", \"CLIENT_SECRET_BASIC\", \"CLIENT_SECRET_POST\", \"PRIVATE_KEY_JWT\", \"CLIENT_SECRET_JWT\".",
				MarkdownDescription: "A string that specifies the client authentication methods supported by the token endpoint. Options are `NONE`, `CLIENT_SECRET_BASIC`, `CLIENT_SECRET_POST`, `PRIVATE_KEY_JWT`, `CLIENT_SECRET_JWT`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"NONE",
						"CLIENT_SECRET_BASIC",
						"CLIENT_SECRET_POST",
						"PRIVATE_KEY_JWT",
						"CLIENT_SECRET_JWT",
					),
				},
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "A string that specifies the type associated with the application. This is a required property. Options are \"WEB_APP\", \"NATIVE_APP\", \"SINGLE_PAGE_APP\", \"WORKER\", \"SERVICE\", \"CUSTOM_APP\", \"PING_ONE_SELF_SERVICE\", \"PING_ONE_ADMIN_CONSOLE\", \"PING_ONE_PORTAL\", \"TEMPLATE_APP\", \"PORTAL_LINK_APP\".",
				MarkdownDescription: "A string that specifies the type associated with the application. This is a required property. Options are `WEB_APP`, `NATIVE_APP`, `SINGLE_PAGE_APP`, `WORKER`, `SERVICE`, `CUSTOM_APP`, `PING_ONE_SELF_SERVICE`, `PING_ONE_ADMIN_CONSOLE`, `PING_ONE_PORTAL`, `TEMPLATE_APP`, `PORTAL_LINK_APP`.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"WEB_APP",
						"NATIVE_APP",
						"SINGLE_PAGE_APP",
						"WORKER",
						"SERVICE",
						"CUSTOM_APP",
						"PING_ONE_SELF_SERVICE",
						"PING_ONE_ADMIN_CONSOLE",
						"PING_ONE_PORTAL",
						"TEMPLATE_APP",
						"PORTAL_LINK_APP",
					),
				},
			},
		},
	}
}

func (r *applicationv2Resource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var config *applicationv2ResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	if config == nil {
		return
	}

	// Verify that the discriminator attribute has a value
	if config.Protocol.IsUnknown() || config.Protocol.IsNull() {
		return
	}

	// Ensure each configured attribute is valid for the type of application
	if !config.AcsUrls.IsNull() && !config.AcsUrls.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("acs_urls"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.AdditionalRefreshTokenReplayProtectionEnabled.IsNull() && !config.AdditionalRefreshTokenReplayProtectionEnabled.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("additional_refresh_token_replay_protection_enabled"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.AllowWildcardInRedirectUris.IsNull() && !config.AllowWildcardInRedirectUris.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("allow_wildcard_in_redirect_uris"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.AssertionDuration.IsNull() && !config.AssertionDuration.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("assertion_duration"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.AssertionSigned.IsNull() && !config.AssertionSigned.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("assertion_signed"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.AssignActorRoles.IsNull() && !config.AssignActorRoles.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("assign_actor_roles"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.BundleId.IsNull() && !config.BundleId.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("bundle_id"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.CorsSettings.IsNull() && !config.CorsSettings.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" && config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("cors_settings"),
				"Invalid configuration",
				"This attribute is only applicable for protocol values `OPENID_CONNECT`, `SAML`.")
		}
	}
	if !config.DefaultTargetUrl.IsNull() && !config.DefaultTargetUrl.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("default_target_url"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.DeviceCustomVerificationUri.IsNull() && !config.DeviceCustomVerificationUri.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("device_custom_verification_uri"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.DevicePathId.IsNull() && !config.DevicePathId.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("device_path_id"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.DevicePollingInterval.IsNull() && !config.DevicePollingInterval.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("device_polling_interval"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.DeviceTimeout.IsNull() && !config.DeviceTimeout.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("device_timeout"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.EnableRequestedAuthnContext.IsNull() && !config.EnableRequestedAuthnContext.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("enable_requested_authn_context"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.GrantTypes.IsNull() && !config.GrantTypes.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("grant_types"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.IdpSigning.IsNull() && !config.IdpSigning.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("idp_signing"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.InitiateLoginUri.IsNull() && !config.InitiateLoginUri.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("initiate_login_uri"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.Jwks.IsNull() && !config.Jwks.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("jwks"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.JwksUrl.IsNull() && !config.JwksUrl.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("jwks_url"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.Kerberos.IsNull() && !config.Kerberos.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("kerberos"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.Mobile.IsNull() && !config.Mobile.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("mobile"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.NameIdFormat.IsNull() && !config.NameIdFormat.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("name_id_format"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.PackageName.IsNull() && !config.PackageName.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("package_name"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.ParRequirement.IsNull() && !config.ParRequirement.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("par_requirement"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.ParTimeout.IsNull() && !config.ParTimeout.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("par_timeout"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.PkceEnforcement.IsNull() && !config.PkceEnforcement.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("pkce_enforcement"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.PostLogoutRedirectUris.IsNull() && !config.PostLogoutRedirectUris.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("post_logout_redirect_uris"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.RedirectUris.IsNull() && !config.RedirectUris.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("redirect_uris"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.RefreshTokenDuration.IsNull() && !config.RefreshTokenDuration.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("refresh_token_duration"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.RefreshTokenRollingDuration.IsNull() && !config.RefreshTokenRollingDuration.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("refresh_token_rolling_duration"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.RefreshTokenRollingGracePeriodDuration.IsNull() && !config.RefreshTokenRollingGracePeriodDuration.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("refresh_token_rolling_grace_period_duration"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.RequireSignedRequestObject.IsNull() && !config.RequireSignedRequestObject.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("require_signed_request_object"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.ResponseSigned.IsNull() && !config.ResponseSigned.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("response_signed"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.ResponseTypes.IsNull() && !config.ResponseTypes.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("response_types"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.SessionNotOnOrAfterDuration.IsNull() && !config.SessionNotOnOrAfterDuration.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("session_not_on_or_after_duration"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.Signing.IsNull() && !config.Signing.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("signing"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.SloBinding.IsNull() && !config.SloBinding.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("slo_binding"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SloEndpoint.IsNull() && !config.SloEndpoint.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("slo_endpoint"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SloResponseEndpoint.IsNull() && !config.SloResponseEndpoint.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("slo_response_endpoint"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SloWindow.IsNull() && !config.SloWindow.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("slo_window"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SpEncryption.IsNull() && !config.SpEncryption.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("sp_encryption"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SpEntityId.IsNull() && !config.SpEntityId.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("sp_entity_id"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SpVerification.IsNull() && !config.SpVerification.IsUnknown() {
		if config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("sp_verification"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `SAML`.")
		}
	}
	if !config.SupportUnsignedRequestObject.IsNull() && !config.SupportUnsignedRequestObject.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("support_unsigned_request_object"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.Tags.IsNull() && !config.Tags.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("tags"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.TargetLinkUri.IsNull() && !config.TargetLinkUri.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("target_link_uri"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
	if !config.Template.IsNull() && !config.Template.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" && config.Protocol.ValueString() != "SAML" {
			resp.Diagnostics.AddAttributeError(
				path.Root("template"),
				"Invalid configuration",
				"This attribute is only applicable for protocol values `OPENID_CONNECT`, `SAML`.")
		}
	}
	if !config.TokenEndpointAuthMethod.IsNull() && !config.TokenEndpointAuthMethod.IsUnknown() {
		if config.Protocol.ValueString() != "OPENID_CONNECT" {
			resp.Diagnostics.AddAttributeError(
				path.Root("token_endpoint_auth_method"),
				"Invalid configuration",
				"This attribute is only applicable for protocol value `OPENID_CONNECT`.")
		}
	}
}

func (r *applicationv2Resource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	var plan *applicationv2ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if plan == nil {
		return
	}

	// Verify that the discriminator attribute has a value
	if plan.Protocol.IsUnknown() || plan.Protocol.IsNull() {
		return
	}

	// Set defaults where appropriate
	if plan.AdditionalRefreshTokenReplayProtectionEnabled.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.AdditionalRefreshTokenReplayProtectionEnabled = types.BoolValue(true)
		}
	}
	if plan.AssertionSigned.IsUnknown() {
		if plan.Protocol.ValueString() == "SAML" {
			plan.AssertionSigned = types.BoolValue(true)
		} else {
			plan.AssertionSigned = types.BoolNull()
		}
	}
	if plan.AssignActorRoles.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.AssignActorRoles = types.BoolValue(false)
		}
	}
	if plan.DevicePollingInterval.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.DevicePollingInterval = types.Int32Value(5)
		}
	}
	if plan.DeviceTimeout.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.DeviceTimeout = types.Int32Value(600)
		}
	}
	if plan.ParRequirement.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.ParRequirement = types.StringValue("OPTIONAL")
		}
	}
	if plan.ParTimeout.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.ParTimeout = types.Int32Value(60)
		}
	}
	if plan.PkceEnforcement.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.PkceEnforcement = types.StringValue("OPTIONAL")
		}
	}
	if plan.RefreshTokenDuration.IsUnknown() {
		if plan.Protocol.ValueString() == "OPENID_CONNECT" {
			plan.RefreshTokenDuration = types.Int32Value(2592000)
		}
	}
	if plan.ResponseSigned.IsUnknown() {
		if plan.Protocol.ValueString() == "SAML" {
			plan.ResponseSigned = types.BoolValue(false)
		} else {
			plan.ResponseSigned = types.BoolNull()
		}
	}
	if plan.SloBinding.IsUnknown() {
		if plan.Protocol.ValueString() == "SAML" {
			plan.SloBinding = types.StringValue("HTTP_POST")
		} else {
			plan.SloBinding = types.StringNull()
		}
	}

	// Update the plan with the new defaults
	resp.Diagnostics.Append(resp.Plan.Set(ctx, plan)...)
}

func (model *applicationv2ResourceModel) buildClientStruct() (*management.CreateApplicationRequest, *management.UpdateApplicationRequest, diag.Diagnostics) {
	result := &management.CreateApplicationRequest{}
	var respDiags diag.Diagnostics

	switch model.Protocol.ValueString() {
	case "EXTERNAL_LINK":
		result.ApplicationExternalLink = &management.ApplicationExternalLink{}
		// EXTERNAL_LINK - access_control
		if !model.AccessControl.IsNull() {
			accessControlValue := &management.ApplicationAccessControl{}
			accessControlAttrs := model.AccessControl.Attributes()
			if !accessControlAttrs["group"].IsNull() {
				accessControlGroupValue := &management.ApplicationAccessControlGroup{}
				accessControlGroupAttrs := accessControlAttrs["group"].(types.Object).Attributes()
				accessControlGroupValue.Groups = []management.ApplicationAccessControlGroupGroupsInner{}
				for _, groupsElement := range accessControlGroupAttrs["groups"].(types.List).Elements() {
					groupsValue := management.ApplicationAccessControlGroupGroupsInner{}
					groupsAttrs := groupsElement.(types.Object).Attributes()
					groupsValue.Id = groupsAttrs["id"].(types.String).ValueString()
					accessControlGroupValue.Groups = append(accessControlGroupValue.Groups, groupsValue)
				}
				accessControlGroupTypeValue, err := management.NewEnumApplicationAccessControlGroupTypeFromValue(accessControlGroupAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlGroupValue.Type = *accessControlGroupTypeValue
				}
				accessControlValue.Group = accessControlGroupValue
			}
			if !accessControlAttrs["role"].IsNull() {
				accessControlRoleValue := &management.ApplicationAccessControlRole{}
				accessControlRoleAttrs := accessControlAttrs["role"].(types.Object).Attributes()
				accessControlRoleTypeValue, err := management.NewEnumApplicationAccessControlTypeFromValue(accessControlRoleAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlRoleValue.Type = *accessControlRoleTypeValue
				}
				accessControlValue.Role = accessControlRoleValue
			}
			result.ApplicationExternalLink.AccessControl = accessControlValue
		}

		// EXTERNAL_LINK - description
		result.ApplicationExternalLink.Description = model.Description.ValueStringPointer()
		// EXTERNAL_LINK - enabled
		result.ApplicationExternalLink.Enabled = model.Enabled.ValueBool()
		// EXTERNAL_LINK - hidden_from_app_portal
		result.ApplicationExternalLink.HiddenFromAppPortal = model.HiddenFromAppPortal.ValueBoolPointer()
		// EXTERNAL_LINK - home_page_url
		result.ApplicationExternalLink.HomePageUrl = model.HomePageUrl.ValueString()
		// EXTERNAL_LINK - icon
		if !model.Icon.IsNull() {
			iconValue := &management.ApplicationIcon{}
			iconAttrs := model.Icon.Attributes()
			iconValue.Href = iconAttrs["href"].(types.String).ValueString()
			iconValue.Id = iconAttrs["id"].(types.String).ValueString()
			result.ApplicationExternalLink.Icon = iconValue
		}

		// EXTERNAL_LINK - login_page_url
		result.ApplicationExternalLink.LoginPageUrl = model.LoginPageUrl.ValueStringPointer()
		// EXTERNAL_LINK - name
		result.ApplicationExternalLink.Name = model.Name.ValueString()
		// EXTERNAL_LINK - protocol
		protocolValue, err := management.NewEnumApplicationProtocolFromValue(model.Protocol.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("protocol"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for protocol is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationExternalLink.Protocol = *protocolValue
		}

		// EXTERNAL_LINK - type
		typeValue, err := management.NewEnumApplicationTypeFromValue(model.Type.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationExternalLink.Type = *typeValue
		}

	case "OPENID_CONNECT":
		result.ApplicationOIDC = &management.ApplicationOIDC{}
		// OPENID_CONNECT - access_control
		if !model.AccessControl.IsNull() {
			accessControlValue := &management.ApplicationAccessControl{}
			accessControlAttrs := model.AccessControl.Attributes()
			if !accessControlAttrs["group"].IsNull() {
				accessControlGroupValue := &management.ApplicationAccessControlGroup{}
				accessControlGroupAttrs := accessControlAttrs["group"].(types.Object).Attributes()
				accessControlGroupValue.Groups = []management.ApplicationAccessControlGroupGroupsInner{}
				for _, groupsElement := range accessControlGroupAttrs["groups"].(types.List).Elements() {
					groupsValue := management.ApplicationAccessControlGroupGroupsInner{}
					groupsAttrs := groupsElement.(types.Object).Attributes()
					groupsValue.Id = groupsAttrs["id"].(types.String).ValueString()
					accessControlGroupValue.Groups = append(accessControlGroupValue.Groups, groupsValue)
				}
				accessControlGroupTypeValue, err := management.NewEnumApplicationAccessControlGroupTypeFromValue(accessControlGroupAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlGroupValue.Type = *accessControlGroupTypeValue
				}
				accessControlValue.Group = accessControlGroupValue
			}
			if !accessControlAttrs["role"].IsNull() {
				accessControlRoleValue := &management.ApplicationAccessControlRole{}
				accessControlRoleAttrs := accessControlAttrs["role"].(types.Object).Attributes()
				accessControlRoleTypeValue, err := management.NewEnumApplicationAccessControlTypeFromValue(accessControlRoleAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlRoleValue.Type = *accessControlRoleTypeValue
				}
				accessControlValue.Role = accessControlRoleValue
			}
			result.ApplicationOIDC.AccessControl = accessControlValue
		}

		// OPENID_CONNECT - additional_refresh_token_replay_protection_enabled
		result.ApplicationOIDC.AdditionalRefreshTokenReplayProtectionEnabled = model.AdditionalRefreshTokenReplayProtectionEnabled.ValueBoolPointer()
		// OPENID_CONNECT - allow_wildcard_in_redirect_uris
		result.ApplicationOIDC.AllowWildcardInRedirectUris = model.AllowWildcardInRedirectUris.ValueBoolPointer()
		// OPENID_CONNECT - assign_actor_roles
		result.ApplicationOIDC.AssignActorRoles = model.AssignActorRoles.ValueBoolPointer()
		// OPENID_CONNECT - bundle_id
		result.ApplicationOIDC.BundleId = model.BundleId.ValueStringPointer()
		// OPENID_CONNECT - cors_settings
		if !model.CorsSettings.IsNull() {
			corsSettingsValue := &management.ApplicationCorsSettings{}
			corsSettingsAttrs := model.CorsSettings.Attributes()
			corsSettingsBehaviorValue, err := management.NewEnumApplicationCorsSettingsBehaviorFromValue(corsSettingsAttrs["behavior"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("behavior"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for behavior is not valid: %s", err.Error()),
				)
			} else {
				corsSettingsValue.Behavior = *corsSettingsBehaviorValue
			}
			if !corsSettingsAttrs["origins"].IsNull() {
				corsSettingsValue.Origins = []string{}
				for _, originsElement := range corsSettingsAttrs["origins"].(types.List).Elements() {
					corsSettingsValue.Origins = append(corsSettingsValue.Origins, originsElement.(types.String).ValueString())
				}
			}
			result.ApplicationOIDC.CorsSettings = corsSettingsValue
		}

		// OPENID_CONNECT - description
		result.ApplicationOIDC.Description = model.Description.ValueStringPointer()
		// OPENID_CONNECT - device_custom_verification_uri
		result.ApplicationOIDC.DeviceCustomVerificationUri = model.DeviceCustomVerificationUri.ValueStringPointer()
		// OPENID_CONNECT - device_path_id
		result.ApplicationOIDC.DevicePathId = model.DevicePathId.ValueStringPointer()
		// OPENID_CONNECT - device_polling_interval
		result.ApplicationOIDC.DevicePollingInterval = model.DevicePollingInterval.ValueInt32Pointer()
		// OPENID_CONNECT - device_timeout
		result.ApplicationOIDC.DeviceTimeout = model.DeviceTimeout.ValueInt32Pointer()
		// OPENID_CONNECT - enabled
		result.ApplicationOIDC.Enabled = model.Enabled.ValueBool()
		// OPENID_CONNECT - grant_types
		if !model.GrantTypes.IsNull() {
			result.ApplicationOIDC.GrantTypes = []management.EnumApplicationOIDCGrantType{}
			for _, grantTypesElement := range model.GrantTypes.Elements() {
				var grantTypesValue management.EnumApplicationOIDCGrantType
				grantTypesEnumValue, err := management.NewEnumApplicationOIDCGrantTypeFromValue(grantTypesElement.(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("grant_types"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for grant_types is not valid: %s", err.Error()),
					)
				} else {
					grantTypesValue = *grantTypesEnumValue
				}
				result.ApplicationOIDC.GrantTypes = append(result.ApplicationOIDC.GrantTypes, grantTypesValue)
			}
		}

		// OPENID_CONNECT - hidden_from_app_portal
		result.ApplicationOIDC.HiddenFromAppPortal = model.HiddenFromAppPortal.ValueBoolPointer()
		// OPENID_CONNECT - home_page_url
		result.ApplicationOIDC.HomePageUrl = model.HomePageUrl.ValueStringPointer()
		// OPENID_CONNECT - icon
		if !model.Icon.IsNull() {
			iconValue := &management.ApplicationIcon{}
			iconAttrs := model.Icon.Attributes()
			iconValue.Href = iconAttrs["href"].(types.String).ValueString()
			iconValue.Id = iconAttrs["id"].(types.String).ValueString()
			result.ApplicationOIDC.Icon = iconValue
		}

		// OPENID_CONNECT - initiate_login_uri
		result.ApplicationOIDC.InitiateLoginUri = model.InitiateLoginUri.ValueStringPointer()
		// OPENID_CONNECT - jwks
		result.ApplicationOIDC.Jwks = model.Jwks.ValueStringPointer()
		// OPENID_CONNECT - jwks_url
		result.ApplicationOIDC.JwksUrl = model.JwksUrl.ValueStringPointer()
		// OPENID_CONNECT - kerberos
		if !model.Kerberos.IsNull() {
			kerberosValue := &management.ApplicationOIDCAllOfKerberos{}
			kerberosAttrs := model.Kerberos.Attributes()
			kerberosKeyValue := management.ApplicationOIDCAllOfKerberosKey{}
			kerberosKeyAttrs := kerberosAttrs["key"].(types.Object).Attributes()
			kerberosKeyValue.Id = kerberosKeyAttrs["id"].(types.String).ValueString()
			kerberosValue.Key = kerberosKeyValue
			result.ApplicationOIDC.Kerberos = kerberosValue
		}

		// OPENID_CONNECT - login_page_url
		result.ApplicationOIDC.LoginPageUrl = model.LoginPageUrl.ValueStringPointer()
		// OPENID_CONNECT - mobile
		if !model.Mobile.IsNull() {
			mobileValue := &management.ApplicationOIDCAllOfMobile{}
			mobileAttrs := model.Mobile.Attributes()
			mobileValue.BundleId = mobileAttrs["bundle_id"].(types.String).ValueStringPointer()
			mobileValue.HuaweiAppId = mobileAttrs["huawei_app_id"].(types.String).ValueStringPointer()
			mobileValue.HuaweiPackageName = mobileAttrs["huawei_package_name"].(types.String).ValueStringPointer()
			if !mobileAttrs["integrity_detection"].IsNull() {
				mobileIntegrityDetectionValue := &management.ApplicationOIDCAllOfMobileIntegrityDetection{}
				mobileIntegrityDetectionAttrs := mobileAttrs["integrity_detection"].(types.Object).Attributes()
				if !mobileIntegrityDetectionAttrs["cache_duration"].IsNull() {
					mobileIntegrityDetectionCacheDurationValue := &management.ApplicationOIDCAllOfMobileIntegrityDetectionCacheDuration{}
					mobileIntegrityDetectionCacheDurationAttrs := mobileIntegrityDetectionAttrs["cache_duration"].(types.Object).Attributes()
					mobileIntegrityDetectionCacheDurationValue.Amount = mobileIntegrityDetectionCacheDurationAttrs["amount"].(types.Int32).ValueInt32Pointer()
					if !mobileIntegrityDetectionCacheDurationAttrs["units"].IsNull() {
						mobileIntegrityDetectionCacheDurationUnitsValue, err := management.NewEnumDurationUnitMinsHoursFromValue(mobileIntegrityDetectionCacheDurationAttrs["units"].(types.String).ValueString())
						if err != nil {
							respDiags.AddAttributeError(
								path.Root("units"),
								"Provided value is not valid",
								fmt.Sprintf("The value provided for units is not valid: %s", err.Error()),
							)
						} else {
							mobileIntegrityDetectionCacheDurationValue.Units = mobileIntegrityDetectionCacheDurationUnitsValue
						}
					}
					mobileIntegrityDetectionValue.CacheDuration = mobileIntegrityDetectionCacheDurationValue
				}
				if !mobileIntegrityDetectionAttrs["excluded_platforms"].IsNull() {
					mobileIntegrityDetectionValue.ExcludedPlatforms = []management.EnumMobileIntegrityDetectionPlatform{}
					for _, excludedPlatformsElement := range mobileIntegrityDetectionAttrs["excluded_platforms"].(types.List).Elements() {
						var excludedPlatformsValue management.EnumMobileIntegrityDetectionPlatform
						excludedPlatformsEnumValue, err := management.NewEnumMobileIntegrityDetectionPlatformFromValue(excludedPlatformsElement.(types.String).ValueString())
						if err != nil {
							respDiags.AddAttributeError(
								path.Root("excluded_platforms"),
								"Provided value is not valid",
								fmt.Sprintf("The value provided for excluded_platforms is not valid: %s", err.Error()),
							)
						} else {
							excludedPlatformsValue = *excludedPlatformsEnumValue
						}
						mobileIntegrityDetectionValue.ExcludedPlatforms = append(mobileIntegrityDetectionValue.ExcludedPlatforms, excludedPlatformsValue)
					}
				}
				if !mobileIntegrityDetectionAttrs["google_play"].IsNull() {
					mobileIntegrityDetectionGooglePlayValue := &management.ApplicationOIDCAllOfMobileIntegrityDetectionGooglePlay{}
					mobileIntegrityDetectionGooglePlayAttrs := mobileIntegrityDetectionAttrs["google_play"].(types.Object).Attributes()
					mobileIntegrityDetectionGooglePlayValue.DecryptionKey = mobileIntegrityDetectionGooglePlayAttrs["decryption_key"].(types.String).ValueStringPointer()
					mobileIntegrityDetectionGooglePlayValue.ServiceAccountCredentials = mobileIntegrityDetectionGooglePlayAttrs["service_account_credentials"].(types.String).ValueStringPointer()
					mobileIntegrityDetectionGooglePlayValue.VerificationKey = mobileIntegrityDetectionGooglePlayAttrs["verification_key"].(types.String).ValueStringPointer()
					if !mobileIntegrityDetectionGooglePlayAttrs["verification_type"].IsNull() {
						mobileIntegrityDetectionGooglePlayVerificationTypeValue, err := management.NewEnumApplicationNativeGooglePlayVerificationTypeFromValue(mobileIntegrityDetectionGooglePlayAttrs["verification_type"].(types.String).ValueString())
						if err != nil {
							respDiags.AddAttributeError(
								path.Root("verification_type"),
								"Provided value is not valid",
								fmt.Sprintf("The value provided for verification_type is not valid: %s", err.Error()),
							)
						} else {
							mobileIntegrityDetectionGooglePlayValue.VerificationType = mobileIntegrityDetectionGooglePlayVerificationTypeValue
						}
					}
					mobileIntegrityDetectionValue.GooglePlay = mobileIntegrityDetectionGooglePlayValue
				}
				if !mobileIntegrityDetectionAttrs["mode"].IsNull() {
					mobileIntegrityDetectionModeValue, err := management.NewEnumEnabledStatusFromValue(mobileIntegrityDetectionAttrs["mode"].(types.String).ValueString())
					if err != nil {
						respDiags.AddAttributeError(
							path.Root("mode"),
							"Provided value is not valid",
							fmt.Sprintf("The value provided for mode is not valid: %s", err.Error()),
						)
					} else {
						mobileIntegrityDetectionValue.Mode = mobileIntegrityDetectionModeValue
					}
				}
				mobileValue.IntegrityDetection = mobileIntegrityDetectionValue
			}
			mobileValue.PackageName = mobileAttrs["package_name"].(types.String).ValueStringPointer()
			if !mobileAttrs["passcode_refresh_duration"].IsNull() {
				mobilePasscodeRefreshDurationValue := &management.ApplicationOIDCAllOfMobilePasscodeRefreshDuration{}
				mobilePasscodeRefreshDurationAttrs := mobileAttrs["passcode_refresh_duration"].(types.Object).Attributes()
				mobilePasscodeRefreshDurationValue.Duration = mobilePasscodeRefreshDurationAttrs["duration"].(types.Int32).ValueInt32()
				if !mobilePasscodeRefreshDurationAttrs["time_unit"].IsNull() {
					mobilePasscodeRefreshDurationTimeUnitValue, err := management.NewEnumPasscodeRefreshTimeUnitFromValue(mobilePasscodeRefreshDurationAttrs["time_unit"].(types.String).ValueString())
					if err != nil {
						respDiags.AddAttributeError(
							path.Root("time_unit"),
							"Provided value is not valid",
							fmt.Sprintf("The value provided for time_unit is not valid: %s", err.Error()),
						)
					} else {
						mobilePasscodeRefreshDurationValue.TimeUnit = *mobilePasscodeRefreshDurationTimeUnitValue
					}
				}
				mobileValue.PasscodeRefreshDuration = mobilePasscodeRefreshDurationValue
			}
			mobileValue.UriPrefix = mobileAttrs["uri_prefix"].(types.String).ValueStringPointer()
			result.ApplicationOIDC.Mobile = mobileValue
		}

		// OPENID_CONNECT - name
		result.ApplicationOIDC.Name = model.Name.ValueString()
		// OPENID_CONNECT - package_name
		result.ApplicationOIDC.PackageName = model.PackageName.ValueStringPointer()
		// OPENID_CONNECT - par_requirement
		if !model.ParRequirement.IsNull() {
			parRequirementValue, err := management.NewEnumApplicationOIDCPARRequirementFromValue(model.ParRequirement.ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("par_requirement"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for par_requirement is not valid: %s", err.Error()),
				)
			} else {
				result.ApplicationOIDC.ParRequirement = parRequirementValue
			}
		}

		// OPENID_CONNECT - par_timeout
		result.ApplicationOIDC.ParTimeout = model.ParTimeout.ValueInt32Pointer()
		// OPENID_CONNECT - pkce_enforcement
		if !model.PkceEnforcement.IsNull() {
			pkceEnforcementValue, err := management.NewEnumApplicationOIDCPKCEOptionFromValue(model.PkceEnforcement.ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("pkce_enforcement"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for pkce_enforcement is not valid: %s", err.Error()),
				)
			} else {
				result.ApplicationOIDC.PkceEnforcement = pkceEnforcementValue
			}
		}

		// OPENID_CONNECT - post_logout_redirect_uris
		if !model.PostLogoutRedirectUris.IsNull() {
			result.ApplicationOIDC.PostLogoutRedirectUris = []string{}
			for _, postLogoutRedirectUrisElement := range model.PostLogoutRedirectUris.Elements() {
				result.ApplicationOIDC.PostLogoutRedirectUris = append(result.ApplicationOIDC.PostLogoutRedirectUris, postLogoutRedirectUrisElement.(types.String).ValueString())
			}
		}

		// OPENID_CONNECT - protocol
		protocolValue, err := management.NewEnumApplicationProtocolFromValue(model.Protocol.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("protocol"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for protocol is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationOIDC.Protocol = *protocolValue
		}

		// OPENID_CONNECT - redirect_uris
		if !model.RedirectUris.IsNull() {
			result.ApplicationOIDC.RedirectUris = []string{}
			for _, redirectUrisElement := range model.RedirectUris.Elements() {
				result.ApplicationOIDC.RedirectUris = append(result.ApplicationOIDC.RedirectUris, redirectUrisElement.(types.String).ValueString())
			}
		}

		// OPENID_CONNECT - refresh_token_duration
		result.ApplicationOIDC.RefreshTokenDuration = model.RefreshTokenDuration.ValueInt32Pointer()
		// OPENID_CONNECT - refresh_token_rolling_duration
		result.ApplicationOIDC.RefreshTokenRollingDuration = model.RefreshTokenRollingDuration.ValueInt32Pointer()
		// OPENID_CONNECT - refresh_token_rolling_grace_period_duration
		result.ApplicationOIDC.RefreshTokenRollingGracePeriodDuration = model.RefreshTokenRollingGracePeriodDuration.ValueInt32Pointer()
		// OPENID_CONNECT - require_signed_request_object
		result.ApplicationOIDC.RequireSignedRequestObject = model.RequireSignedRequestObject.ValueBoolPointer()
		// OPENID_CONNECT - response_types
		if !model.ResponseTypes.IsNull() {
			result.ApplicationOIDC.ResponseTypes = []management.EnumApplicationOIDCResponseType{}
			for _, responseTypesElement := range model.ResponseTypes.Elements() {
				var responseTypesValue management.EnumApplicationOIDCResponseType
				responseTypesEnumValue, err := management.NewEnumApplicationOIDCResponseTypeFromValue(responseTypesElement.(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("response_types"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for response_types is not valid: %s", err.Error()),
					)
				} else {
					responseTypesValue = *responseTypesEnumValue
				}
				result.ApplicationOIDC.ResponseTypes = append(result.ApplicationOIDC.ResponseTypes, responseTypesValue)
			}
		}

		// OPENID_CONNECT - signing
		if !model.Signing.IsNull() && !model.Signing.IsUnknown() {
			signingValue := &management.ApplicationOIDCAllOfSigning{}
			signingAttrs := model.Signing.Attributes()
			signingKeyRotationPolicyValue := management.ApplicationOIDCAllOfSigningKeyRotationPolicy{}
			signingKeyRotationPolicyAttrs := signingAttrs["key_rotation_policy"].(types.Object).Attributes()
			signingKeyRotationPolicyValue.Id = signingKeyRotationPolicyAttrs["id"].(types.String).ValueString()
			signingValue.KeyRotationPolicy = signingKeyRotationPolicyValue
			result.ApplicationOIDC.Signing = signingValue
		}

		// OPENID_CONNECT - support_unsigned_request_object
		result.ApplicationOIDC.SupportUnsignedRequestObject = model.SupportUnsignedRequestObject.ValueBoolPointer()
		// OPENID_CONNECT - tags
		if !model.Tags.IsNull() {
			result.ApplicationOIDC.Tags = []management.EnumApplicationTags{}
			for _, tagsElement := range model.Tags.Elements() {
				var tagsValue management.EnumApplicationTags
				tagsEnumValue, err := management.NewEnumApplicationTagsFromValue(tagsElement.(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("tags"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for tags is not valid: %s", err.Error()),
					)
				} else {
					tagsValue = *tagsEnumValue
				}
				result.ApplicationOIDC.Tags = append(result.ApplicationOIDC.Tags, tagsValue)
			}
		}

		// OPENID_CONNECT - target_link_uri
		result.ApplicationOIDC.TargetLinkUri = model.TargetLinkUri.ValueStringPointer()
		// OPENID_CONNECT - template
		if !model.Template.IsNull() {
			templateValue := &management.ApplicationTemplate{}
			templateAttrs := model.Template.Attributes()
			templateValue.Configuration = map[string]string{}
			for key, configurationElement := range templateAttrs["configuration"].(types.Map).Elements() {
				templateValue.Configuration[key] = configurationElement.(types.String).ValueString()
			}
			templateIntegrationValue := management.ApplicationTemplateIntegration{}
			templateIntegrationAttrs := templateAttrs["integration"].(types.Object).Attributes()
			templateIntegrationValue.Id = templateIntegrationAttrs["id"].(types.String).ValueString()
			templateValue.Integration = templateIntegrationValue
			templateVersionValue := management.ApplicationTemplateVersion{}
			templateVersionAttrs := templateAttrs["version"].(types.Object).Attributes()
			templateVersionValue.Id = templateVersionAttrs["id"].(types.String).ValueString()
			templateValue.Version = templateVersionValue
			result.ApplicationOIDC.Template = templateValue
		}

		// OPENID_CONNECT - token_endpoint_auth_method
		if !model.TokenEndpointAuthMethod.IsNull() {
			tokenEndpointAuthMethodValue, err := management.NewEnumApplicationOIDCTokenAuthMethodFromValue(model.TokenEndpointAuthMethod.ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("token_endpoint_auth_method"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for token_endpoint_auth_method is not valid: %s", err.Error()),
				)
			} else {
				result.ApplicationOIDC.TokenEndpointAuthMethod = *tokenEndpointAuthMethodValue
			}
		}

		// OPENID_CONNECT - type
		typeValue, err := management.NewEnumApplicationTypeFromValue(model.Type.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationOIDC.Type = *typeValue
		}

	case "SAML":
		result.ApplicationSAML = &management.ApplicationSAML{}
		// SAML - access_control
		if !model.AccessControl.IsNull() {
			accessControlValue := &management.ApplicationAccessControl{}
			accessControlAttrs := model.AccessControl.Attributes()
			if !accessControlAttrs["group"].IsNull() {
				accessControlGroupValue := &management.ApplicationAccessControlGroup{}
				accessControlGroupAttrs := accessControlAttrs["group"].(types.Object).Attributes()
				accessControlGroupValue.Groups = []management.ApplicationAccessControlGroupGroupsInner{}
				for _, groupsElement := range accessControlGroupAttrs["groups"].(types.List).Elements() {
					groupsValue := management.ApplicationAccessControlGroupGroupsInner{}
					groupsAttrs := groupsElement.(types.Object).Attributes()
					groupsValue.Id = groupsAttrs["id"].(types.String).ValueString()
					accessControlGroupValue.Groups = append(accessControlGroupValue.Groups, groupsValue)
				}
				accessControlGroupTypeValue, err := management.NewEnumApplicationAccessControlGroupTypeFromValue(accessControlGroupAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlGroupValue.Type = *accessControlGroupTypeValue
				}
				accessControlValue.Group = accessControlGroupValue
			}
			if !accessControlAttrs["role"].IsNull() {
				accessControlRoleValue := &management.ApplicationAccessControlRole{}
				accessControlRoleAttrs := accessControlAttrs["role"].(types.Object).Attributes()
				accessControlRoleTypeValue, err := management.NewEnumApplicationAccessControlTypeFromValue(accessControlRoleAttrs["type"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("type"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
					)
				} else {
					accessControlRoleValue.Type = *accessControlRoleTypeValue
				}
				accessControlValue.Role = accessControlRoleValue
			}
			result.ApplicationSAML.AccessControl = accessControlValue
		}

		// SAML - acs_urls
		if !model.AcsUrls.IsNull() {
			result.ApplicationSAML.AcsUrls = []string{}
			for _, acsUrlsElement := range model.AcsUrls.Elements() {
				result.ApplicationSAML.AcsUrls = append(result.ApplicationSAML.AcsUrls, acsUrlsElement.(types.String).ValueString())
			}
		}

		// SAML - assertion_duration
		result.ApplicationSAML.AssertionDuration = model.AssertionDuration.ValueInt32()
		// SAML - assertion_signed
		result.ApplicationSAML.AssertionSigned = model.AssertionSigned.ValueBoolPointer()
		// SAML - cors_settings
		if !model.CorsSettings.IsNull() {
			corsSettingsValue := &management.ApplicationCorsSettings{}
			corsSettingsAttrs := model.CorsSettings.Attributes()
			corsSettingsBehaviorValue, err := management.NewEnumApplicationCorsSettingsBehaviorFromValue(corsSettingsAttrs["behavior"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("behavior"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for behavior is not valid: %s", err.Error()),
				)
			} else {
				corsSettingsValue.Behavior = *corsSettingsBehaviorValue
			}
			if !corsSettingsAttrs["origins"].IsNull() {
				corsSettingsValue.Origins = []string{}
				for _, originsElement := range corsSettingsAttrs["origins"].(types.List).Elements() {
					corsSettingsValue.Origins = append(corsSettingsValue.Origins, originsElement.(types.String).ValueString())
				}
			}
			result.ApplicationSAML.CorsSettings = corsSettingsValue
		}

		// SAML - default_target_url
		result.ApplicationSAML.DefaultTargetUrl = model.DefaultTargetUrl.ValueStringPointer()
		// SAML - description
		result.ApplicationSAML.Description = model.Description.ValueStringPointer()
		// SAML - enable_requested_authn_context
		result.ApplicationSAML.EnableRequestedAuthnContext = model.EnableRequestedAuthnContext.ValueBoolPointer()
		// SAML - enabled
		result.ApplicationSAML.Enabled = model.Enabled.ValueBool()
		// SAML - hidden_from_app_portal
		result.ApplicationSAML.HiddenFromAppPortal = model.HiddenFromAppPortal.ValueBoolPointer()
		// SAML - home_page_url
		result.ApplicationSAML.HomePageUrl = model.HomePageUrl.ValueStringPointer()
		// SAML - icon
		if !model.Icon.IsNull() {
			iconValue := &management.ApplicationIcon{}
			iconAttrs := model.Icon.Attributes()
			iconValue.Href = iconAttrs["href"].(types.String).ValueString()
			iconValue.Id = iconAttrs["id"].(types.String).ValueString()
			result.ApplicationSAML.Icon = iconValue
		}

		// SAML - idp_signing
		if !model.IdpSigning.IsNull() {
			idpSigningValue := &management.ApplicationSAMLAllOfIdpSigning{}
			idpSigningAttrs := model.IdpSigning.Attributes()
			if !idpSigningAttrs["algorithm"].IsNull() {
				idpSigningAlgorithmValue, err := management.NewEnumCertificateKeySignagureAlgorithmFromValue(idpSigningAttrs["algorithm"].(types.String).ValueString())
				if err != nil {
					respDiags.AddAttributeError(
						path.Root("algorithm"),
						"Provided value is not valid",
						fmt.Sprintf("The value provided for algorithm is not valid: %s", err.Error()),
					)
				} else {
					idpSigningValue.Algorithm = idpSigningAlgorithmValue
				}
			}
			idpSigningKeyValue := management.ApplicationSAMLAllOfIdpSigningKey{}
			idpSigningKeyAttrs := idpSigningAttrs["key"].(types.Object).Attributes()
			idpSigningKeyValue.Id = idpSigningKeyAttrs["id"].(types.String).ValueString()
			idpSigningValue.Key = idpSigningKeyValue
			result.ApplicationSAML.IdpSigning = idpSigningValue
		}

		// SAML - login_page_url
		result.ApplicationSAML.LoginPageUrl = model.LoginPageUrl.ValueStringPointer()
		// SAML - name
		result.ApplicationSAML.Name = model.Name.ValueString()
		// SAML - name_id_format
		result.ApplicationSAML.NameIdFormat = model.NameIdFormat.ValueStringPointer()
		// SAML - protocol
		protocolValue, err := management.NewEnumApplicationProtocolFromValue(model.Protocol.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("protocol"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for protocol is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationSAML.Protocol = *protocolValue
		}

		// SAML - response_signed
		result.ApplicationSAML.ResponseSigned = model.ResponseSigned.ValueBoolPointer()
		// SAML - session_not_on_or_after_duration
		result.ApplicationSAML.SessionNotOnOrAfterDuration = model.SessionNotOnOrAfterDuration.ValueInt32Pointer()
		// SAML - slo_binding
		if !model.SloBinding.IsNull() {
			sloBindingValue, err := management.NewEnumApplicationSAMLSloBindingFromValue(model.SloBinding.ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("slo_binding"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for slo_binding is not valid: %s", err.Error()),
				)
			} else {
				result.ApplicationSAML.SloBinding = sloBindingValue
			}
		}

		// SAML - slo_endpoint
		result.ApplicationSAML.SloEndpoint = model.SloEndpoint.ValueStringPointer()
		// SAML - slo_response_endpoint
		result.ApplicationSAML.SloResponseEndpoint = model.SloResponseEndpoint.ValueStringPointer()
		// SAML - slo_window
		result.ApplicationSAML.SloWindow = model.SloWindow.ValueInt32Pointer()
		// SAML - sp_encryption
		if !model.SpEncryption.IsNull() {
			spEncryptionValue := &management.ApplicationSAMLAllOfSpEncryption{}
			spEncryptionAttrs := model.SpEncryption.Attributes()
			spEncryptionAlgorithmValue, err := management.NewEnumCertificateKeyEncryptionAlgorithmFromValue(spEncryptionAttrs["algorithm"].(types.String).ValueString())
			if err != nil {
				respDiags.AddAttributeError(
					path.Root("algorithm"),
					"Provided value is not valid",
					fmt.Sprintf("The value provided for algorithm is not valid: %s", err.Error()),
				)
			} else {
				spEncryptionValue.Algorithm = *spEncryptionAlgorithmValue
			}
			spEncryptionCertificateValue := management.ApplicationSAMLAllOfSpEncryptionCertificate{}
			spEncryptionCertificateAttrs := spEncryptionAttrs["certificate"].(types.Object).Attributes()
			spEncryptionCertificateValue.Id = spEncryptionCertificateAttrs["id"].(types.String).ValueString()
			spEncryptionValue.Certificate = spEncryptionCertificateValue
			result.ApplicationSAML.SpEncryption = spEncryptionValue
		}

		// SAML - sp_entity_id
		result.ApplicationSAML.SpEntityId = model.SpEntityId.ValueString()
		// SAML - sp_verification
		if !model.SpVerification.IsNull() {
			spVerificationValue := &management.ApplicationSAMLAllOfSpVerification{}
			spVerificationAttrs := model.SpVerification.Attributes()
			spVerificationValue.AuthnRequestSigned = spVerificationAttrs["authn_request_signed"].(types.Bool).ValueBoolPointer()
			spVerificationValue.Certificates = []management.ApplicationSAMLAllOfSpVerificationCertificates{}
			for _, certificatesElement := range spVerificationAttrs["certificates"].(types.List).Elements() {
				certificatesValue := management.ApplicationSAMLAllOfSpVerificationCertificates{}
				certificatesAttrs := certificatesElement.(types.Object).Attributes()
				certificatesValue.Id = certificatesAttrs["id"].(types.String).ValueString()
				spVerificationValue.Certificates = append(spVerificationValue.Certificates, certificatesValue)
			}
			result.ApplicationSAML.SpVerification = spVerificationValue
		}

		// SAML - template
		if !model.Template.IsNull() {
			templateValue := &management.ApplicationTemplate{}
			templateAttrs := model.Template.Attributes()
			templateValue.Configuration = map[string]string{}
			for key, configurationElement := range templateAttrs["configuration"].(types.Map).Elements() {
				templateValue.Configuration[key] = configurationElement.(types.String).ValueString()
			}
			templateIntegrationValue := management.ApplicationTemplateIntegration{}
			templateIntegrationAttrs := templateAttrs["integration"].(types.Object).Attributes()
			templateIntegrationValue.Id = templateIntegrationAttrs["id"].(types.String).ValueString()
			templateValue.Integration = templateIntegrationValue
			templateVersionValue := management.ApplicationTemplateVersion{}
			templateVersionAttrs := templateAttrs["version"].(types.Object).Attributes()
			templateVersionValue.Id = templateVersionAttrs["id"].(types.String).ValueString()
			templateValue.Version = templateVersionValue
			result.ApplicationSAML.Template = templateValue
		}

		// SAML - type
		typeValue, err := management.NewEnumApplicationTypeFromValue(model.Type.ValueString())
		if err != nil {
			respDiags.AddAttributeError(
				path.Root("type"),
				"Provided value is not valid",
				fmt.Sprintf("The value provided for type is not valid: %s", err.Error()),
			)
		} else {
			result.ApplicationSAML.Type = *typeValue
		}

	}
	updateResult := &management.UpdateApplicationRequest{
		ApplicationExternalLink: result.ApplicationExternalLink,
		ApplicationOIDC:         result.ApplicationOIDC,
		ApplicationSAML:         result.ApplicationSAML,
	}
	return result, updateResult, respDiags
}

func (state *applicationv2ResourceModel) readClientResponse(response *management.ReadOneApplication200Response) diag.Diagnostics {
	var respDiags, diags diag.Diagnostics
	switch {
	case response.ApplicationExternalLink != nil:
		// ApplicationExternalLink - access_control
		accessControlGroupGroupsAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		accessControlGroupGroupsElementType := types.ObjectType{AttrTypes: accessControlGroupGroupsAttrTypes}
		accessControlGroupAttrTypes := map[string]attr.Type{
			"groups": types.ListType{ElemType: accessControlGroupGroupsElementType},
			"type":   types.StringType,
		}
		accessControlRoleAttrTypes := map[string]attr.Type{
			"type": types.StringType,
		}
		accessControlAttrTypes := map[string]attr.Type{
			"group": types.ObjectType{AttrTypes: accessControlGroupAttrTypes},
			"role":  types.ObjectType{AttrTypes: accessControlRoleAttrTypes},
		}
		var accessControlValue types.Object
		if response.ApplicationExternalLink.AccessControl == nil {
			accessControlValue = types.ObjectNull(accessControlAttrTypes)
		} else {
			var accessControlGroupValue types.Object
			if response.ApplicationExternalLink.AccessControl.Group == nil {
				accessControlGroupValue = types.ObjectNull(accessControlGroupAttrTypes)
			} else {
				var accessControlGroupGroupsValues []attr.Value
				for _, accessControlGroupGroupsResponseValue := range response.ApplicationExternalLink.AccessControl.Group.Groups {
					accessControlGroupGroupsValue, diags := types.ObjectValue(accessControlGroupGroupsAttrTypes, map[string]attr.Value{
						"id": types.StringValue(accessControlGroupGroupsResponseValue.Id),
					})
					respDiags.Append(diags...)
					accessControlGroupGroupsValues = append(accessControlGroupGroupsValues, accessControlGroupGroupsValue)
				}
				accessControlGroupGroupsValue, diags := types.ListValue(accessControlGroupGroupsElementType, accessControlGroupGroupsValues)
				respDiags.Append(diags...)
				accessControlGroupTypeValue := types.StringValue(string(response.ApplicationExternalLink.AccessControl.Group.Type))
				accessControlGroupValue, diags = types.ObjectValue(accessControlGroupAttrTypes, map[string]attr.Value{
					"groups": accessControlGroupGroupsValue,
					"type":   accessControlGroupTypeValue,
				})
				respDiags.Append(diags...)
			}
			var accessControlRoleValue types.Object
			if response.ApplicationExternalLink.AccessControl.Role == nil {
				accessControlRoleValue = types.ObjectNull(accessControlRoleAttrTypes)
			} else {
				accessControlRoleTypeValue := types.StringValue(string(response.ApplicationExternalLink.AccessControl.Role.Type))
				accessControlRoleValue, diags = types.ObjectValue(accessControlRoleAttrTypes, map[string]attr.Value{
					"type": accessControlRoleTypeValue,
				})
				respDiags.Append(diags...)
			}
			accessControlValue, diags = types.ObjectValue(accessControlAttrTypes, map[string]attr.Value{
				"group": accessControlGroupValue,
				"role":  accessControlRoleValue,
			})
			respDiags.Append(diags...)
		}
		state.AccessControl = accessControlValue
		// ApplicationExternalLink - description
		state.Description = types.StringPointerValue(response.ApplicationExternalLink.Description)
		// ApplicationExternalLink - enabled
		state.Enabled = types.BoolValue(response.ApplicationExternalLink.Enabled)
		// ApplicationExternalLink - hidden_from_app_portal
		state.HiddenFromAppPortal = types.BoolPointerValue(response.ApplicationExternalLink.HiddenFromAppPortal)
		// ApplicationExternalLink - home_page_url
		state.HomePageUrl = types.StringValue(response.ApplicationExternalLink.HomePageUrl)
		// ApplicationExternalLink - icon
		iconAttrTypes := map[string]attr.Type{
			"href": types.StringType,
			"id":   types.StringType,
		}
		var iconValue types.Object
		if response.ApplicationExternalLink.Icon == nil {
			iconValue = types.ObjectNull(iconAttrTypes)
		} else {
			iconValue, diags = types.ObjectValue(iconAttrTypes, map[string]attr.Value{
				"href": types.StringValue(response.ApplicationExternalLink.Icon.Href),
				"id":   types.StringValue(response.ApplicationExternalLink.Icon.Id),
			})
			respDiags.Append(diags...)
		}
		state.Icon = iconValue
		// ApplicationExternalLink - id
		idValue := framework.PingOneResourceIDToTF(response.ApplicationExternalLink.GetId())
		state.Id = idValue
		// ApplicationExternalLink - login_page_url
		state.LoginPageUrl = types.StringPointerValue(response.ApplicationExternalLink.LoginPageUrl)
		// ApplicationExternalLink - name
		state.Name = types.StringValue(response.ApplicationExternalLink.Name)
		// ApplicationExternalLink - protocol
		protocolValue := types.StringValue(string(response.ApplicationExternalLink.Protocol))
		state.Protocol = protocolValue
		// ApplicationExternalLink - type
		typeValue := types.StringValue(string(response.ApplicationExternalLink.Type))
		state.Type = typeValue
	case response.ApplicationOIDC != nil:
		// ApplicationOIDC - access_control
		accessControlGroupGroupsAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		accessControlGroupGroupsElementType := types.ObjectType{AttrTypes: accessControlGroupGroupsAttrTypes}
		accessControlGroupAttrTypes := map[string]attr.Type{
			"groups": types.ListType{ElemType: accessControlGroupGroupsElementType},
			"type":   types.StringType,
		}
		accessControlRoleAttrTypes := map[string]attr.Type{
			"type": types.StringType,
		}
		accessControlAttrTypes := map[string]attr.Type{
			"group": types.ObjectType{AttrTypes: accessControlGroupAttrTypes},
			"role":  types.ObjectType{AttrTypes: accessControlRoleAttrTypes},
		}
		var accessControlValue types.Object
		if response.ApplicationOIDC.AccessControl == nil {
			accessControlValue = types.ObjectNull(accessControlAttrTypes)
		} else {
			var accessControlGroupValue types.Object
			if response.ApplicationOIDC.AccessControl.Group == nil {
				accessControlGroupValue = types.ObjectNull(accessControlGroupAttrTypes)
			} else {
				var accessControlGroupGroupsValues []attr.Value
				for _, accessControlGroupGroupsResponseValue := range response.ApplicationOIDC.AccessControl.Group.Groups {
					accessControlGroupGroupsValue, diags := types.ObjectValue(accessControlGroupGroupsAttrTypes, map[string]attr.Value{
						"id": types.StringValue(accessControlGroupGroupsResponseValue.Id),
					})
					respDiags.Append(diags...)
					accessControlGroupGroupsValues = append(accessControlGroupGroupsValues, accessControlGroupGroupsValue)
				}
				accessControlGroupGroupsValue, diags := types.ListValue(accessControlGroupGroupsElementType, accessControlGroupGroupsValues)
				respDiags.Append(diags...)
				accessControlGroupTypeValue := types.StringValue(string(response.ApplicationOIDC.AccessControl.Group.Type))
				accessControlGroupValue, diags = types.ObjectValue(accessControlGroupAttrTypes, map[string]attr.Value{
					"groups": accessControlGroupGroupsValue,
					"type":   accessControlGroupTypeValue,
				})
				respDiags.Append(diags...)
			}
			var accessControlRoleValue types.Object
			if response.ApplicationOIDC.AccessControl.Role == nil {
				accessControlRoleValue = types.ObjectNull(accessControlRoleAttrTypes)
			} else {
				accessControlRoleTypeValue := types.StringValue(string(response.ApplicationOIDC.AccessControl.Role.Type))
				accessControlRoleValue, diags = types.ObjectValue(accessControlRoleAttrTypes, map[string]attr.Value{
					"type": accessControlRoleTypeValue,
				})
				respDiags.Append(diags...)
			}
			accessControlValue, diags = types.ObjectValue(accessControlAttrTypes, map[string]attr.Value{
				"group": accessControlGroupValue,
				"role":  accessControlRoleValue,
			})
			respDiags.Append(diags...)
		}
		state.AccessControl = accessControlValue
		// ApplicationOIDC - additional_refresh_token_replay_protection_enabled
		state.AdditionalRefreshTokenReplayProtectionEnabled = types.BoolPointerValue(response.ApplicationOIDC.AdditionalRefreshTokenReplayProtectionEnabled)
		// ApplicationOIDC - allow_wildcard_in_redirect_uris
		state.AllowWildcardInRedirectUris = types.BoolPointerValue(response.ApplicationOIDC.AllowWildcardInRedirectUris)
		// ApplicationOIDC - assign_actor_roles
		state.AssignActorRoles = types.BoolPointerValue(response.ApplicationOIDC.AssignActorRoles)
		// ApplicationOIDC - bundle_id
		state.BundleId = types.StringPointerValue(response.ApplicationOIDC.BundleId)
		// ApplicationOIDC - cors_settings
		corsSettingsAttrTypes := map[string]attr.Type{
			"behavior": types.StringType,
			"origins":  types.ListType{ElemType: types.StringType},
		}
		var corsSettingsValue types.Object
		if response.ApplicationOIDC.CorsSettings == nil {
			corsSettingsValue = types.ObjectNull(corsSettingsAttrTypes)
		} else {
			corsSettingsBehaviorValue := types.StringValue(string(response.ApplicationOIDC.CorsSettings.Behavior))
			corsSettingsOriginsValue, diags := types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.CorsSettings.Origins)
			respDiags.Append(diags...)
			corsSettingsValue, diags = types.ObjectValue(corsSettingsAttrTypes, map[string]attr.Value{
				"behavior": corsSettingsBehaviorValue,
				"origins":  corsSettingsOriginsValue,
			})
			respDiags.Append(diags...)
		}
		state.CorsSettings = corsSettingsValue
		// ApplicationOIDC - description
		state.Description = types.StringPointerValue(response.ApplicationOIDC.Description)
		// ApplicationOIDC - device_custom_verification_uri
		state.DeviceCustomVerificationUri = types.StringPointerValue(response.ApplicationOIDC.DeviceCustomVerificationUri)
		// ApplicationOIDC - device_path_id
		state.DevicePathId = types.StringPointerValue(response.ApplicationOIDC.DevicePathId)
		// ApplicationOIDC - device_polling_interval
		state.DevicePollingInterval = types.Int32PointerValue(response.ApplicationOIDC.DevicePollingInterval)
		// ApplicationOIDC - device_timeout
		state.DeviceTimeout = types.Int32PointerValue(response.ApplicationOIDC.DeviceTimeout)
		// ApplicationOIDC - enabled
		state.Enabled = types.BoolValue(response.ApplicationOIDC.Enabled)
		// ApplicationOIDC - grant_types
		state.GrantTypes, diags = types.SetValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.GrantTypes)
		respDiags.Append(diags...)
		// ApplicationOIDC - hidden_from_app_portal
		state.HiddenFromAppPortal = types.BoolPointerValue(response.ApplicationOIDC.HiddenFromAppPortal)
		// ApplicationOIDC - home_page_url
		state.HomePageUrl = types.StringPointerValue(response.ApplicationOIDC.HomePageUrl)
		// ApplicationOIDC - icon
		iconAttrTypes := map[string]attr.Type{
			"href": types.StringType,
			"id":   types.StringType,
		}
		var iconValue types.Object
		if response.ApplicationOIDC.Icon == nil {
			iconValue = types.ObjectNull(iconAttrTypes)
		} else {
			iconValue, diags = types.ObjectValue(iconAttrTypes, map[string]attr.Value{
				"href": types.StringValue(response.ApplicationOIDC.Icon.Href),
				"id":   types.StringValue(response.ApplicationOIDC.Icon.Id),
			})
			respDiags.Append(diags...)
		}
		state.Icon = iconValue
		// ApplicationOIDC - id
		idValue := framework.PingOneResourceIDToTF(response.ApplicationOIDC.GetId())
		state.Id = idValue
		// ApplicationOIDC - initiate_login_uri
		state.InitiateLoginUri = types.StringPointerValue(response.ApplicationOIDC.InitiateLoginUri)
		// ApplicationOIDC - jwks
		state.Jwks = types.StringPointerValue(response.ApplicationOIDC.Jwks)
		// ApplicationOIDC - jwks_url
		state.JwksUrl = types.StringPointerValue(response.ApplicationOIDC.JwksUrl)
		// ApplicationOIDC - kerberos
		kerberosKeyAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		kerberosAttrTypes := map[string]attr.Type{
			"key": types.ObjectType{AttrTypes: kerberosKeyAttrTypes},
		}
		var kerberosValue types.Object
		if response.ApplicationOIDC.Kerberos == nil {
			kerberosValue = types.ObjectNull(kerberosAttrTypes)
		} else {
			kerberosKeyValue, diags := types.ObjectValue(kerberosKeyAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationOIDC.Kerberos.Key.Id),
			})
			respDiags.Append(diags...)
			kerberosValue, diags = types.ObjectValue(kerberosAttrTypes, map[string]attr.Value{
				"key": kerberosKeyValue,
			})
			respDiags.Append(diags...)
		}
		state.Kerberos = kerberosValue
		// ApplicationOIDC - login_page_url
		state.LoginPageUrl = types.StringPointerValue(response.ApplicationOIDC.LoginPageUrl)
		// ApplicationOIDC - mobile
		mobileIntegrityDetectionCacheDurationAttrTypes := map[string]attr.Type{
			"amount": types.Int32Type,
			"units":  types.StringType,
		}
		mobileIntegrityDetectionGooglePlayAttrTypes := map[string]attr.Type{
			"decryption_key":              types.StringType,
			"service_account_credentials": types.StringType,
			"verification_key":            types.StringType,
			"verification_type":           types.StringType,
		}
		mobileIntegrityDetectionAttrTypes := map[string]attr.Type{
			"cache_duration":     types.ObjectType{AttrTypes: mobileIntegrityDetectionCacheDurationAttrTypes},
			"excluded_platforms": types.ListType{ElemType: types.StringType},
			"google_play":        types.ObjectType{AttrTypes: mobileIntegrityDetectionGooglePlayAttrTypes},
			"mode":               types.StringType,
		}
		mobilePasscodeRefreshDurationAttrTypes := map[string]attr.Type{
			"duration":  types.Int32Type,
			"time_unit": types.StringType,
		}
		mobileAttrTypes := map[string]attr.Type{
			"bundle_id":                 types.StringType,
			"huawei_app_id":             types.StringType,
			"huawei_package_name":       types.StringType,
			"integrity_detection":       types.ObjectType{AttrTypes: mobileIntegrityDetectionAttrTypes},
			"package_name":              types.StringType,
			"passcode_refresh_duration": types.ObjectType{AttrTypes: mobilePasscodeRefreshDurationAttrTypes},
			"uri_prefix":                types.StringType,
		}
		var mobileValue types.Object
		if response.ApplicationOIDC.Mobile == nil {
			mobileValue = types.ObjectNull(mobileAttrTypes)
		} else {
			var mobileIntegrityDetectionValue types.Object
			if response.ApplicationOIDC.Mobile.IntegrityDetection == nil {
				mobileIntegrityDetectionValue = types.ObjectNull(mobileIntegrityDetectionAttrTypes)
			} else {
				var mobileIntegrityDetectionCacheDurationValue types.Object
				if response.ApplicationOIDC.Mobile.IntegrityDetection.CacheDuration == nil {
					mobileIntegrityDetectionCacheDurationValue = types.ObjectNull(mobileIntegrityDetectionCacheDurationAttrTypes)
				} else {
					var mobileIntegrityDetectionCacheDurationUnitsPtrValue *string
					if response.ApplicationOIDC.Mobile.IntegrityDetection.CacheDuration.Units != nil {
						mobileIntegrityDetectionCacheDurationUnitsStringValue := string(*response.ApplicationOIDC.Mobile.IntegrityDetection.CacheDuration.Units)
						mobileIntegrityDetectionCacheDurationUnitsPtrValue = &mobileIntegrityDetectionCacheDurationUnitsStringValue
					}
					mobileIntegrityDetectionCacheDurationUnitsValue := types.StringPointerValue(mobileIntegrityDetectionCacheDurationUnitsPtrValue)
					mobileIntegrityDetectionCacheDurationValue, diags = types.ObjectValue(mobileIntegrityDetectionCacheDurationAttrTypes, map[string]attr.Value{
						"amount": types.Int32PointerValue(response.ApplicationOIDC.Mobile.IntegrityDetection.CacheDuration.Amount),
						"units":  mobileIntegrityDetectionCacheDurationUnitsValue,
					})
					respDiags.Append(diags...)
				}
				mobileIntegrityDetectionExcludedPlatformsValue, diags := types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.Mobile.IntegrityDetection.ExcludedPlatforms)
				respDiags.Append(diags...)
				var mobileIntegrityDetectionGooglePlayValue types.Object
				if response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay == nil {
					mobileIntegrityDetectionGooglePlayValue = types.ObjectNull(mobileIntegrityDetectionGooglePlayAttrTypes)
				} else {
					var mobileIntegrityDetectionGooglePlayVerificationTypePtrValue *string
					if response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay.VerificationType != nil {
						mobileIntegrityDetectionGooglePlayVerificationTypeStringValue := string(*response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay.VerificationType)
						mobileIntegrityDetectionGooglePlayVerificationTypePtrValue = &mobileIntegrityDetectionGooglePlayVerificationTypeStringValue
					}
					mobileIntegrityDetectionGooglePlayVerificationTypeValue := types.StringPointerValue(mobileIntegrityDetectionGooglePlayVerificationTypePtrValue)
					mobileIntegrityDetectionGooglePlayValue, diags = types.ObjectValue(mobileIntegrityDetectionGooglePlayAttrTypes, map[string]attr.Value{
						"decryption_key":              types.StringPointerValue(response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay.DecryptionKey),
						"service_account_credentials": types.StringPointerValue(response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay.ServiceAccountCredentials),
						"verification_key":            types.StringPointerValue(response.ApplicationOIDC.Mobile.IntegrityDetection.GooglePlay.VerificationKey),
						"verification_type":           mobileIntegrityDetectionGooglePlayVerificationTypeValue,
					})
					respDiags.Append(diags...)
				}
				var mobileIntegrityDetectionModePtrValue *string
				if response.ApplicationOIDC.Mobile.IntegrityDetection.Mode != nil {
					mobileIntegrityDetectionModeStringValue := string(*response.ApplicationOIDC.Mobile.IntegrityDetection.Mode)
					mobileIntegrityDetectionModePtrValue = &mobileIntegrityDetectionModeStringValue
				}
				mobileIntegrityDetectionModeValue := types.StringPointerValue(mobileIntegrityDetectionModePtrValue)
				mobileIntegrityDetectionValue, diags = types.ObjectValue(mobileIntegrityDetectionAttrTypes, map[string]attr.Value{
					"cache_duration":     mobileIntegrityDetectionCacheDurationValue,
					"excluded_platforms": mobileIntegrityDetectionExcludedPlatformsValue,
					"google_play":        mobileIntegrityDetectionGooglePlayValue,
					"mode":               mobileIntegrityDetectionModeValue,
				})
				respDiags.Append(diags...)
			}
			var mobilePasscodeRefreshDurationValue types.Object
			if response.ApplicationOIDC.Mobile.PasscodeRefreshDuration == nil {
				mobilePasscodeRefreshDurationValue = types.ObjectNull(mobilePasscodeRefreshDurationAttrTypes)
			} else {
				mobilePasscodeRefreshDurationTimeUnitValue := types.StringValue(string(response.ApplicationOIDC.Mobile.PasscodeRefreshDuration.TimeUnit))
				mobilePasscodeRefreshDurationValue, diags = types.ObjectValue(mobilePasscodeRefreshDurationAttrTypes, map[string]attr.Value{
					"duration":  types.Int32Value(response.ApplicationOIDC.Mobile.PasscodeRefreshDuration.Duration),
					"time_unit": mobilePasscodeRefreshDurationTimeUnitValue,
				})
				respDiags.Append(diags...)
			}
			mobileValue, diags = types.ObjectValue(mobileAttrTypes, map[string]attr.Value{
				"bundle_id":                 types.StringPointerValue(response.ApplicationOIDC.Mobile.BundleId),
				"huawei_app_id":             types.StringPointerValue(response.ApplicationOIDC.Mobile.HuaweiAppId),
				"huawei_package_name":       types.StringPointerValue(response.ApplicationOIDC.Mobile.HuaweiPackageName),
				"integrity_detection":       mobileIntegrityDetectionValue,
				"package_name":              types.StringPointerValue(response.ApplicationOIDC.Mobile.PackageName),
				"passcode_refresh_duration": mobilePasscodeRefreshDurationValue,
				"uri_prefix":                types.StringPointerValue(response.ApplicationOIDC.Mobile.UriPrefix),
			})
			respDiags.Append(diags...)
		}
		state.Mobile = mobileValue
		// ApplicationOIDC - name
		state.Name = types.StringValue(response.ApplicationOIDC.Name)
		// ApplicationOIDC - package_name
		state.PackageName = types.StringPointerValue(response.ApplicationOIDC.PackageName)
		// ApplicationOIDC - par_requirement
		var parRequirementPtrValue *string
		if response.ApplicationOIDC.ParRequirement != nil {
			parRequirementStringValue := string(*response.ApplicationOIDC.ParRequirement)
			parRequirementPtrValue = &parRequirementStringValue
		}
		parRequirementValue := types.StringPointerValue(parRequirementPtrValue)
		state.ParRequirement = parRequirementValue
		// ApplicationOIDC - par_timeout
		state.ParTimeout = types.Int32PointerValue(response.ApplicationOIDC.ParTimeout)
		// ApplicationOIDC - pkce_enforcement
		var pkceEnforcementPtrValue *string
		if response.ApplicationOIDC.PkceEnforcement != nil {
			pkceEnforcementStringValue := string(*response.ApplicationOIDC.PkceEnforcement)
			pkceEnforcementPtrValue = &pkceEnforcementStringValue
		}
		pkceEnforcementValue := types.StringPointerValue(pkceEnforcementPtrValue)
		state.PkceEnforcement = pkceEnforcementValue
		// ApplicationOIDC - post_logout_redirect_uris
		state.PostLogoutRedirectUris, diags = types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.PostLogoutRedirectUris)
		respDiags.Append(diags...)
		// ApplicationOIDC - protocol
		protocolValue := types.StringValue(string(response.ApplicationOIDC.Protocol))
		state.Protocol = protocolValue
		// ApplicationOIDC - redirect_uris
		state.RedirectUris, diags = types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.RedirectUris)
		respDiags.Append(diags...)
		// ApplicationOIDC - refresh_token_duration
		state.RefreshTokenDuration = types.Int32PointerValue(response.ApplicationOIDC.RefreshTokenDuration)
		// ApplicationOIDC - refresh_token_rolling_duration
		state.RefreshTokenRollingDuration = types.Int32PointerValue(response.ApplicationOIDC.RefreshTokenRollingDuration)
		// ApplicationOIDC - refresh_token_rolling_grace_period_duration
		state.RefreshTokenRollingGracePeriodDuration = types.Int32PointerValue(response.ApplicationOIDC.RefreshTokenRollingGracePeriodDuration)
		// ApplicationOIDC - require_signed_request_object
		state.RequireSignedRequestObject = types.BoolPointerValue(response.ApplicationOIDC.RequireSignedRequestObject)
		// ApplicationOIDC - response_types
		state.ResponseTypes, diags = types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.ResponseTypes)
		respDiags.Append(diags...)
		// ApplicationOIDC - signing
		signingKeyRotationPolicyAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		signingAttrTypes := map[string]attr.Type{
			"key_rotation_policy": types.ObjectType{AttrTypes: signingKeyRotationPolicyAttrTypes},
		}
		var signingValue types.Object
		if response.ApplicationOIDC.Signing == nil {
			signingValue = types.ObjectNull(signingAttrTypes)
		} else {
			signingKeyRotationPolicyValue, diags := types.ObjectValue(signingKeyRotationPolicyAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationOIDC.Signing.KeyRotationPolicy.Id),
			})
			respDiags.Append(diags...)
			signingValue, diags = types.ObjectValue(signingAttrTypes, map[string]attr.Value{
				"key_rotation_policy": signingKeyRotationPolicyValue,
			})
			respDiags.Append(diags...)
		}
		state.Signing = signingValue
		// ApplicationOIDC - support_unsigned_request_object
		state.SupportUnsignedRequestObject = types.BoolPointerValue(response.ApplicationOIDC.SupportUnsignedRequestObject)
		// ApplicationOIDC - tags
		state.Tags, diags = types.ListValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.Tags)
		respDiags.Append(diags...)
		// ApplicationOIDC - target_link_uri
		state.TargetLinkUri = types.StringPointerValue(response.ApplicationOIDC.TargetLinkUri)
		// ApplicationOIDC - template
		templateIntegrationAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		templateVersionAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		templateAttrTypes := map[string]attr.Type{
			"configuration": types.MapType{ElemType: types.StringType},
			"integration":   types.ObjectType{AttrTypes: templateIntegrationAttrTypes},
			"version":       types.ObjectType{AttrTypes: templateVersionAttrTypes},
		}
		var templateValue types.Object
		if response.ApplicationOIDC.Template == nil {
			templateValue = types.ObjectNull(templateAttrTypes)
		} else {
			templateConfigurationValue, diags := types.MapValueFrom(context.Background(), types.StringType, response.ApplicationOIDC.Template.Configuration)
			respDiags.Append(diags...)
			templateIntegrationValue, diags := types.ObjectValue(templateIntegrationAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationOIDC.Template.Integration.Id),
			})
			respDiags.Append(diags...)
			templateVersionValue, diags := types.ObjectValue(templateVersionAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationOIDC.Template.Version.Id),
			})
			respDiags.Append(diags...)
			templateValue, diags = types.ObjectValue(templateAttrTypes, map[string]attr.Value{
				"configuration": templateConfigurationValue,
				"integration":   templateIntegrationValue,
				"version":       templateVersionValue,
			})
			respDiags.Append(diags...)
		}
		state.Template = templateValue
		// ApplicationOIDC - token_endpoint_auth_method
		tokenEndpointAuthMethodValue := types.StringValue(string(response.ApplicationOIDC.TokenEndpointAuthMethod))
		state.TokenEndpointAuthMethod = tokenEndpointAuthMethodValue
		// ApplicationOIDC - type
		typeValue := types.StringValue(string(response.ApplicationOIDC.Type))
		state.Type = typeValue
	case response.ApplicationSAML != nil:
		// ApplicationSAML - access_control
		accessControlGroupGroupsAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		accessControlGroupGroupsElementType := types.ObjectType{AttrTypes: accessControlGroupGroupsAttrTypes}
		accessControlGroupAttrTypes := map[string]attr.Type{
			"groups": types.ListType{ElemType: accessControlGroupGroupsElementType},
			"type":   types.StringType,
		}
		accessControlRoleAttrTypes := map[string]attr.Type{
			"type": types.StringType,
		}
		accessControlAttrTypes := map[string]attr.Type{
			"group": types.ObjectType{AttrTypes: accessControlGroupAttrTypes},
			"role":  types.ObjectType{AttrTypes: accessControlRoleAttrTypes},
		}
		var accessControlValue types.Object
		if response.ApplicationSAML.AccessControl == nil {
			accessControlValue = types.ObjectNull(accessControlAttrTypes)
		} else {
			var accessControlGroupValue types.Object
			if response.ApplicationSAML.AccessControl.Group == nil {
				accessControlGroupValue = types.ObjectNull(accessControlGroupAttrTypes)
			} else {
				var accessControlGroupGroupsValues []attr.Value
				for _, accessControlGroupGroupsResponseValue := range response.ApplicationSAML.AccessControl.Group.Groups {
					accessControlGroupGroupsValue, diags := types.ObjectValue(accessControlGroupGroupsAttrTypes, map[string]attr.Value{
						"id": types.StringValue(accessControlGroupGroupsResponseValue.Id),
					})
					respDiags.Append(diags...)
					accessControlGroupGroupsValues = append(accessControlGroupGroupsValues, accessControlGroupGroupsValue)
				}
				accessControlGroupGroupsValue, diags := types.ListValue(accessControlGroupGroupsElementType, accessControlGroupGroupsValues)
				respDiags.Append(diags...)
				accessControlGroupTypeValue := types.StringValue(string(response.ApplicationSAML.AccessControl.Group.Type))
				accessControlGroupValue, diags = types.ObjectValue(accessControlGroupAttrTypes, map[string]attr.Value{
					"groups": accessControlGroupGroupsValue,
					"type":   accessControlGroupTypeValue,
				})
				respDiags.Append(diags...)
			}
			var accessControlRoleValue types.Object
			if response.ApplicationSAML.AccessControl.Role == nil {
				accessControlRoleValue = types.ObjectNull(accessControlRoleAttrTypes)
			} else {
				accessControlRoleTypeValue := types.StringValue(string(response.ApplicationSAML.AccessControl.Role.Type))
				accessControlRoleValue, diags = types.ObjectValue(accessControlRoleAttrTypes, map[string]attr.Value{
					"type": accessControlRoleTypeValue,
				})
				respDiags.Append(diags...)
			}
			accessControlValue, diags = types.ObjectValue(accessControlAttrTypes, map[string]attr.Value{
				"group": accessControlGroupValue,
				"role":  accessControlRoleValue,
			})
			respDiags.Append(diags...)
		}
		state.AccessControl = accessControlValue
		// ApplicationSAML - acs_urls
		state.AcsUrls, diags = types.ListValueFrom(context.Background(), types.StringType, response.ApplicationSAML.AcsUrls)
		respDiags.Append(diags...)
		// ApplicationSAML - assertion_duration
		state.AssertionDuration = types.Int32Value(response.ApplicationSAML.AssertionDuration)
		// ApplicationSAML - assertion_signed
		state.AssertionSigned = types.BoolPointerValue(response.ApplicationSAML.AssertionSigned)
		// ApplicationSAML - cors_settings
		corsSettingsAttrTypes := map[string]attr.Type{
			"behavior": types.StringType,
			"origins":  types.ListType{ElemType: types.StringType},
		}
		var corsSettingsValue types.Object
		if response.ApplicationSAML.CorsSettings == nil {
			corsSettingsValue = types.ObjectNull(corsSettingsAttrTypes)
		} else {
			corsSettingsBehaviorValue := types.StringValue(string(response.ApplicationSAML.CorsSettings.Behavior))
			corsSettingsOriginsValue, diags := types.ListValueFrom(context.Background(), types.StringType, response.ApplicationSAML.CorsSettings.Origins)
			respDiags.Append(diags...)
			corsSettingsValue, diags = types.ObjectValue(corsSettingsAttrTypes, map[string]attr.Value{
				"behavior": corsSettingsBehaviorValue,
				"origins":  corsSettingsOriginsValue,
			})
			respDiags.Append(diags...)
		}
		state.CorsSettings = corsSettingsValue
		// ApplicationSAML - default_target_url
		state.DefaultTargetUrl = types.StringPointerValue(response.ApplicationSAML.DefaultTargetUrl)
		// ApplicationSAML - description
		state.Description = types.StringPointerValue(response.ApplicationSAML.Description)
		// ApplicationSAML - enable_requested_authn_context
		state.EnableRequestedAuthnContext = types.BoolPointerValue(response.ApplicationSAML.EnableRequestedAuthnContext)
		// ApplicationSAML - enabled
		state.Enabled = types.BoolValue(response.ApplicationSAML.Enabled)
		// ApplicationSAML - hidden_from_app_portal
		state.HiddenFromAppPortal = types.BoolPointerValue(response.ApplicationSAML.HiddenFromAppPortal)
		// ApplicationSAML - home_page_url
		state.HomePageUrl = types.StringPointerValue(response.ApplicationSAML.HomePageUrl)
		// ApplicationSAML - icon
		iconAttrTypes := map[string]attr.Type{
			"href": types.StringType,
			"id":   types.StringType,
		}
		var iconValue types.Object
		if response.ApplicationSAML.Icon == nil {
			iconValue = types.ObjectNull(iconAttrTypes)
		} else {
			iconValue, diags = types.ObjectValue(iconAttrTypes, map[string]attr.Value{
				"href": types.StringValue(response.ApplicationSAML.Icon.Href),
				"id":   types.StringValue(response.ApplicationSAML.Icon.Id),
			})
			respDiags.Append(diags...)
		}
		state.Icon = iconValue
		// ApplicationSAML - id
		idValue := framework.PingOneResourceIDToTF(response.ApplicationSAML.GetId())
		state.Id = idValue
		// ApplicationSAML - idp_signing
		idpSigningKeyAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		idpSigningAttrTypes := map[string]attr.Type{
			"algorithm": types.StringType,
			"key":       types.ObjectType{AttrTypes: idpSigningKeyAttrTypes},
		}
		var idpSigningValue types.Object
		if response.ApplicationSAML.IdpSigning == nil {
			idpSigningValue = types.ObjectNull(idpSigningAttrTypes)
		} else {
			var idpSigningAlgorithmPtrValue *string
			if response.ApplicationSAML.IdpSigning.Algorithm != nil {
				idpSigningAlgorithmStringValue := string(*response.ApplicationSAML.IdpSigning.Algorithm)
				idpSigningAlgorithmPtrValue = &idpSigningAlgorithmStringValue
			}
			idpSigningAlgorithmValue := types.StringPointerValue(idpSigningAlgorithmPtrValue)
			idpSigningKeyValue, diags := types.ObjectValue(idpSigningKeyAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationSAML.IdpSigning.Key.Id),
			})
			respDiags.Append(diags...)
			idpSigningValue, diags = types.ObjectValue(idpSigningAttrTypes, map[string]attr.Value{
				"algorithm": idpSigningAlgorithmValue,
				"key":       idpSigningKeyValue,
			})
			respDiags.Append(diags...)
		}
		state.IdpSigning = idpSigningValue
		// ApplicationSAML - login_page_url
		state.LoginPageUrl = types.StringPointerValue(response.ApplicationSAML.LoginPageUrl)
		// ApplicationSAML - name
		state.Name = types.StringValue(response.ApplicationSAML.Name)
		// ApplicationSAML - name_id_format
		state.NameIdFormat = types.StringPointerValue(response.ApplicationSAML.NameIdFormat)
		// ApplicationSAML - protocol
		protocolValue := types.StringValue(string(response.ApplicationSAML.Protocol))
		state.Protocol = protocolValue
		// ApplicationSAML - response_signed
		state.ResponseSigned = types.BoolPointerValue(response.ApplicationSAML.ResponseSigned)
		// ApplicationSAML - session_not_on_or_after_duration
		state.SessionNotOnOrAfterDuration = types.Int32PointerValue(response.ApplicationSAML.SessionNotOnOrAfterDuration)
		// ApplicationSAML - slo_binding
		var sloBindingPtrValue *string
		if response.ApplicationSAML.SloBinding != nil {
			sloBindingStringValue := string(*response.ApplicationSAML.SloBinding)
			sloBindingPtrValue = &sloBindingStringValue
		}
		sloBindingValue := types.StringPointerValue(sloBindingPtrValue)
		state.SloBinding = sloBindingValue
		// ApplicationSAML - slo_endpoint
		state.SloEndpoint = types.StringPointerValue(response.ApplicationSAML.SloEndpoint)
		// ApplicationSAML - slo_response_endpoint
		state.SloResponseEndpoint = types.StringPointerValue(response.ApplicationSAML.SloResponseEndpoint)
		// ApplicationSAML - slo_window
		state.SloWindow = types.Int32PointerValue(response.ApplicationSAML.SloWindow)
		// ApplicationSAML - sp_encryption
		spEncryptionCertificateAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		spEncryptionAttrTypes := map[string]attr.Type{
			"algorithm":   types.StringType,
			"certificate": types.ObjectType{AttrTypes: spEncryptionCertificateAttrTypes},
		}
		var spEncryptionValue types.Object
		if response.ApplicationSAML.SpEncryption == nil {
			spEncryptionValue = types.ObjectNull(spEncryptionAttrTypes)
		} else {
			spEncryptionAlgorithmValue := types.StringValue(string(response.ApplicationSAML.SpEncryption.Algorithm))
			spEncryptionCertificateValue, diags := types.ObjectValue(spEncryptionCertificateAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationSAML.SpEncryption.Certificate.Id),
			})
			respDiags.Append(diags...)
			spEncryptionValue, diags = types.ObjectValue(spEncryptionAttrTypes, map[string]attr.Value{
				"algorithm":   spEncryptionAlgorithmValue,
				"certificate": spEncryptionCertificateValue,
			})
			respDiags.Append(diags...)
		}
		state.SpEncryption = spEncryptionValue
		// ApplicationSAML - sp_entity_id
		state.SpEntityId = types.StringValue(response.ApplicationSAML.SpEntityId)
		// ApplicationSAML - sp_verification
		spVerificationCertificatesAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		spVerificationCertificatesElementType := types.ObjectType{AttrTypes: spVerificationCertificatesAttrTypes}
		spVerificationAttrTypes := map[string]attr.Type{
			"authn_request_signed": types.BoolType,
			"certificates":         types.ListType{ElemType: spVerificationCertificatesElementType},
		}
		var spVerificationValue types.Object
		if response.ApplicationSAML.SpVerification == nil {
			spVerificationValue = types.ObjectNull(spVerificationAttrTypes)
		} else {
			var spVerificationCertificatesValues []attr.Value
			for _, spVerificationCertificatesResponseValue := range response.ApplicationSAML.SpVerification.Certificates {
				spVerificationCertificatesValue, diags := types.ObjectValue(spVerificationCertificatesAttrTypes, map[string]attr.Value{
					"id": types.StringValue(spVerificationCertificatesResponseValue.Id),
				})
				respDiags.Append(diags...)
				spVerificationCertificatesValues = append(spVerificationCertificatesValues, spVerificationCertificatesValue)
			}
			spVerificationCertificatesValue, diags := types.ListValue(spVerificationCertificatesElementType, spVerificationCertificatesValues)
			respDiags.Append(diags...)
			spVerificationValue, diags = types.ObjectValue(spVerificationAttrTypes, map[string]attr.Value{
				"authn_request_signed": types.BoolPointerValue(response.ApplicationSAML.SpVerification.AuthnRequestSigned),
				"certificates":         spVerificationCertificatesValue,
			})
			respDiags.Append(diags...)
		}
		state.SpVerification = spVerificationValue
		// ApplicationSAML - template
		templateIntegrationAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		templateVersionAttrTypes := map[string]attr.Type{
			"id": types.StringType,
		}
		templateAttrTypes := map[string]attr.Type{
			"configuration": types.MapType{ElemType: types.StringType},
			"integration":   types.ObjectType{AttrTypes: templateIntegrationAttrTypes},
			"version":       types.ObjectType{AttrTypes: templateVersionAttrTypes},
		}
		var templateValue types.Object
		if response.ApplicationSAML.Template == nil {
			templateValue = types.ObjectNull(templateAttrTypes)
		} else {
			templateConfigurationValue, diags := types.MapValueFrom(context.Background(), types.StringType, response.ApplicationSAML.Template.Configuration)
			respDiags.Append(diags...)
			templateIntegrationValue, diags := types.ObjectValue(templateIntegrationAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationSAML.Template.Integration.Id),
			})
			respDiags.Append(diags...)
			templateVersionValue, diags := types.ObjectValue(templateVersionAttrTypes, map[string]attr.Value{
				"id": types.StringValue(response.ApplicationSAML.Template.Version.Id),
			})
			respDiags.Append(diags...)
			templateValue, diags = types.ObjectValue(templateAttrTypes, map[string]attr.Value{
				"configuration": templateConfigurationValue,
				"integration":   templateIntegrationValue,
				"version":       templateVersionValue,
			})
			respDiags.Append(diags...)
		}
		state.Template = templateValue
		// ApplicationSAML - type
		typeValue := types.StringValue(string(response.ApplicationSAML.Type))
		state.Type = typeValue
	}
	return respDiags
}

func (r *applicationv2Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data applicationv2ResourceModel

	if r.Client == nil || r.Client.ManagementAPIClient == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Create API call logic
	clientData, _, diags := data.buildClientStruct()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	var createResponseData *management.CreateApplication201Response
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.ManagementAPIClient.ApplicationsApi.CreateApplication(ctx, data.EnvironmentId.ValueString()).CreateApplicationRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client.ManagementAPIClient, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"CreateApplication",
		framework.DefaultCustomError,
		sdk.DefaultCreateReadRetryable,
		&createResponseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	responseData := &management.ReadOneApplication200Response{
		ApplicationOIDC:         createResponseData.ApplicationOIDC,
		ApplicationSAML:         createResponseData.ApplicationSAML,
		ApplicationExternalLink: createResponseData.ApplicationExternalLink,
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *applicationv2Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data applicationv2ResourceModel

	if r.Client == nil || r.Client.ManagementAPIClient == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read API call logic
	var responseData *management.ReadOneApplication200Response
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.ManagementAPIClient.ApplicationsApi.ReadOneApplication(ctx, data.EnvironmentId.ValueString(), data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client.ManagementAPIClient, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"ReadOneApplication",
		framework.CustomErrorResourceNotFoundWarning,
		sdk.DefaultCreateReadRetryable,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Remove from state if resource is not found
	if responseData == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *applicationv2Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data applicationv2ResourceModel

	if r.Client == nil || r.Client.ManagementAPIClient == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Update API call logic
	_, clientData, diags := data.buildClientStruct()
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	var responseData *management.ReadOneApplication200Response
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fO, fR, fErr := r.Client.ManagementAPIClient.ApplicationsApi.UpdateApplication(ctx, data.EnvironmentId.ValueString(), data.Id.ValueString()).UpdateApplicationRequest(*clientData).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client.ManagementAPIClient, data.EnvironmentId.ValueString(), fO, fR, fErr)
		},
		"UpdateApplication",
		framework.DefaultCustomError,
		nil,
		&responseData,
	)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Read response into the model
	resp.Diagnostics.Append(data.readClientResponse(responseData)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *applicationv2Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data applicationv2ResourceModel

	if r.Client == nil || r.Client.ManagementAPIClient == nil {
		resp.Diagnostics.AddError(
			"Client not initialized",
			"Expected the PingOne client, got nil.  Please report this issue to the provider maintainers.")
		return
	}

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Delete API call logic
	resp.Diagnostics.Append(framework.ParseResponse(
		ctx,

		func() (any, *http.Response, error) {
			fR, fErr := r.Client.ManagementAPIClient.ApplicationsApi.DeleteApplication(ctx, data.EnvironmentId.ValueString(), data.Id.ValueString()).Execute()
			return framework.CheckEnvironmentExistsOnPermissionsError(ctx, r.Client.ManagementAPIClient, data.EnvironmentId.ValueString(), nil, fR, fErr)
		},
		"DeleteApplication",
		framework.CustomErrorResourceNotFoundWarning,
		nil,
		nil,
	)...)
}

func (r *applicationv2Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	idComponents := []framework.ImportComponent{
		{
			Label:  "environment_id",
			Regexp: verify.P1ResourceIDRegexp,
		},
		{
			Label:     "applicationv2_id",
			Regexp:    verify.P1ResourceIDRegexp,
			PrimaryID: true,
		},
	}

	attributes, err := framework.ParseImportID(req.ID, idComponents...)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			err.Error(),
		)
		return
	}

	for _, idComponent := range idComponents {
		pathKey := idComponent.Label

		if idComponent.PrimaryID {
			pathKey = "id"
		}

		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root(pathKey), attributes[idComponent.Label])...)
	}
}
